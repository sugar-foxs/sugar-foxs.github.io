---
layout:     post
title:      mybatis加载配置
subtitle:   
date:       2019-12-29 23:00:00
author:     sugar-foxs
catalog: 	true
tags:
    - mybatis
    - spring
---

> 这篇文章主要看下mybatis的配置文件配置了哪些东西，做了什么工作。
查看源码可以追踪到XMLConfigBuilder类，这个类主要是做加载配置工作，生成Configution。通过Configuration新建SqlSessionFactory，这个以后再细看，这篇主要看加载配置过程。
<!-- more -->

# XMLConfigBuilder
- 先看下这个类的代码，主要代码如下，

```java
public Configuration parse() {
    if (parsed) {
      throw new BuilderException("Each XMLConfigBuilder can only be used once.");
    }
    parsed = true;
    // 从根节点configuration开始解析
    parseConfiguration(parser.evalNode("/configuration"));
    return configuration;
  }

  private void parseConfiguration(XNode root) {
    try {
      Properties settings = settingsAsPropertiess(root.evalNode("settings"));
      //issue #117 read properties first
      propertiesElement(root.evalNode("properties"));
      loadCustomVfs(settings);
      typeAliasesElement(root.evalNode("typeAliases"));
      pluginElement(root.evalNode("plugins"));
      objectFactoryElement(root.evalNode("objectFactory"));
      objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
      reflectionFactoryElement(root.evalNode("reflectionFactory"));
      settingsElement(settings);
      // read it after objectFactory and objectWrapperFactory issue #631
      environmentsElement(root.evalNode("environments"));
      databaseIdProviderElement(root.evalNode("databaseIdProvider"));
      typeHandlerElement(root.evalNode("typeHandlers"));
      mapperElement(root.evalNode("mappers"));
    } catch (Exception e) {
      throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);
    }
  }
```
- 从上面代码能够看到，在根节点下配置了10个子节点， 分别为：properties、typeAliases、plugins、objectFactory、objectWrapperFactory、settings、environments、databaseIdProvider、typeHandlers、mappers。

下面分别对10个子节点进行解析,进入具体的方法中找寻答案：

## properties
- 一起看下代码，注释写在其中：
```java
private void propertiesElement(XNode context) throws Exception {
    if (context != null) {
      // 获取properties所有子节点property作为default，其实就是一个map
      Properties defaults = context.getChildrenAsProperties();
      // properties有resource和url属性，接着往下看
      String resource = context.getStringAttribute("resource");
      String url = context.getStringAttribute("url");
      // 这里表明resource和url只能有一个
      if (resource != null && url != null) {
        throw new BuilderException("The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.");
      }
      // 接下来是对resource和url的不同处理
      // 获取到的k-v如果有相同k会覆盖之前property节点的值,因为是map，所以会覆盖
      if (resource != null) {
        defaults.putAll(Resources.getResourceAsProperties(resource));
      } else if (url != null) {
        defaults.putAll(Resources.getUrlAsProperties(url));
      }
      // 将这个节点下的配置加入到全局的configuration和parser中。
      Properties vars = configuration.getVariables();
      if (vars != null) {
        defaults.putAll(vars);
      }
      parser.setVariables(defaults);
      configuration.setVariables(defaults);
    }
  }
```
- 接下来看下resource和url有什么不同：
```java
public static Properties getResourceAsProperties(String resource) throws IOException {
    Properties props = new Properties();
    InputStream in = getResourceAsStream(resource);
    props.load(in);
    in.close();
    return props;
}

public static Properties getUrlAsProperties(String urlString) throws IOException {
    Properties props = new Properties();
    InputStream in = getUrlAsStream(urlString);
    props.load(in);
    in.close();
    return props;
}

// 可以看到差别只在getResourceAsStream和getUrlAsStream方法之间，他们的入参不同，返回对象相同。分别看到最底层方法。

public static InputStream getResourceAsStream(ClassLoader loader, String resource) throws IOException {
    InputStream in = classLoaderWrapper.getResourceAsStream(resource, loader);
    if (in == null) {
      throw new IOException("Could not find resource " + resource);
    }
    return in;
}
public static InputStream getUrlAsStream(String urlString) throws IOException {
    URL url = new URL(urlString);
    URLConnection conn = url.openConnection();
    return conn.getInputStream();
}
```
- resource是用来引入类路径下的资源，url是用来引入网络路径的资源，两者只能选其一。
- 共同点都是转成流获取到属性，只是获取的源头不一样而已。

## typeAliases
- 下面看下typeAliases节点，主要用途是定义别名
```java
private void typeAliasesElement(XNode parent) {
    if (parent != null) {
      for (XNode child : parent.getChildren()) {

        //子节点如果是package，即指定包名，该包下的类都会有别名，别名默认是转成小写
        //也可以使用@Alias注解进行加别名，这个优先级比在配置文件里写的要高
        if ("package".equals(child.getName())) {
          String typeAliasPackage = child.getStringAttribute("name");
          configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);
        } else {
          // 这里是typeAlias子节点，一个一个进行设置别名
          String alias = child.getStringAttribute("alias");
          String type = child.getStringAttribute("type");
          try {
            Class<?> clazz = Resources.classForName(type);
            if (alias == null) {
              typeAliasRegistry.registerAlias(clazz);
            } else {
              typeAliasRegistry.registerAlias(alias, clazz);
            }
          } catch (ClassNotFoundException e) {
            throw new BuilderException("Error registering typeAlias for '" + alias + "'. Cause: " + e, e);
          }
        }
      }
    }
  }
```

## plugins
```
private void pluginElement(XNode parent) throws Exception {
    if (parent != null) {
      for (XNode child : parent.getChildren()) {
        // 解析每个Interceptor节点，生成Interceptor对象，并设置属性，加入到拦截器链中
        String interceptor = child.getStringAttribute("interceptor");
        Properties properties = child.getChildrenAsProperties();
        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();
        interceptorInstance.setProperties(properties);
        configuration.addInterceptor(interceptorInstance);
      }
    }
}
```
Interceptor有三个方法：intercept,plugin,setProperties。setProperties是用来设置属性给拦截器使用，主要方法是intercept和plugin。拦截器示例可见{% post_link 2019-12-29-mybatis拦截器分页 %}
- @Intercepts({ @Signature(type = StatementHandler.class, method = "prepare", args = { Connection.class, Integer.class }) })
  - 此注解是表名拦截那个类的哪个方法和方法的入参类型。其实就是拦截的规则，对哪些方法进行拦截。
  - 也可以写同一个类的不同方法，即对同一个类的不同方法进行拦截。

- interceptor ，该方法是拦截后的操作。

- plugin ,该方法一般这么写，Plugin.wrap(o, this); 作用是为目标类生成代理类。Plugin实现了InvocationHandler，熟悉动态代理的就知道了。

```java
  public static Object wrap(Object target, Interceptor interceptor) {
  Map<Class<?>, Set<Method>> signatureMap = getSignatureMap(interceptor);
  Class<?> type = target.getClass();
  Class<?>[] interfaces = getAllInterfaces(type, signatureMap);
  // 目标类的接口和Intercepts注解中signature的类有相同的，即符合注解中规则的，为其生成代理类
  if (interfaces.length > 0) {
    return Proxy.newProxyInstance(
        type.getClassLoader(),
        interfaces,
        new Plugin(target, interceptor, signatureMap));
  }
  return target;
}
```

下面看下代理类的执行方法：

```java
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  try {
    Set<Method> methods = signatureMap.get(method.getDeclaringClass());
    if (methods != null && methods.contains(method)) {
      // 这里便是执行我们自己写的拦截器的intercept方法
      return interceptor.intercept(new Invocation(target, method, args));
    }
    return method.invoke(target, args);
  } catch (Exception e) {
    throw ExceptionUtil.unwrapThrowable(e);
  }
}
```

## objectFactory
```java
private void objectFactoryElement(XNode context) throws Exception {
  if (context != null) {
    // type是对象工厂类的类名,默认是DefaultObjectFactory
    String type = context.getStringAttribute("type");
    Properties properties = context.getChildrenAsProperties();
    ObjectFactory factory = (ObjectFactory) resolveClass(type).newInstance();
    // 设置属性
    factory.setProperties(properties);
    configuration.setObjectFactory(factory);
  }
}
```
- 知道了这个标签是生成对象工厂类，但是对象工厂类到底是做什么用的？
- 我们看先默认的对象工厂类DefaultObjectFactory
```java
public class DefaultObjectFactory implements ObjectFactory, Serializable {

  private static final long serialVersionUID = -8855120656740914948L;

  @Override
  public <T> T create(Class<T> type) {
    return create(type, null, null);
  }

  @SuppressWarnings("unchecked")
  @Override
  public <T> T create(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs) {
    Class<?> classToCreate = resolveInterface(type);
    // we know types are assignable
    return (T) instantiateClass(classToCreate, constructorArgTypes, constructorArgs);
  }

  @Override
  public void setProperties(Properties properties) {
    // no props for default
  }

  <T> T instantiateClass(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs) {
    try {
      Constructor<T> constructor;
      if (constructorArgTypes == null || constructorArgs == null) {
        constructor = type.getDeclaredConstructor();
        if (!constructor.isAccessible()) {
          constructor.setAccessible(true);
        }
        return constructor.newInstance();
      }
      constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(new Class[constructorArgTypes.size()]));
      if (!constructor.isAccessible()) {
        constructor.setAccessible(true);
      }
      return constructor.newInstance(constructorArgs.toArray(new Object[constructorArgs.size()]));
    } catch (Exception e) {
      StringBuilder argTypes = new StringBuilder();
      if (constructorArgTypes != null && !constructorArgTypes.isEmpty()) {
        for (Class<?> argType : constructorArgTypes) {
          argTypes.append(argType.getSimpleName());
          argTypes.append(",");
        }
        argTypes.deleteCharAt(argTypes.length() - 1); // remove trailing ,
      }
      StringBuilder argValues = new StringBuilder();
      if (constructorArgs != null && !constructorArgs.isEmpty()) {
        for (Object argValue : constructorArgs) {
          argValues.append(String.valueOf(argValue));
          argValues.append(",");
        }
        argValues.deleteCharAt(argValues.length() - 1); // remove trailing ,
      }
      throw new ReflectionException("Error instantiating " + type + " with invalid types (" + argTypes + ") or values (" + argValues + "). Cause: " + e, e);
    }
  }

  protected Class<?> resolveInterface(Class<?> type) {
    Class<?> classToCreate;
    if (type == List.class || type == Collection.class || type == Iterable.class) {
      classToCreate = ArrayList.class;
    } else if (type == Map.class) {
      classToCreate = HashMap.class;
    } else if (type == SortedSet.class) { // issue #510 Collections Support
      classToCreate = TreeSet.class;
    } else if (type == Set.class) {
      classToCreate = HashSet.class;
    } else {
      classToCreate = type;
    }
    return classToCreate;
  }

  @Override
  public <T> boolean isCollection(Class<T> type) {
    return Collection.class.isAssignableFrom(type);
  }

}
```


## objectWrapperFactory

## settings

## environments

## databaseIdProvider

## typeHandlers

## mappers

# 总结
- properties节点首先读取子节点property属性，然后从由resource或者url标记的地方获取属性，有相同key的属性会覆盖之前读取的值。