---
layout:     post
title:      java类加载
subtitle:   
date:       2020-03-15
author:     sugar-foxs
catalog: 	true
tags:
    - java
    - jvm
---

本文介绍下java类加载的过程。
<!-- more -->

# 类加载的过程
## 加载阶段
- 加载二进制字节流，将这个字节流代表的静态存储结构转化为方法区的运行时数据结构，在内存中生成Class对象，作为方法区这个类的各种数据的访问入口。
## 验证阶段
- 文件格式验证，元数据验证，字节码验证，符号引用验证。
## 准备阶段
- 为类变量分配内存并设置类变量初始值。这里的初始值是数据类型的零值。程序员设置的值在初始化阶段设置。
## 解析阶段
- 将常量池内的符号引用转化为直接引用。类或接口的解析，字段解析，类方法解析，接口方法解析。
## 初始化
- 初始化类变量和其他资源。即执行类构造器clinit方法的过程。clinit方法是由类中所有类变量的赋值动作和静态语句块中的语句合并产生。
- 遇到以下5种情况时，必须立即对类进行初始化。
    - 遇到new,getstatic,putstatic,invokestati这4条字节码指令时，如果类没有进行过初始化，需要先触发初始化。对应这4条字节码指令的场景是：new一个对象，获取或者设置一个类的静态字段时，调用一个类的静态方法时。
    - 使用反射包的方法对类进行反射调用时，如果类没有进行过初始化，需要先触发初始化。
    - 当初始化一个类时，如果发现它的父类没有初始化，需要先初始化其父类。
    - 虚拟机启动时执行的主类，需要先进行初始化。
    - 当使用动态语言支持时，如果一个java.lang.invoke.MethodHandler 实例最后的解析结果的方法句柄对应的类没有进行过初始化，需要先进行初始化。

# 双亲委派
- 如果一个类加载器收到了加载某个类的请求,则该类加载器并不会去加载该类,而是把这个请求委派给父类加载器,每一个层次的类加载器都是如此,因此所有的类加载请求最终都会传送到顶端的启动类加载器;只有当父类加载器在其搜索范围内无法找到所需的类,并将该结果反馈给子类加载器,子类加载器会尝试去自己加载。

# 破坏双亲委派
- 破坏双亲委派的例子：
    1. 在某些情况下，父类加载器需要委托子类加载器去加载class文件。受到加载范围的限制，父类加载器无法加载到需要的文件。以Driver接口为例，由于Driver接口定义在jdk当中，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能加载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，使用的是线程上下文类加载器，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。
    2. 由于用户对程序动态性的追求导致的，比如：代码热替换，模块热部署。OSG实现模块热部署的关键是它自定义的类加载器机制的实现。每一个程序模块都有自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。

