---
layout:     post
title:      java垃圾回收
subtitle:   
date:       2019-03-01
author:     sugar-foxs
catalog: 	true
tags:
    - java
    - jvm
---

本文主要介绍java垃圾回收，包括：可回收对象判定，垃圾回收算法，垃圾回收器。
<!-- more -->

# 可回收对象判定
## 引用计数器
- 为每个对象维护一个引用计数器，当对象被引用，计数器值就加1；引用失效时，计数器值就减1，当计数器的值为0时，此对象就是可回收对象。
- 缺点：会有循环引用问题，导致两个本来可以回收的对象回收不了。

## 可达性分析
- 选取GC Roots,判断对象是否存在到任意GC Roots的引用链，没有则是可回收对象。
- 可作为GC Roots的有：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法区JNI引用的对象。
    - 因为这些都是当前存活对象。其他的比如被classloader加载的class对象，monitor的对象，被JVM持有的对象也可能是GC Roots对象。
- 真正宣告一个对象死亡，至少要经过两次标记的的过程。
    - 如果对象在经过可达性分析后发现没有和GC Roots连接的路径，那它将会被第一次标记并且进行一次筛选，筛选的条件是：此对象是否有必要执行finalize方法，即对象覆盖了finalize方法或者finalize方法还没被虚拟机执行过，称为有必要执行。如果有必要执行finalize方法，那这个对象会被放入F-Queue队列中，由虚拟机自动建立的低优先级的Finalizer线程去执行。这里的执行是指挥触发这个finalize方法，但是不能保证会等待它结束。(因为如果其中一个对象的finalize方法执行缓慢，或者出现了死循环，将可能导致内存回收系统崩溃)
    - 稍后GC将对F-Queue队列中的对象进行第二次标记，如果这时候对象和GC Roots有了和引用链,则这次不会被回收。

# 垃圾回收
## 回收算法介绍及其优缺点
- 标记清理算法
    - 标记完可回收对象后进行清理
    - 缺点：内存碎片

- 复制算法
    - eden区和两个survrior区，默认比例为8：1，初始对象储存在eden区和其中一个survrior区中，当eden区内存满了的时候，会进行Minor GC,将存回对象放入另一个空闲survior区，如果放不下，会通过年老代进行分配担保，将对象存入年老代，如果年老代也烦不下，会进行一次Full GC.
    - 缺点：在对象存活率高的情况下，效率会降低

- 标记整理算法
    - 标记完可回收对象后将存活对象向一边移动，清理可回收对象，解决了标记清理的内存碎片问题
    - 缺点：需要进行移动，吞吐量较低

## 垃圾回收器
### CMS

### G1

# Minor GC 和Full GC的触发条件
- Minor GC触发：
    - 在eden区没有足够空间分配时触发
    - 在发生Minor GC之前，检查如果老年代最大可用连续空间 > 新生代所有对象总空间或者历次晋升到老年代的对象平均大小，进行Minor GC，否则进行先进行Full GC
- Full GC触发：
    - 老年代最大可用连续空间 < 新生代所有对象总空间或者历次晋升到老年代的对象平均大小
    - System.gc
    - 方法区空间不足
    - 担保失败后也会进行Full GC
