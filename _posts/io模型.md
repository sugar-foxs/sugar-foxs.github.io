---
layout:     post
title:      IO模型
subtitle:   
date:       2020-02-02
author:     sugar-foxs
catalog: 	true
tags:
    - java
---

本文主要介绍IO模型。
<!-- more -->

# Linux中IO模型
- 在Linux操作系统中有5中IO模型：阻塞IO模型，非阻塞IO模型，IO复用模型，信号驱动IO模型，异步IO模型。

## 阻塞IO模型
- 应用进程通过系统调用 recvfrom 接收数据，但由于内核还未准备好数据报，应用进程就会阻塞住，直到内核准备好数据报，recvfrom 完成数据报复制工作，应用进程才能结束阻塞状态。
- 在阻塞的时候什么也做不了，比较浪费时间。

## 非阻塞IO模型
- 该模型在阻塞的时候可以做其他事情，提高了时间利用率。
- 应用进程通过 recvfrom 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回error，应用进程在得到error后，过一段时间再发送recvfrom请求。在两次发送请求的时间段，进程可以先做别的事情。

## 信号驱动IO模型
- 非阻塞模型需要隔一段时间检查数据是否准备好，我们可以在数据准备好的时候通知应用进程。
- 应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。

## IO复用模型
- 多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。
- IO多路复用是多了一个select函数，多个进程的IO可以注册到同一个select上，当用户进程调用该select，select会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，select调用进程会阻塞。当任意一个IO所需的数据准备好之后，select调用就会返回，然后进程在通过recvfrom来进行数据拷贝。
- IO复用模型，并没有向内核注册信号处理函数，所以并不是非阻塞的。进程在发出select后，要等到select监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。

## 异步IO模型
- 上述IO模型都是同步的，因为真正的数据拷贝过程是同步的。
- 应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。
- 用户进程发起aio_read操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到aio_read后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户空间，然后再通知进程本次IO已经完成。

# java中的IO模型
- java中有3中IO模型：BIO,NIO,AIO。

## BIO 同步阻塞模型
- 拿微波炉热饭举例，假设热饭结束没有响声，同步阻塞是一直在微波炉前面等待着，不做其他事情，直到饭热了。

## NIO 同步非阻塞模型
- 假设热饭结束没有响声，同步非阻塞是打开微波炉热饭，然后去做其他事情，比如炒菜，然后过一段时间去看下有没有热好，没好再去做其他事情。

## AIO 异步非阻塞模型
- 微波炉热好饭有响声通知饭热好了，异步非阻塞就是打开微波炉，饭放进去，就可以去做其他事情了，然后饭热好了会有响声通知你。

