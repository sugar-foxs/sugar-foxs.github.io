---
layout:     post
title:      java并发-锁
subtitle:   
date:       2020-01-11
author:     sugar-foxs
catalog: 	true
tags:
    - java
    - 并发编程
---

本文主要介绍java锁的实现和使用中会出现的问题，比如死锁，以及如何避免。
<!-- more -->

# java中锁的实现
- java中锁的实现有两种：synchronized和ReentrantLock。synchronized是一个悲观锁，而ReentrantLock是一个乐观锁，底层使用的是CAS。

## synchronized
- synchronized是java虚拟机的内置锁
    - 对于同步块：编译之后，会在同步块的前后形成 monitorenter 和 monitorexit 两个字节码指令，每个对象都具有一个monitor与之关联，拥有了monitor的线程便锁住了对象。
    - 对于同步方法：编译之后，该同步方法有一个同步标志来表明该方法是同步方法。
- synchronized对同一个线程是可重入的，进去一次monitor，count就加1。
- java的线程是映射到操作系统的原生系统之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，状态转换需要耗费很多的时间。所以synchronized属于一个重量级锁。之后虚拟机也进行了优化，比如：自旋锁，自适应自旋锁，轻量级锁，偏向锁。

    - 自旋锁：线程没有获取到锁便进入忙循环，直到获取到锁。
    - 自适应自旋：因为锁占用的时间长的话，自旋的时间太长浪费处理器资源，所以有了自适应自旋，自适应自旋的自旋时间不再固定，而是根据前一次在同一个锁上的自旋时间决定的。如果对于某个锁自旋很少成功，则省掉自旋过程，避免浪费资源，如果刚刚获得过成功，则自旋等待的时间持续相对的更长。
    - 轻量级锁：在不存在锁竞争的时候起作用，当有锁竞争时会膨胀为重量级锁。轻量级锁是使用CAS操作完成的加锁解锁过程。虚拟机的对象头中有Mark Word，其中有两位用来存储锁标志位，代码进入同步块时，如果同步对象没有被锁定，虚拟机先在栈帧中建立一个锁记录，来存储锁对象目前的Mark Word的拷贝，然后虚拟机使用CAS操作将对象的Mark Word更新为指向锁记录的指针。如果更新成功了，这个线程就拥有了这个对象锁，否则，先检查Mark Word是否指向当前线程的栈帧，如果是直接进入同步块执行，否则说明锁已经被其他线程抢占了。
    - 偏向锁：在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。意思是这个所锁会偏向与第一个获得它的线程，只要这个锁没有被其他线程获取，则持有偏向锁的线程将永远不需要同步。线程第一次获取锁时，对象头中的标志位设置为偏向模式，使用CAS将线程ID记录在Mark Word中，如果CAS成功，持有偏向锁的线程之后都不需要进行同步操作。当有另一个线程尝试获取锁时，偏向模式结束。

## ReentrantLock
- ReentrantLock没有直接来继承AQS,而是定义了一个Sync类去继承AQS。
- AQS维护了一个同步状态state，子类通过继承同步器并实现它的抽象方法来管理同步状态。(模板方法模式：定义一个操作中算法的骨架，而将一些步骤的实现延迟到子类中)
- AQS维护了一个FIFO的同步队列，AQS则会将当前线程以及等待状态等信息构造成一个节点Node并将其加入到同步队列的队尾并一直保持着自旋。在同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。
- 需要阻塞或者唤醒一个线程的时候，AQS都是使用LockSupport这个工具类来完成。
- reentrantLock有两个内部类继承了AQS，是公平锁和非公平锁,实现了自己的获取和释放同步状态的方法。
- ReentrantLock 也是可重入的。
- 同时ReentrantLock还增加了一些高级功能:
    - 可中断:当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。
    - 公平锁: 因为synchroized是非公平的，ReentrantLock有公平和非公平锁(默认是非公平锁)，所以公平锁是和sychronized的区别。多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁。
    - 锁可绑定多个条件:一个ReentrantLock对象可以同时绑定多个Condition对象。

# 死锁
- 说到死锁一般都会想到底什么情况下才叫作死锁。下面看下死锁的4个必要条件，即这4个条件都满足的情况就是发生了死锁，只要其中一个条件不满足，死锁就不存在。
    - 互斥：同一个资源每次只能一个进程使用。
    - 资源不可抢占：不可抢占其他进程持有的资源。
    - 循环等待：若干进程互相循环等待资源。
    - 请求与保持：持有一个资源，又在请求另一个资源，请求不到资源就一直保持这个资源。
- 既然说只要一个条件不满足就不是死锁，那为了不发生死锁，只要让其中一个条件不满足就行了。针对每一个条件，看看如何才能不发生死锁：
    - 互斥：这个条件一般不可避免，因为加锁就是为了互斥。
    - 资源不可抢夺：只要准许抢夺，这个条件就不成立了。
    - 循环等待：避免这个条件可以事先约定好锁的请求顺序，所有线程获取锁的顺序保持一致。
    - 请求与保持：持有一个资源，想要获取其他资源，必须先释放当前持有的资源，才能请求其他资源。

# 总结
- 在需要使用一些sychronized没有的功能时，一般使用ReentrantLock来实现同步，否则一般使用sychronized，在synchronized进行了优化之后，性能不再是优先选择ReentrantLock的条件。
- synchronized和ReenttrantLock的相同点：
    - 都可重入
    - 都实现了非公平锁
- synchronized和ReenttrantLock的不同点：
    - synchronized是悲观锁，而ReentrantLock是乐观锁。
    - synchronized是java语法层面的锁，而ReentrantLock是api层面的锁
    - ReentrantLock需要手动解锁，而synchronized不需要
    - ReentrantLock可中断
    - ReentrantLock还实现了公平锁
    - ReentrantLock锁可绑定多个条件