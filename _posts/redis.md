---
layout:     post
title:      redis
subtitle:   
date:       2020-01-06
author:     sugar-foxs
catalog: 	true
tags:
    - redis
---

本文主要介绍redis。

<!-- more -->

# redis支持的数据结构

- 字符串（String）
- 散列（Hash）
- 列表（List）
- 集合（Set）
- 有序集合（Sorted Set）
    - 采用跳表实现
- Bitmaps
    - 通过一个bit位来表示某个元素对应的值或者状态,其中的key就是对应元素本身。本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。
- Hyperloglogs
    - 用来做基数统计的算法，优点是:在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的，并且是很小的。
- 地理空间（Geospatial）及索引半径查询

# redis为什么这么快
- 基于内存。数据存在内存中，类似于HashMap，查找和操作的时间复杂度都是O(1)

- 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。

- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。

- 使用多路I/O复用模型，非阻塞IO。

- 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

# redis 为什么是单线程
- 因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。
- 单线程，只是说在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis服务器运行的时候肯定是不止一个线程的，例如Redis进行持久化的时候会以子进程或者子线程的方式执行。

# 键过期策略
保证Redis不会超过可用内存的方法是为键设置超时时间。
三种过期策略：
- 定时删除：在设置key的过期时间的同时，创建一个定时器(timer)，让定时器在key的过期时间来临时，立即执行对key的删除操作。
    - 优点：能及时删除过期key，内存被释放。
    - 缺点：占用太多CPU时间，影响服务器的响应时间和吞吐量
- 惰性删除：放任key过期不管，但是每次去数据库获取key的时候去检查是否过期，若过期，则删除，返回null。
    - 优点：在进行get或setnx等操作时，先检查key是否过期，不会占用太多cpu。
    - 缺点：可能有大量过期的key没有再次被访问，不会被清除，这样会浪费太多内存，有内存泄漏的危险。
- 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面过期的key。
    - 是前两种策略的折中。

redis实现的是惰性删除和定期删除。