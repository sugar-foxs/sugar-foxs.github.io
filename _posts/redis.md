---
layout:     post
title:      redis
subtitle:   
date:       2020-01-06
author:     sugar-foxs
catalog: 	true
tags:
    - redis
---

本文主要介绍redis。

<!-- more -->

# redis支持的数据结构

- 字符串（String）
    - 字符串对象的编码可以是：int,raw或者embstr
    - 如果一个字符串对象保存的是整数，则使用int编码；如果保存的是长度大于32字节的字符串值，则使用raw编码，否则使用embstr编码。
- 散列（Hash）
    - hash对象的编码可以是ziplist和hashtable
    - ziplist编码的hash对象使用压缩列表实现；hashtable编码的hash对象使用字典实现。
- 列表（List）
    - 列表对象的编码可以是ziplist或者linkelist
    - ziplist编码的列表对象使用压缩列表实现，linkedlist编码的列表对象使用双端队列实现。
    - 列表对象保存的所有字符串元素的长度都小于64字节，元素数量小于512个，列表对象使用ziplist编码，否则使用linkedlist.
- 集合（Set）
    - 集合对象的编码可以是intset或者hashtable。
    - intset编码的集合对象使用整数集合实现；hashtable编码的集合对象使用字典实现，字典的每一个键是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值都是null。
    - inset编码的集合对象在不满足条件：所有元素都是整数，且元素数量不超过512个时，编码会转换成hashtable。
- 有序集合（Sorted Set）
    - 有序集合对象编码可以是ziplist或skiplist。
    - ziplist编码的有序集合对象使用压缩列表实现，每个集合元素使用两个紧挨在一起的压缩列表来保存,第一个节点保存元素的成员，第二个节点保存元素的分值；压缩列表内集合元素按分值从小到大排序；skiplist编码的有序集合对象使用zset实现，zset结构包含了一个字典和一个跳表。字典为有序集合创建了一个从成员到分值的映射，通过字典可以以O(1)复杂度查找给定成员的分值；跳表可以对有序集合进行范围性型操作。
    - 有序集合的元素数量小于128个且所有元素长度都小于64字节时使用ziplist编码，否则使用skiplist编码。

- Bitmaps
    - 通过一个bit位来表示某个元素对应的值或者状态,其中的key就是对应元素本身。本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。
- Hyperloglogs
    - 用来做基数统计的算法，优点是:在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的，并且是很小的。
- 地理空间（Geospatial）及索引半径查询

# redis为什么这么快
- 基于内存。数据存在内存中，类似于HashMap，查找和操作的时间复杂度都是O(1)

- 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。

- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。

- 使用多路I/O复用模型，非阻塞IO。

- 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

# redis 为什么是单线程
- 因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。
- 单线程，只是说在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis服务器运行的时候肯定是不止一个线程的，例如Redis进行持久化的时候会以子进程或者子线程的方式执行。

# 键过期策略
- 保证Redis不会超过可用内存的方法是为键设置超时时间。三种过期策略：
    - 定时删除：在设置key的过期时间的同时，创建一个定时器(timer)，让定时器在key的过期时间来临时，立即执行对key的删除操作。
        - 优点：能及时删除过期key，内存被释放。
        - 缺点：占用太多CPU时间，影响服务器的响应时间和吞吐量
    - 惰性删除：放任key过期不管，但是每次去数据库获取key的时候去检查是否过期，若过期，则删除，返回null。
        - 优点：在进行get或setnx等操作时，先检查key是否过期，不会占用太多cpu。
        - 缺点：可能有大量过期的key没有再次被访问，不会被清除，这样会浪费太多内存，有内存泄漏的危险。
    - 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面过期的key。
        - 是前两种策略的折中。
- redis实现的是惰性删除和定期删除。

# 缓存雪崩
- 缓存宕机或缓存同时失效，请求都打到数据库，造成数据库崩溃，这是缓存雪崩。
- 解决方法：
    - 事前：redis 高可用，避免全盘崩溃；失效时间加随机值
    - 事中：本地缓存 + hystrix限流&降级，避免MySQL被打死
    - 事后：redis持久化，快速恢复缓存数据

# 缓存穿透
- 恶意查找数据库一定不存在的数据，缓存不起作用，数据库被打死。
- 解决方法：
    - 1，不存在的值也放到缓存，过期时间设置的短
    - 2，布隆过滤器，不存在的值直接过滤

# 持久化
## RDB
- 有两个命令可以生成RBD文件：SAVE和BGSAVE。SAVE命令会阻塞服务器进程，直到RDB文件创建完成为止；而BIGSAVE命令会派生出一个子进程，由子进程来生成RDB文件。
- RDB文件的载入在redis重启检测到RDB文件时自动执行。如果服务器开启了AOF功能，因为通常AOF的更新频率比RDB高，会优先使用AOF文件来还原数据库状态。
- RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。
- BIGSAVE命令执行期间，客户端发送的SAVE，BIGSAVE命令都会被拒绝。
- BIGREWRITEAOF和BIGSAVE命令不能同时执行，BIGSAVE正在执行，收到的BIGREWRITEAOF会被延迟；BIGREWRITEAOF正在执行，收到的BIGSAVE会被拒绝。
- 可以通过设置save选项设置保存条件，只要其中一个条件满足，就会自动执行BIGSAVE命令。

## AOF
- AOF是通过保存redis执行的写命令来记录数据库状态的。
- 命令追加：打开AOP持久化功能时，服务器在执行完一个写命令后，会以协议格式将命令追加到服务器状态的aof_buf缓冲区的末尾。
- appendfsync决定了如何进行持久化：always,everysec,no。
- AOF的载入和数据还原：通过创建一个不带网络连接的伪客户端，解析每一条aof命令并执行。
- AOF重写：目的是减少aof的空间占用。从数据库读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。
- 解决重写导致的不一致问题：设置了一个AOF重写缓冲区，这个缓冲区在创建子进程之后开始使用，当redis执行完一个写命令之后，需要同时将这个写命令发送给AOF缓存区和AOF重写缓冲区。这样可以保证：1，AOF缓冲区的内容会定期被写入到和同步到AOF文件中，对现有AOF文件的处理工作会如常进行。2，从创建子进程之后，所有写命令都会被写入到AOF重写缓冲区中。当子进程完成AOF重写工作之后，它会向父进程发送信号，父进程会执行以下工作：1，将AOF重写缓冲区中的所有内容写入到AOF文件中，这时新AOF文件的状态和数据库状态是一致的。 2， 对新AOF文件进行改名，原子的覆盖旧AOF文件。

# 复制
- PSYNC具有完整重同步和部分重同步功能。
## 完整重同步
- 完整重同步用于处理初次复制的情况，通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓存区中的写命令来进行同步。
##  部分重同步
- 主从服务器分别维护一个复制偏移量，传播N个字节数据，偏移量增加N。通过比较偏移量，可以很容易知道主从服务器是否一致。
- 复制积压缓冲区：是一个由主服务器维护的固定长度的先进先出的队列，默认大小为1MB。保存着一部分最近传播的写命令。所以根据从服务器的偏移量是否在复制积压缓冲区中存在来决定使用哪种同步。如果在使用部分重同步，否则使用完整重同步。
- 服务器运行ID：redis服务器都会有自己的运行ID,在启动时自动生成，由40个随机的十六进制字符组成。断线重连之后，如果从服务器保存的主服务器运行ID和重写连接的主服务器运行Id不一样，则使用完整重同步。

# 哨兵模式sentinel


# 事务
- redis通过MULTI,EXEC,WATCH,DISCARD命令实现事务的功能。
- 在MUTLI命令之后的命令会放入到一个事务队列中去，当遇到MULTI,ISCARD,EXEC,WATCH命令时 ，会立即执行。遇到EXEC命令，会将事务队列中的命令都执行。
- WATCH命令可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个被修改过，如果是的话，服务器将拒绝执行事务。