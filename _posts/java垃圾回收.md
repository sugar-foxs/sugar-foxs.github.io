---
layout:     post
title:      java垃圾回收
subtitle:   
date:       2019-03-01
author:     sugar-foxs
catalog: 	true
tags:
    - java
---

# 可回收对象判定
- 引用计数器
    - 为每个对象维护一个引用计数器，当对象被引用，计数器值就加1；引用失效时，计数器值就减1，当计数器的值为0时，此对象就是可回收对象。
<!-- more -->
    - 缺点：会有循环引用问题，导致两个本来可以回收的对象回收不了。
- 可达性分析
    - 选取GC Roots,判断对象是否存在到任意GC Roots的引用链，没有则是可回收对象。
    - 可作为GC Roots的有：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法区JNI引用的对象。
    - 因为这些都是当前存活对象。其他的比如被classloader加载的class对象，monitor的对象，被JVM持有的对象也可能是GC Roots对象。

# 垃圾回收
## 回收算法介绍及其优缺点
- 标记清理算法
    - 标记完可回收对象后进行清理
    - 缺点：内存碎片

- 复制算法
    - eden区和两个survrior区，默认比例为8：1，初始对象储存在eden区和其中一个survrior区中，当eden区内存满了的时候，会进行Minor GC,将存回对象放入另一个空闲survior区，如果放不下，会通过年老代进行分配担保，将对象存入年老代，如果年老代也烦不下，会进行一次Full GC.
    - 缺点：在对象存活率高的情况下，效率会降低

- 标记整理算法
    - 标记完可回收对象后将存活对象向一边移动，清理可回收对象，解决了标记清理的内存碎片问题
    - 缺点：需要进行移动，吞吐量较低

## 垃圾回收器
> 待补充
- CMS
- G1

# Minor GC 和Full GC的触发条件
- Minor GC在eden区没有足够空间分配时触发
- Full GC触发：老年代空间不足的时候
    - 老年代最大可用连续空间 > 新生代所有对象总空间
    - 历次晋升到老年代的对象平均大小 > 老年代的最大可用连续内存
    - System.gc
    - 方法区空间不足
    - 担保失败后也会进行Full GC
