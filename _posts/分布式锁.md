---
layout:     post
title:      分布式锁
subtitle:   
date:       2020-03-12
author:     sugar-foxs
catalog: 	true
tags:
    - 分布式
---

在分布式系统中，单进程内的锁已然不能适用，为了防止分布式系统中的多个进程之间相互干扰，分布式锁应运而生。本文主要来学习下分布式锁。

<!-- more -->
# 分布式锁的概念
- 可以先想想我们在单进程内，多个线程操作同一个共享变量时出现的线程安全问题，我们是用来锁来解决。以此类推，在分布式环境下，进程之间无法约束访问共享内存，导致安全问题，所以需要第三方进程来实现分布式锁。

# 分布式锁的原理


# 分布式锁的实现
## redis的setnx 命令

## zookeeper的顺序临时节点
- zk节点有临时和持久之分，临时节点表示客户端和服务端断开连接后节点会自动删除，持久节点相反不会删除。
- 不管临时节点还是持久节点，都有顺序和非顺序的节点，顺序节点表示zk会给该节点进行顺序编号。
- 那临时顺序节点是如何实现分布式锁的呢？
    - 创建分布式锁首先会创建一个持久节点作为根节点。
    - 客户端想要获取锁，需要先在根节点下创建一个临时顺序节点，然后查看所有顺序节点，看自己是否是第一个，如果是第一个就拿到了锁，如果不是第一个，获取锁便失败，这时会对自己上一个顺序节点加监听器，当前一个节点对应的客户端主动释放了锁，或者客户端宕机，相应的临时顺序节点会被删除，这个删除操作会被通知下一个节点的客户端，客户端会重新获取锁，如果发现自己是第一个节点，便拿到了锁。

- 示例代码
ZkClient作为获取zk客户端的类。
```java
public class ZkClient {
    public static CuratorFramework build() {
        final String connectString = "127.0.0.1:2181";

        // 重试策略，初始化每次重试之间需要等待的时间，基准等待时间为1秒。
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);

        // 使用默认的会话时间（60秒）和连接超时时间（15秒）来创建 Zookeeper 客户端
        return CuratorFrameworkFactory.builder()
                .connectString(connectString)
                .connectionTimeoutMs(15 * 1000)
                .sessionTimeoutMs(60 * 100)
                .retryPolicy(retryPolicy)
                .build();
    }
}
```

- 用两个线程各自开启zk客户端模拟多个进程。doSomeThing是一个需要加分布式锁的方法。使用睡眠模拟做的事情。
```java
public class ZkLock {
    public static void main(String[] args) {
        new Thread(new TestRunnable()).start();
        new Thread(new TestRunnable()).start();
    }

    private static class TestRunnable implements Runnable {
        @Override
        public void run() {
            try {
                doSomeThing();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public static void doSomeThing() throws Exception {
        CuratorFramework client = ZkClient.build();
        client.start();

        final String lockNode = "/test";
        InterProcessMutex lock = new InterProcessMutex(client, lockNode);
        try {
            boolean get = false;
            while (!get){
                // 获取锁加了超时时间
                if (lock.acquire(5, TimeUnit.SECONDS)) {
                    Stat stat = client.checkExists().forPath(lockNode);
                    if (null != stat){
                        get = true;
                        System.out.println(Thread.currentThread()+"获取到了锁"+System.currentTimeMillis());
                        Thread.sleep(10000);
                    }
                } else {
                    System.out.println(Thread.currentThread()+"获取锁超时");
                }
            }
        } finally {
            if (lock.isAcquiredInThisProcess()) {
                lock.release();
            }
            client.close();
        }
    }
}
```

## Memcached的add指令
## Chubby：粗粒度分布式锁服务，底层利用了 Paxos 一致性算法