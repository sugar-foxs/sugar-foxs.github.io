---
layout:     post
title:      CAS
subtitle:   
date:       2020-01-11
author:     sugar-foxs
catalog: 	true
tags:
    - java
    - 并发编程
---

本文主要介绍CAS的原理，存在的问题及解决方法，CAS在操作系统级别是如何实现的。

<!-- more -->

# CAS介绍

- CAS:compareAndSwap，字面上是说比较再交换。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

> CAS比较与交换的伪代码可以表示为：
do{
    备份旧数据；
    基于旧数据构造新数据；
}while(!CAS( 内存地址，备份的旧数据，新数据 ))

- 就是说，当旧数据和内存值相等时更新数据，如果不等，说明数据已经被其他线程修改，CAS失败，再次进入循环。

# CAS存在的问题及解决方法

- ABA问题：当你获取的旧值是A，然后获得内存的值也是A，但你不能保证是没有被改变过的，因为可能被改变成B，然后又被改变成A。
    - java并发包中提供了一个带有标记的原子引用类"AtomicStampedReference"，它可以通过控制变量值的版本来保证CAS的正确性。

- 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。
    - 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

- 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，
    - 这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。
    - 从Java1。5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。

# CAS在操作系统级别是如何实现的
- x86处理器的cmpxchg指令
    - 确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。
        - 从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。
    - 禁止该指令与之前和之后的读和写指令重排序。
    - 把写缓冲区中的所有数据刷新到内存中。