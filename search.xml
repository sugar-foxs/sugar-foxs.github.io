<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker资源隔离</title>
    <url>/2022/02/16/docker%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<p>docker如何实现资源的隔离，涉及cgroups、namespace和unionFS。</p>
<a id="more"></a>

<ul>
<li><p>cgroups<br>CGroups 全称control groups，cgroups 是 Linux 内核提供的一种机制，这种机制可以根据特定的行为，把一系列系统任务及其子任务整合（或分隔）到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架。用来限定一个进程的资源使用，由Linux内核支持，可以限制和隔离Linux进程组 (process groups) 所使用的物理资源 ，比如cpu，内存，磁盘和网络IO，是Linux container技术的物理基础。</p>
</li>
<li><p>cgroups 的 API 以一个伪文件系统的方式实现，即用户可以通过文件操作实现 cgroups 的组织管理。</p>
</li>
<li><p>cgroups 的组织管理操作单元可以细粒度到线程级别，用户态代码也可以针对系统分配的资源创建和销毁 cgroups，从而实现资源再分配和管理。</p>
</li>
<li><p>所有资源管理的功能都以“subsystem（子系统）”的方式实现，接口统一。</p>
</li>
<li><p>子进程创建之初与其父进程处于同一个 cgroups 的控制组。</p>
</li>
</ul>
<p>cpu隔离包含cpuset隔离、cpuquota隔离、cpushare隔离</p>
<p>内存限制：<br>systemd 只提供了一个参数 MemoryLimit 来对其进行控制，该参数表示某个 user 或 service 所能使用的物理内存总量。</p>
<p>io隔离<br>讨论IO资源隔离的时候，实际上有两个资源需要考虑，一个是空间，另一个是速度。<br>cgroup主要解决的是如何进行IO数据传输的速度限制。</p>
<ul>
<li><p>namespace<br>namespace用来隔离PID(进程ID),IPC,Network等系统资源。</p>
</li>
<li><p>unionFS</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>不同类型数据系统的比较</title>
    <url>/2022/02/10/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9C%A8%E6%8C%81%E4%B9%85%E5%8C%96%E4%BF%9D%E8%AF%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>关系型数据库和nosql、文档数据库其实都为了存储数据，由于侧重点和实现方式的不同，他们的用途也有显著不同。可以从不同方面去比较他们，其实很多方面都有很多类似的地方，比如：扩展性、高可用等等。<br>下面分别选择比较常用的数据系统进行比较：mysql、redis、kafka</p>
<a id="more"></a>

<h1 id="主要应用场景及侧重点"><a href="#主要应用场景及侧重点" class="headerlink" title="主要应用场景及侧重点"></a>主要应用场景及侧重点</h1><p>也就是为什么某些场景选择该数据系统。<br>||mysql|redis|kafka|<br>|—|—|—|—|<br>|应用场景|强一致需求、持久存储|缓存|异步处理，应用解耦，流量削锋和消息通讯|灵活的文档模型<br>|吞吐|4000-7000|集群10w+|集群100w+|<br>|延迟|<br>|事务|支持|不支持，只是批量执行|支持了Kafka跨分区和Topic的原子写操作，要确保跨分区的多个写操作的原子性；用事务id拒绝僵尸实例；消费者只会读已经提交了的消息|<br>|高可用|主从|主从；主从+哨兵；cluster模式，每个主节点都有至少一个从节点|每个partition都有备份|<br>|扩展性|主从结构可以扩展从节点，增加读性能，但是对写性能没有用；mysql cluster可以数据分片，引擎为NDB|cluster模式，扩展方便|数据分片，数据按partition分片|<br>|磁盘存储|B+树|/|LSM树|</p>
]]></content>
      <tags>
        <tag>数据系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《设计数据密集型应用》读后总结</title>
    <url>/2022/02/10/%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%EF%BC%88Designing%20Data-intersive%20Application%EF%BC%89/</url>
    <content><![CDATA[<a id="more"></a>
<p>最近在读《Designing Data-intersive Application》这本书的翻译版本，在这里写下自己的一些学习成果，这本书确实很好，能够将很多知识串联起来，对整个知识图谱的建立有很多帮助。</p>
]]></content>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd入门</title>
    <url>/2021/05/10/etcd/</url>
    <content><![CDATA[<p>本文是关于etcd的介绍。</p>
<a id="more"></a>
<h1 id="etcd简介"><a href="#etcd简介" class="headerlink" title="etcd简介"></a>etcd简介</h1><p>etcd是一个可靠的分布式KV存储，其底层使用Raft算法保证一致性，主要用于共享配置和服务发现。目前提供配置共享和服务发现的组件还是比较多的，大家最为熟悉的就是zookeeper了。简单列举下etcd相较于zookeeper的优势：</p>
<ul>
<li>一致性协议：etcd底层采用了raft协议，zookeeper采用了ZAB协议，ZAB协议是一种类Paxos的一致性协议。目前公认的是Raft比Paxos抑郁理解，工程化也较为容易。</li>
<li>API接口：etcd v2版本提供了Http+json的调用方式，v3版本使用Grpc与服务端交互，grpc本身是跨平台的。</li>
<li>性能：etcd集群可以支持每秒10000+次的写入，性能相当可观，由于zookeeper。</li>
<li>安全性：etcd支持TLS访问，而zookeeper在权限控制这方面略显粗糙。</li>
</ul>
]]></content>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>raft协议</title>
    <url>/2021/05/10/raft%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>raft协议</p>
<a id="more"></a>

<p>常见的一致性算法有Paxos、Raft等，Paxos协议是Leslie Lamport于1990年提出的一种基于消息传递、具有高度容错性的一致性算法，Paxos算法解决的主要问题是分布式系统内如何就某个值达成一致。但Paxos有两个明显的缺点：1，Paxos算法难以理解。2，没有提供构建现实系统的良好基础，也有很多工程化Paxos算法的尝试，但是它们对Paxos算法本身做了比较大的改动，彼此之间的实现差距都比较大，实现的功能和目的有所不同，同时与Paxos算法的描述有很多出入。<br>Raft算法是一种用于管理复制日志的一致性算法，其功能与Paxos算法类似，但其算法结构和Paxos不同，设计者将易用理解作为其目标之一，这使得Raft算法更易于构建实际的系统，大幅度减少了工程化的工作量，也方便开发者在此基础上进行扩展。</p>
<h1 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h1><p>Raft协议功能做模式是Leader-follower模式。每个节点都维护了一个状态机，状态机有3个状态：Leader、Follower、Candidate。在任意时刻，集群中的任意一个节点都处于这3个状态之一。下面介绍下每个状态的节点负责的主要工作。<br>Leader节点：Leader节点负责处理所以客户端的请求，当接收到客户端的写入请求时，Leader节点会在本地追加一条响应的日志，然后将其封装成消息发送到集群中其他的Follower节点。当Follower节点接受到该消息时会对其进行响应。如果集群中多数（超过半数）节点都已收到该请求对应的日志记录时，则Leader节点认为该条日志已提交（Committed），可以向客户端返回响应。Leader还会处理客户端的只读请求。Leader的另一项工作是定期向集群中的Follower节点发送心跳消息，这主要是为了防止集群中的其他Follower节点的选举计时器超时而触发新一轮选举。</p>
<p>Follower节点：不会发生任何请求，它们只是简单的响应来自Leader或Candidate节点的请求；也不处理客户端的请求，而是将请求重定向给Leader节点处理。</p>
<p>Candidate节点：由Follower节点转化而来。当Follower节点长时间没有收到Leader节点发送的心跳消息时，则该节点的选举计时器机会过期，同时会将自身状态转换成Candidate，发起新一轮选举。</p>
<h2 id="Leader选举流程"><a href="#Leader选举流程" class="headerlink" title="Leader选举流程"></a>Leader选举流程</h2><ol>
<li><p>当集群初始化时，所有节点都处于Follower状态，此时的集群中没有Leader节点。当Follower节点一段时间（选举计时器超时）内收不到Leader节点的心跳消息，则认为Leader节点出现故障导致其任期过期，Follower节点会转换成Candidate节点，发起新一轮选举。所谓任期实际上就是一个全局的、连续递增的整数，在Raft协议中每进行一次选举，任期加一，在每个节点中都会记录当前的任期值。每一个任期都是从一次选举开始的，在选举时，会出现一个或者多个Candidate节点尝试承诺为Leader节点，如果其中一个Canndidate节点赢得选举，则该节点就会切换为Leader状态并成为该任期的Leader节点，直到该任期结束。</p>
</li>
<li><p>如果两个或两个以上节点的选举计时器同时过期,则这些节点会同时由Follower状态切换成Candidate状态，然后同时触发新一轮选举。假设两个节点发起选举都没有成功成为Leader，这是会以选举失败结束，当任意节点的选举计时器到期之后，会再次发起新一轮的选举。因为选举超时时间是在一个时间区间内取的随机数，所以在配置合理的时候，像上述情况多次出现的概率不大。</p>
</li>
</ol>
<h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><h2 id="网络分区（脑裂）"><a href="#网络分区（脑裂）" class="headerlink" title="网络分区（脑裂）"></a>网络分区（脑裂）</h2><p>网络分区：在集群中，有部分节点的网络发生故障，和其他一部分节点的连接中断<br>举例：集群中有5个节点A、B、C、D、E。A是leader节点，任期为1，此时其中A和B网络连通，CDE网络连通，但两部分之间网络故障，形成了网络分区。<br>1，随着时间流逝，与leader节点A隔离的CDE节点会有一个节点的选举超时器先超时，假设是E，此时E会切换为Candidate状态，并发起新一轮选举，因为网络分区的原因，只有CD节点能接受到E的选举请求，假设CD都投给了E，E收到了包含3票（包含自己），达到了集群半数以上，成为新任期（Term=2）的leader节点。<br>2，当网络故障修复时，网络分区消失，节点A此时认为自己是Leader，会发送心跳给CDE，CDE接受到心跳请求，但是由于请求中携带的Term小于当前CDE的term,会被CDE忽略。同时节点E也是leader节点，会发生心跳给AB,由于E发送的请求携带的term大于AB的term，所以A、B会切换为Follower状态，这样整个节点的leader节点就是E。<br>3，存在一种情况，A是leader，ABC在一个网络中，DE在一个网络中，DE分区由于节点数不足半数，无法选举出leader节点，会持续发起leader选举。这里raft协议有个优化，在节点发起选举之前，需要先进入PreVote的状态，在该状态下，节点会尝试连接集群中其他节点，只有成功连接到半数以上节点，才能真正发起新一轮leader选举。</p>
]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>一致性协议</tag>
      </tags>
  </entry>
  <entry>
    <title>go入门</title>
    <url>/2021/02/08/go/</url>
    <content><![CDATA[<p>本文是学习go语言过程中的记录。</p>
<a id="more"></a>

<h1 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h1><p>版本13之前使用export k=v 例如export GOPROXY=<a href="https://goproxy.io" target="_blank" rel="noopener">https://goproxy.io</a> ,改.bash_profile更好，因为export只对当前shell有用。<br>之后使用go env w k=v 例如go env w GOPROXY=<a href="https://goproxy.io" target="_blank" rel="noopener">https://goproxy.io</a></p>
<h1 id="mac-go版本升级"><a href="#mac-go版本升级" class="headerlink" title="mac go版本升级"></a>mac go版本升级</h1><ol>
<li>删除 /usr/local/go 目录和/usr/local/Cellar/go 目录</li>
<li>从这个地址 <a href="http://mirrors.ustc.edu.cn/golang/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/golang/</a> 下载合适的mac版本pkg进行安装</li>
<li>重启mac</li>
<li>go version查看是否安装成功</li>
</ol>
]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd命令</title>
    <url>/2020/09/06/etcd%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>本文主要介绍etcdctl命令。</p>
<a id="more"></a>
<h1 id="mac安装etcd"><a href="#mac安装etcd" class="headerlink" title="mac安装etcd"></a>mac安装etcd</h1><ul>
<li>brew install etcd</li>
<li>默认etcdctl APIVERSION是2，通过设置export ETCDCTL_API=3，设置APIversion为3</li>
<li>执行etcd命令启动本地etcd服务</li>
</ul>
<h1 id="etcdctl基本使用"><a href="#etcdctl基本使用" class="headerlink" title="etcdctl基本使用"></a>etcdctl基本使用</h1><p>可分为数据库操作和非数据库操作。数据库操作其实就是对数据的增删改查；非数据操作包含对集群信息的操作、监听等等。</p>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="put-指定某个键的值"><a href="#put-指定某个键的值" class="headerlink" title="put 指定某个键的值"></a>put 指定某个键的值</h3><ul>
<li>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> put /testdir/foo ‘Hello World’</li>
</ul>
<h3 id="get-查询某个键的值"><a href="#get-查询某个键的值" class="headerlink" title="get 查询某个键的值"></a>get 查询某个键的值</h3><ul>
<li>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> get /testdir/foo</li>
<li>输出格式可指定<br>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> get /testdir/foo –write-out=”json”</li>
<li>基于前缀查询，具有相同前缀的key都会被找到<br>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> get /testdir/fo –prefix</li>
</ul>
<h3 id="del-删除某个键值对"><a href="#del-删除某个键值对" class="headerlink" title="del 删除某个键值对"></a>del 删除某个键值对</h3><ul>
<li>删除key为foo的键值对<br>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> del /testdir/foo</li>
<li>带有前缀fo的key都被删除<br>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> del /testdir/fo –prefix</li>
</ul>
<h3 id="租约"><a href="#租约" class="headerlink" title="租约"></a>租约</h3><ul>
<li><p>1.创建租约</p>
</li>
<li><p>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> lease grant 1800</p>
</li>
<li><p>返回值中包含租约id</p>
</li>
<li><p>2.查看所有租约</p>
</li>
<li><p>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> lease list</p>
</li>
<li><p>3.绑定租约</p>
</li>
<li><p>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> put /testdir/fo ‘ffff’ –lease ${leaseid}</p>
</li>
<li><p>查看某个租约剩余时间</p>
</li>
<li><p>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> lease timetolive ${leaseid}</p>
</li>
<li><p>查看某个租约绑定的key</p>
</li>
<li><p>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> lease timetolive ${leaseid} –keys</p>
</li>
<li><p>4.删除租约</p>
</li>
<li><p>先查看下绑定的key</p>
</li>
<li><p>删除租约 etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> lease revoke ${leaseid}</p>
</li>
<li><p>删除租约会，绑定的key也被删除</p>
</li>
<li><p>5.续租</p>
</li>
<li><p>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> lease keep-alive ${leaseid}</p>
</li>
</ul>
<h2 id="非数据库操作"><a href="#非数据库操作" class="headerlink" title="非数据库操作"></a>非数据库操作</h2><ul>
<li><p>查看集群健康状态</p>
</li>
<li><p>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> endpoint health</p>
</li>
<li><p>查看集群status</p>
</li>
<li><p>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> endpoint status</p>
</li>
<li><p>endpoint, ID, version, db size, is leader, raft term, raft index</p>
</li>
<li><p>查看etcd集群<br>etcdctl –endpoints=<a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a> member list</p>
</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka</title>
    <url>/2020/04/24/kafka/</url>
    <content><![CDATA[<p>本文是关于kafka的原理学习。</p>
<a id="more"></a>
<h1 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h1><h2 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h2><h2 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h2><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><h2 id="投票机制"><a href="#投票机制" class="headerlink" title="投票机制"></a>投票机制</h2><ul>
<li>Kafka 动态维护了一个同步状态的备份的集合，简称ISR ，在这个集合中的节点都是和leader保持高度一致的，只有这个集合的成员才有资格被选举为 leader，一条消息必须被这个集合所有节点读取并追加到日志中了，这条消息才能视为提交。这个ISR集合发生变化会在ZooKeeper持久化，正因为如此，这个集合中的任何一个节点都有资格被选为leader 。这对于Kafka使用模型中，有很多分区和并确保主从关系是很重要的。因为ISR模型和f+1副本，一个Kafka topic冗余f个节点故障而不会丢失任何已经提交的消息。</li>
</ul>
<h1 id="kafka管理"><a href="#kafka管理" class="headerlink" title="kafka管理"></a>kafka管理</h1><h2 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h2><ol>
<li>启动kafka</li>
</ol>
<p>bin/kafka-server-start.sh -daemon <path>/server.properties</p>
<ol start="2">
<li>关闭kafka</li>
</ol>
<p>bin/kafka-server-stop.sh</p>
<p>这个脚本会搜寻机器上所有broker进程，并全部关闭。不建议使用kill -9 方式关闭进程，会导致broker状态的不一致。</p>
<p>另一种方法：</p>
<p>找到要kill的broker进程的pid之后执行 kill -s TERM $pid</p>
<ol start="3">
<li>增加broker</li>
</ol>
<p>启动新的broker之后，需要手动执行分区重分配操作，否则新增的broker不会自动被分配任何已有的topic分区</p>
<ol start="4">
<li>升级broker版本</li>
</ol>
<p>更新broker间通信版本和消息版本，这一步向所有broker的server.properties中增加下面两行。<br>inter.broker.protocol.version=当前版本<br>log.message.format.version=当前版本<br>依次更新代码，重启所有broker<br>下载新版本的kafka二进制包，放在哪自己定，只要确保使用目标版本的二进制程序即可。<br>再次更新broker间通信版本和消息版本<br>再次依次重启broker</p>
<h2 id="topic管理"><a href="#topic管理" class="headerlink" title="topic管理"></a>topic管理</h2><ol>
<li>创建topic</li>
</ol>
<p>创建topic的途径有如下4种：</p>
<ul>
<li>执行kafka-topics.sh脚本<ul>
<li>创建test-topic，6个分区，3个副本，topic日志留存时间是3天</li>
<li>bin/kafka-topics –create –zookeeper localhost:2181 –partitions 6 –replication-factor 3 –topic test-topic –config delete.retention.ms=259200000</li>
<li>创建test-topic2,4个分区，2个副本，手动分配</li>
<li>bin/kafka-topics –create –zookeeper localhost:2181 –topic test-topic2 –repica-assignment 0:1,1:2,0:2,1:2</li>
</ul>
</li>
<li>发送CreateTopicsRequest请求</li>
<li>发送MetadataRequest请求且broker端设置了auto.create.topics.enable为true</li>
<li>向zk的/brokers/topics路径下写入以topic名称命名的子节点</li>
</ul>
<ol start="2">
<li>删除topic</li>
</ol>
<p>删除topic的方法：</p>
<ul>
<li><p>使用kafka-topics脚本</p>
</li>
<li><p>构造DeleteTopicsRequest请求</p>
</li>
<li><p>向zk的/admin/delete_topics下写入子节点，不推荐。</p>
</li>
<li><p>无论使用哪种方法，必需保证delete.topic.enable=true,否则kafka不会删除topic。</p>
</li>
<li><p>bin/kafka-topics –delete –zookeeper localhost:2181 –topic test-topic</p>
</li>
</ul>
<ol start="3">
<li>查询topic</li>
</ol>
<ul>
<li>bin/kafka-topics.sh –zookeeper localhost:2181 –list</li>
</ul>
<ol start="4">
<li>查询topic详情</li>
</ol>
<ul>
<li>查询test-topic详情，不指定topic，则查询集群所有topic</li>
<li>bin/kafka-topics –zookeeper localhost:2181 –describe –topic test-topic</li>
</ul>
<ol start="5">
<li>修改topic</li>
</ol>
<ul>
<li>增加分区</li>
<li>test-topic的分区数改为10，根据key确定分区的时候，增加分区需要考虑清楚。</li>
<li>bin/kafka-topics –alter –zookeeper localhost:2181 –partitions 10 –topic test-topic</li>
<li>设置topic级别参数</li>
<li>为test-topic设置参数cleanup.policy=compact</li>
<li>bin/kafka-configs.sh –zookeeper localhost:2181 –alter –entity-type topics –entity-name test-topic –add-config cleanup.policy=compact</li>
</ul>
]]></content>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK命令行工具记录</title>
    <url>/2020/04/06/JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>本文主要记录JDK命令行工具的使用。</p>
<a id="more"></a>

<h1 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h1><ul>
<li>jps命令应该是工作中用的最多的命令了。用来查看服务器所有的java进程。但是有些参数你可能并不知道。</li>
<li>jps -q : 只输出pid。</li>
<li>jps -l : 输出主类的全名，如果进程执行的是Jar包，输出Jar路径。</li>
<li>jps -v : 输出虚拟机进程启动时JVM参数。</li>
<li>jps -m : 输出传递给Java进程main()函数的参数。</li>
</ul>
<h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><ul>
<li>是一个监视虚拟机各种运行状态信息的命令行工具，可以显示本地或者远程虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据。</li>
</ul>
<h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><ul>
<li>用来生成虚拟机当前时刻的线程快照。可用于定位线程长时间出现停顿的原因。</li>
<li>jstack pid</li>
</ul>
<h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><ul>
<li>用来生成堆转储快照。当发生OOM时，用于生成dump文件。</li>
<li>jmap -dump:format=b,file=指定生成的dump文件路径 pid</li>
</ul>
<h1 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h1><ul>
<li>用于分析dump文件，它会建立一个本地http服务器，端口默认为7000，让用户可以在浏览器上查看分析结果。</li>
<li>jhat dump文件路径</li>
</ul>
<h1 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h1><ul>
<li>输出当前进程的全部参数和系统属性。</li>
<li>jinfo -flag name pid :输出对应名称的参数的具体值。</li>
<li>jinfo可以在不重启虚拟机的情况下，可以动态的修改jvm参数。<ul>
<li>jinfo -flag [+|-]name pid :开启或者关闭对应名称的参数。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap1.8原理解读</title>
    <url>/2020/04/06/ConcurrentHashMap1.8/</url>
    <content><![CDATA[<p>本文通过对ConcurrentHashMap1.8版本的代码进行解读来了解其原理。</p>
<a id="more"></a>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><ul>
<li>待写… 可先参考<a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/" target="_blank" rel="noopener">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！</a> ,但是该篇文章中关于ConcurrentHashMap1.8死循环的内容持怀疑态度。<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2></li>
</ul>
<h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><ul>
<li>今天在学习LongAdder的时候，突然发现ConcurrentHashMap中获取size的方法和LongAdder获取值的方法竟然是一样的。OMG… 详情可参考<a href="/2020/04/05/java%E5%B9%B6%E5%8F%91-LongAdder/" title="java并发-LongAdder">java并发-LongAdder</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞队列-SynchronousQueue</title>
    <url>/2020/04/06/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-SynchronousQueue/</url>
    <content><![CDATA[<p>本文主要介绍阻塞队列其中一种实现：SynchronousQueue。</p>
<a id="more"></a>

<blockquote>
<p>先大概了解一下这个阻塞队列的基本情况：当生产线程生产，如果当前没有线程消费产品，此生产线程必须阻塞，等待一个消费线程调用take操作，take操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品。相反，消费线程当消费线程时，如果当前没有线程生产产品，此消费线程必须阻塞，等待一个生产线程调用put操作，put操作将会唤醒消费线程获取生产线程的产品。</p>
</blockquote>
<ul>
<li>下面通过源码的解读来看看是如何做到的。</li>
</ul>
<h1 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h1><h2 id="构造函数和属性"><a href="#构造函数和属性" class="headerlink" title="构造函数和属性"></a>构造函数和属性</h2><ul>
<li>先看下SynchronousQueue的构造函数：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpu核数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPUS = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置超时的最大自旋次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxTimedSpins = (NCPUS &lt; <span class="number">2</span>) ? <span class="number">0</span> : <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没设置超时的最大自旋次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxUntimedSpins = maxTimedSpins * <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Transferer&lt;E&gt; transferer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认是不公平队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransferQueue是公平队列，TransferStack是不公平队列，它们都继承自Transferer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 此方法既负责put,也负责take,下面看如何做到的。TransferQueue和TransferStack分别实现此方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="put-take-offer-poll"><a href="#put-take-offer-poll" class="headerlink" title="put,take,offer,poll"></a>put,take,offer,poll</h2><ul>
<li>上面的解释只是给一个大概了解，具体如何实现的还得看put和take等方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// put失败，会抛出中断异常</span></span><br><span class="line">        Thread.interrupted();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) <span class="comment">// 消费成功</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// offer和poll方法可设置超时时间，也可以被中断；不带参数的offer和poll方法：超时时间为0，生产不成功，立即返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">true</span>, unit.toNanos(timeout)) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(e, <span class="keyword">true</span>, <span class="number">0</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>生产和消费数据的方法最终都是用的transfer方法，只是参数不一样，通过参数识别操作是生产还是消费。</p>
</li>
<li><p>下面看具体子类的transfer方法，我们以公平模式的TransferQueue为例看下，可以先到后面看图更好理解一点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransferQueue() &#123;</span><br><span class="line">    QNode h = <span class="keyword">new</span> QNode(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// 初始化一个dummy node，头尾指针都指向它。</span></span><br><span class="line">    head = h;</span><br><span class="line">    tail = h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    QNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">    <span class="keyword">boolean</span> isData = (e != <span class="keyword">null</span>); <span class="comment">// isData=true表示put，否则表示take</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        QNode t = tail;</span><br><span class="line">        QNode h = head;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)         <span class="comment">//自旋等待初始化</span></span><br><span class="line">            <span class="keyword">continue</span>;                       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// 队列为空或者尾节点和当前操作模式相同</span></span><br><span class="line">            QNode tn = t.next;</span><br><span class="line">            <span class="keyword">if</span> (t != tail)                  <span class="comment">// 防止其他线程并发操作导致的不一致读</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;               <span class="comment">// lagging tail</span></span><br><span class="line">                advanceTail(t, tn);         <span class="comment">// cas设置tn为新的尾节点</span></span><br><span class="line">                <span class="keyword">continue</span>;                  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// cas 设置next</span></span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// cas没成功，自旋</span></span><br><span class="line"></span><br><span class="line">            advanceTail(t, s);              <span class="comment">// cas成功的话，即插入成功，cas设置尾节点</span></span><br><span class="line">            Object x = awaitFulfill(s, e, timed, nanos);<span class="comment">// 看下下面此方法的具体注释</span></span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// 等待被中断</span></span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">                advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">                    s.item = s;</span><br><span class="line">                s.waiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// 互补模式，当前操作和尾节点的模式不同</span></span><br><span class="line">            QNode m = h.next;               <span class="comment">// node to fulfill</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// 自旋等待达到此状态：h==head,t=tail,m!=null</span></span><br><span class="line"></span><br><span class="line">            Object x = m.item;              <span class="comment">// 消费对头的下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    </span><br><span class="line">                x == m ||                   </span><br><span class="line">                !m.casItem(x, e)) &#123;         <span class="comment">// cas item </span></span><br><span class="line">                advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// 上面的条件满足一个就继续循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            advanceHead(h, m);              <span class="comment">// cas item 成功之后，设置m为新的head</span></span><br><span class="line">            LockSupport.unpark(m.waiter);   <span class="comment">// 唤醒m的waiter线程</span></span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">awaitFulfill</span><span class="params">(QNode s, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Same idea as TransferStack.awaitFulfill */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>; <span class="comment">// 等待的截止时间</span></span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> spins = ((head.next == s) ?</span><br><span class="line">                    (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            s.tryCancel(e);  <span class="comment">// 被中断</span></span><br><span class="line">        Object x = s.item;</span><br><span class="line">        <span class="keyword">if</span> (x != e)</span><br><span class="line">            <span class="keyword">return</span> x; <span class="comment">// 返回的是s</span></span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123; <span class="comment">// 阻塞超时</span></span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) <span class="comment">// 自旋次数</span></span><br><span class="line">            --spins;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">            s.waiter = w; <span class="comment">// 设置当前线程为s的waiter，表示当前线程等待另一种角色出现，即消费线程被生产线程唤醒，生产线程被消费线程唤醒</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>光看代码还是不能清晰的看出具体的执行规则，我画个图解释下吧。</p>
</li>
</ul>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><ol>
<li>初始状态,false代表是消费线程，true代表是生成线程<br><img src="http://ww1.sinaimg.cn/large/dbf344a4ly1gdpvmmann9j20fa07o0to.jpg" alt="1.jpg"></li>
<li>消费线程a来消费数据，但是现在没有生产线程在阻塞，所以线程a阻塞<br><img src="http://ww1.sinaimg.cn/large/dbf344a4ly1gdpvn0ky7lj20lg0ck0v3.jpg" alt="2.jpg"></li>
<li>消费线程b来消费数据，也进入阻塞状态<br><img src="http://ww1.sinaimg.cn/large/dbf344a4ly1gdpvnbalc4j20wu0dawi7.jpg" alt="3.jpg"></li>
<li>现在来了一个生产线程c,唤醒第一个阻塞的消费线程，生产的元素被线程a获取<br><img src="http://ww1.sinaimg.cn/large/dbf344a4ly1gdpvnkjr32j20uk0e2jvt.jpg" alt="4.jpg"></li>
<li>生产线程又生产了一个元素，线程b被唤醒，获取到生产的元素<br><img src="http://ww1.sinaimg.cn/large/dbf344a4ly1gdpvnrp44dj20uq08iwgq.jpg" alt="5.jpg"></li>
<li>生产线程c又生产数据的话，如果目前没有消费线程阻塞，生产线程c会阻塞<br><img src="http://ww1.sinaimg.cn/large/dbf344a4ly1gdpwr3a6mij20m80eaq5y.jpg" alt="6.jpg"></li>
</ol>
<ul>
<li>阻塞也可以指定超时时间，阻塞超时的话相当于操作失败，会从队列中去除。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发-LongAdder</title>
    <url>/2020/04/05/java%E5%B9%B6%E5%8F%91-LongAdder/</url>
    <content><![CDATA[<p>本文是关于LongAdder的原理学习。</p>
<blockquote>
<p>由于AtomicLong在高并发下CAS会大概率的进行重试而导致性能不佳，Doug Lea大神在java1.8又增加了LongAdder类来处理这种情况，下面我们来看看LongAdder是如何来解决高并发下的性能问题的。</p>
</blockquote>
<a id="more"></a>

<h1 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h1><ul>
<li>先看下LongAdder的定义和基础属性<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdder</span> <span class="keyword">extends</span> <span class="title">Striped64</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7249069246863182397L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongAdder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以看到LongAdder继承自Striped64抽象类。所以需要看下Striped64类的基础属性。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpu核数, 用来约束cells数组的大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来存放cell,数组size是2的n次方</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础值，除了cells数组中的值，base值也是总和的一部分</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在初始化和扩容时作为锁使用</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br></pre></td></tr></table></figure></li>
<li>这里大概知道下LongAdder里也继承了这些属性。后面都会用到，下面看下LongAdder的add方法作为切入点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="comment">// cells数组已初始化过或者对base属性进行CAS操作没有成功，如果对base设置成功了，则add成功了</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || </span><br><span class="line">            (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>add的逻辑是这样的：</p>
<ul>
<li>cells没初始化过，对base字段尝试CAS，如果成功了直接返回，如果不成功没进入下一步。</li>
<li>不执行longAccumulate方法的情况：cells初始过，且随机获取cells一个cell不为null,且对获取到的cell进行一次CAS尝试，如果成功了，便不用执行longAccumulate方法。</li>
<li>其他情况都需要执行longAccumulate方法。</li>
</ul>
</li>
<li><p>所以总结一下add的逻辑其实就是：在执行longAccumulate方法之前，进行一些小范围的尝试，如对base字段的cas操作，对cells数组中随机一个cell的cas操作。如果尝试都不成功，才执行longAccumulate方法。如果尝试成功了，add的速度变提高了。</p>
</li>
<li><p>下面再具体看下longAccumulate方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.current(); <span class="comment">// 线程安全的获取随机值</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 随机获取的cell为null</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;</span><br><span class="line">                    Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// 新建一个cell,获取锁之后，将新建的cell放入对应位置。</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;         </span><br><span class="line">                            Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;   <span class="comment">// 这里说明插入不成功，当前位置已经被其他线程插入了cell,继续下个循环      </span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里说明其他线程获取到了锁</span></span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 随机获取的cell不是null,但是cas已经失败，这里wasUncontended是参数里传进来的，即之前add方法cas尝试失败</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)    </span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// 设置wasUncontended为true，下一次循环继续，即下一次循环会跳过这个if,持续的尝试cas操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// cas尝试不成功，进入下一步</span></span><br><span class="line">            <span class="comment">// cells数组大小大于NCPU或者cells被其他线程更改过</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// collide=true,且cells数组大小小于NCPU同时cells没被其他线程更改过</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 进行扩容</span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新换一个cell尝试</span></span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是是初始化cells数组的逻辑</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                         </span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>]; <span class="comment">// cells初始大小是2</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x); <span class="comment">// 随机放在下标0 或者 1 上</span></span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里是兜底的方法，上面都不成功的话，通过对base变量进行CAS操作来完成</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再看下LongAdder的值是如何取的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可以看到，获取LongAdder的值是使用sum方法获取的，sum方法通过将base值和所有cells数组中cell的值相加得到。由于sum方法并没有使用锁，所以可以知道这个方法得到的值其实并不精确，因为在求和时，可能会有其他线程在修改base或者cells。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>在并发量比较小的时候，通过对base进行cas操作，实现add功能。此时相当于AtomicLong。</li>
<li>cells数组里的所有值加上base的值就是LongAdder的值。</li>
<li>当对base进行cas操作失败后，会尝试往cells数组里插值<ul>
<li>如果cells数组为空，会先拿到锁，进行初始化cells，初始容量为2，值随机放在下标0 或者 1 上。</li>
<li>如果cells不为空，会随机获取一个cell<ul>
<li>如果cell为空，会拿到锁，新建一个cell,并插入到当前下标。如果插入成功则返回，如果插入失败，表示当前下标被其他线程插入了，进入下一个循环。</li>
<li>如果cell不为空，会尝试进行cas操作，成功则返回，如果不成功，判断数组大小是否大于CPU核数或者cells被其他线程更改过。<ul>
<li>如果数组大小小于核数，且拿到了锁，便开始进行扩容，扩大至之前的2倍。之后再重新随机选择一个cell进行操作。</li>
<li>如果数组大小大于核数或者cells被其他线程更改过，此时没必要扩容，直接再重新随机选择一个cell进行操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>和AtomicLong比较，LongAdder通过在高并发时将对单一变量的CAS操作分散为对cells中多个元素的CAS操作，取值时进行求和，但是因为增加了数组，使用了更多的空间。并发较低时仅对base变量进行CAS操作，与AtomicLong类原理相同。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式在工作中的应用</title>
    <url>/2020/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。本文记录策略模式和模板方法模式在工作中的应用。</p>
<a id="more"></a>

<p>在应用中需要处理不同的模型：单表模型，星型模型，雪花模型，星座模型等等。不同的模型对应着不同的生成sql的逻辑。这时策略模式便可以很好的处理这种情况，并具有很好的扩展性。</p>
<ul>
<li><p>将不同策略的单例放到map中，后面根据不同的模型类型modelType获取模型策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelStrategyFactory</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, AbstractModelStrategy&gt; modelStrategyHandlerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, AbstractModelStrategy&gt; beanMap = applicationContext.getBeansOfType(AbstractModelStrategy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (String key : beanMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.modelStrategyHandlerMap.put(beanMap.get(key).modelType(), beanMap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractModelStrategy <span class="title">getHandler</span><span class="params">(Integer modelType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modelStrategyHandlerMap.get(modelType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>需要使用策略时，通过getHandler方法来获取。</p>
</li>
<li><p>模型策略的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractModelStrategy</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title">modelType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">generateSql</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这里的generateSql方法如果有固定的模板，可以使用模板方法模式，抽象出算法骨架。</p>
</li>
<li><p>单表模型策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleModelModelStrategy</span> <span class="keyword">extends</span> <span class="title">CommonStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PublishTableService publishTableService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ColumnService columnService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PublishModelService publishModelService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">modelType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ModelTypeEnum.SINGLE_MODEL.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateSql</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>星型模型策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarModelModelStrategy</span> <span class="keyword">extends</span> <span class="title">CommonStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">modelType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ModelTypeEnum.STAR_MODEL.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateSql</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后再扩展其他的策略就会很方便。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper学习</title>
    <url>/2020/03/22/zookeeper/</url>
    <content><![CDATA[<p>本文是关于zookepper学习的记录。</p>
<a id="more"></a>

<h2 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a>Paxos协议</h2><p>需要解决的问题是：如何在一个可能发生机器宕机或者网络异常等情况的分布式系统中，快速且准确的在集群内部对某个数据的值达到一致。并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p>
<ul>
<li>拜占庭将军问题：拜占庭帝国有很多军队，每个军队之间将军必须指定一致的行动计划，各个军队在地理上是分开的，只能依靠军队的通讯员进行通讯，但是通讯员可能会有叛徒，可以任意篡改消息，从而欺骗将军。</li>
</ul>
<p>在实际工程实践中，可以假设不存在拜占庭问题，即假设所有消息是完整的，是没有被篡改的。因为：</p>
<ul>
<li><p>大部分系统都是部署在同一个局域网内，因此消息被篡改的情况非常罕见。</p>
</li>
<li><p>由于硬件或者网络造成的消息不完整问题，可以使用校验算法避免。</p>
<p>Paxos算法描述：Paxos小岛采用议会的形式通过法令，议员通过信使来进行消息的传递，值得注意的是，议员和信使都是兼职的，他们随时有可能离开议会厅，并且信使可能会重复的传递消息，也可能一去不复返，因此，议会协议要保证 这种情况下，法令仍然能正确的产生，并且不会出现冲突。</p>
</li>
</ul>
<ul>
<li>google chubby是Paxos的实现。</li>
</ul>
<h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><ul>
<li><p>zookeeper是google chubby的开源实现，但是并没有直接用Paxos算法，而采用了ZAB的一致性协议。</p>
</li>
<li><p>ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议。</p>
</li>
<li><p>ZAB协议的核心：所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为Leader服务器，而余下的其他服务器则成为Follower服务器。Leader服务器负责将一个客户端事务请求转换成一个事务Proosal,并将该Proposal分发给集群中其他的Follower服务器。之后Leader服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那么Leader就会再次向所有的Follower服务器分发Commit消息，要求其将前一个Proposal进行提交。</p>
</li>
<li><p>ZAB协议包括两种基本的模式：崩溃恢复和消息广播。</p>
</li>
<li><p>消息广播<br>针对客户端的事务请求，Leader服务器会为其生成Proposal，并将其发送给集群中其他机器，然后再分别收集各自的选票，最后进行事务提交。ZAB协议在集群中过半Follower机器已经反馈ACK之后，就开始提交事务了，而不需要等待所有Follower都反馈。所以需要崩溃恢复来解决Leader服务器崩溃退出而导致的数据不一致的问题。在广播事务Proposal之前，Leader服务器会先为这个事务生成一个全局递增的唯一ID，称为事务ID。Leader服务器会为每个Follower分配一个队列，需要广播的事务放入对应的队列就可以发送出去。每个Follower接收到事务之后，首先会将其以事务日志的形式写入到本地磁盘中去，并且在成功写入之后反馈给Leader服务器一个ACK响应。当Leader服务器接收到过半Follower的ACK响应后，就会广播一个Commit消息给所有的Follower服务器，以通知其进行事务提交，同时Leader也进行事务提交。每一个Follower服务器接收到Commit消息后会进行事务提交。</p>
</li>
<li><p>崩溃恢复<br>消息广播在正常情况下运行非常良好，但是当Leader服务器出现崩溃，或者由于网络原因Leader服务器失去了与过半Follower的联系，便会进入崩溃恢复模式。即重新选举出一个Leader。 </p>
<ul>
<li>需要确保已经在Leader服务器上提交的事务，最终被所有服务器都提交。</li>
<li>需要确保丢弃那些只在Leader服务器上被提出的事务。</li>
</ul>
</li>
<li><p>Leader选举算法：让具有最高事务编号ZXID的机器成为Leader。可以保证新选举出来的Leader服务器一定具有所有已经提交的提案。</p>
</li>
<li><p>数据同步：Leader选举之后，在正式工作开始之前，Leader服务器首先会确认事务日志中所有的Proposal是否都被集群中过半的机器提交了，即是否完成数据同步。数据同步过程如下：</p>
<ul>
<li>Leader服务器为每个Follower准备一个队列，将没有被Follower提交的事务发送给Follower，并在每个事务消息之后紧接着一个Commit消息，表示该事务已经提交。等到Follwer将所有未同步的事务从leader上同步过来并应用到本地数据库中，Leader服务器就将该Follower加入到真正可用的Follower列表中。</li>
<li>在处理一些需要被丢弃的事务时，是这样处理的：因为事务id能够区分Leader周期变化，能避免leader错误的使用相同的事务id创建不同的事务的情况，当包含了上一个leader周期ongoing尚未提交的事务的服务器启动时，首先它肯定无法成为leader，因为当前集群中一定包含一个Quorum集合，该集合中集群一定包含了更高epoch的事务。当这台机器加入到集群中时，leader服务器会根据自己服务器最后被提交的事务和Follower服务器的事务进行比较，让follower进行回退操作，回退到一个确实被集群中过半机器提交的最新事务。</li>
</ul>
</li>
</ul>
<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><ul>
<li>ZooKeeper致力于提供一个高性能、高可用，且具有严格的顺序访问控制能力的分布式协调服务。</li>
</ul>
<h3 id="服务器角色"><a href="#服务器角色" class="headerlink" title="服务器角色"></a>服务器角色</h3><ul>
<li>ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器，Leader既可以为客户端提供写服务又能提供读服务。除了Leader外，Follower 和 Observer 都只能提供读服务。<br>Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。</li>
</ul>
<h4 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h4><ul>
<li>使用责任链模式来处理每一个请求，请求处理链包含以下几个：<ul>
<li>PreRequestProcessor: 请求预处理器。对于一些事务请求，会对其进行一些预处理，例如创建请求事务头、事务体，会话检查，ACL检查，版本检查等。</li>
<li>ProposalRequestProcessor：事务投票处理器。对于非事务请求，会将请求交给CommitProcessor;对于事务请求，除了将请求交给Commitprocessor之外，还会根据请求类型创建对应的Proposal提议，并发送给所有的Follower，发起一次集群内的事务投票。同时，还会将事务请求交给SyncRequestProcessor进行事务日志的记录。</li>
<li>SyncRequestProcessor：事务日志记录处理器。主要用来将事务请求记录到事务日志文件中去，同时还会触发zk进行事数据快照。</li>
<li>AckRequestProcessor：主要负责在SyncRequestProcessor完成事务日志记录之后，向Proposal的投票收集器发送ack反馈，以通知投票收集器当前服务器已经完成了对改Proposal的事务日志记录。</li>
<li>CommitProcessor：事务提交处理器。对于非事务请求，直接交给下一级处理器；对于事务请求，会等待集群内针对Proposal的投票直到该Proposal可被提交。</li>
<li>ToBeCommitProcessor：该处理器中有一个ToBeApplied队列，用来储存可被提交的Proposal，将这些请求逐个交给FinalRequestProcessor处理。</li>
<li>FinalRequestProcessor：主要用来进行客户端请求返回之前的收尾工作，包括创建客户端请求的响应；针对事务请求，还会将事务应用到内存数据库中。</li>
</ul>
</li>
</ul>
<h4 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h4><ul>
<li>主要职责：<ul>
<li>处理客户端非事务请求，转发事务请求给Leader。</li>
<li>参与事务请求Proposal投票</li>
<li>参与Leader选举</li>
</ul>
</li>
</ul>
<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><ul>
<li>除了不参与Proposal投票和Leader选举，其他功能和Follower一样。</li>
</ul>
<h3 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h3><ul>
<li>LOOKING 不确定Leader状态。该状态下的服务器认为当前集群中没有Leader，会发起Leader选举。</li>
<li>FOLLOWING 跟随者状态。表明当前服务器角色是Follower，并且它知道Leader是谁。</li>
<li>LEADING 领导者状态。表明当前服务器角色是Leader，它会维护与Follower间的心跳。</li>
<li>OBSERVING 观察者状态。表明当前服务器角色是Observer，与Folower唯一的不同在于不参与选举，也不参与集群写操作时的投票。</li>
</ul>
<h3 id="羊群效应"><a href="#羊群效应" class="headerlink" title="羊群效应"></a>羊群效应</h3><p>像这样，大量的client都会获得相同的事件通知，而只有很小的一部分client会对 事件通知有响应。我们这里，只有一个client将获得锁，但是所有的client都得到了通知。那么 这就像在网络公路上撒了把钉子，增加了ZooKeeper服务器的压力。</p>
<h3 id="zookeeper应用场景"><a href="#zookeeper应用场景" class="headerlink" title="zookeeper应用场景"></a>zookeeper应用场景</h3><h4 id="数据发布与订阅（配置中心）"><a href="#数据发布与订阅（配置中心）" class="headerlink" title="数据发布与订阅（配置中心）"></a>数据发布与订阅（配置中心）</h4><ul>
<li>客户端向zookeeper注册自己想要关注的节点，当节点数据发生变化时，服务端会向客户端发生watcher事件通知，客户端接收到通知，需要向服务端获取最新数据。</li>
</ul>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><h4 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h4><ul>
<li>全局性唯一id,使用顺序节点的特性。</li>
<li>使用多个线程模拟多个客户端获取唯一id的逻辑。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">zkID</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String root = <span class="string">"/zk-id"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getId</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="string">"127.0.0.1:2181"</span>,</span><br><span class="line">                <span class="keyword">new</span> RetryNTimes(<span class="number">10</span>, <span class="number">5000</span>));</span><br><span class="line">        client.start();<span class="comment">// 连接</span></span><br><span class="line">        String name = client.create()</span><br><span class="line">                .withMode(CreateMode.PERSISTENT_SEQUENTIAL)</span><br><span class="line">                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">                .forPath(root + <span class="string">"/id"</span>);</span><br><span class="line">        <span class="keyword">return</span> name.substring(name.lastIndexOf(<span class="string">"/"</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(getId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(getId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="分布式协调与通知"><a href="#分布式协调与通知" class="headerlink" title="分布式协调与通知"></a>分布式协调与通知</h4><h4 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h4><h4 id="master选举"><a href="#master选举" class="headerlink" title="master选举"></a>master选举</h4><ul>
<li>使用curator客户端实现Master选举逻辑。用多个线程模拟多个应用，在”/root”持久节点下同时创建相同的临时节点，创建成功的线程作为master节点，创建失败的节点便监听root的子节点变更事件，即被创建的临时节点被删除时会通知不是master的节点去重新选举master。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectMaster</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Master()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Master()).start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String root = <span class="string">"/root"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="string">"127.0.0.1:2181"</span>,</span><br><span class="line">                    <span class="keyword">new</span> RetryNTimes(<span class="number">10</span>, <span class="number">5000</span>));</span><br><span class="line">            client.start();<span class="comment">// 连接</span></span><br><span class="line">            createMasterNode(client);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMasterNode</span><span class="params">(CuratorFramework client)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String name = client.create()</span><br><span class="line">                        .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">                        .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">                        .forPath(root + <span class="string">"/binding"</span>);</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.isEmpty(name)) &#123;</span><br><span class="line">                    System.out.println(name);</span><br><span class="line">                    System.out.println(<span class="string">"i am master."</span>+ Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"create failed. i am not master."</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">            watch(client);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(CuratorFramework client)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"注册子节点变更事件。"</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">// 注册子节点变更监听</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                client.getChildren().usingWatcher((CuratorWatcher) event -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"监控： "</span> + event);</span><br><span class="line">                    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">                            createMasterNode(client);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).forPath(root);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"根节点不存在。注册监听事件失败。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><h4 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h4><ul>
<li>FIFO分布式队列，使用临时顺序节点实现。</li>
<li>barrier：分布式屏障。<ul>
<li>根节点设置数据为n,表示子节点个数达到n时，可以执行业务逻辑。</li>
<li>所有客户端都会在根节点下创建一个临时节点，创建完节点之后，调用getData获取根节点的数据n,调用getChildren获取子节点个数，当个数达到n时，执行业务逻辑，否则继续监听根节点的子节点变更事件。</li>
</ul>
</li>
</ul>
<h3 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h3><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><ul>
<li>zk的视图结构和Unix的文件系统很类似，使用了数据节点的概念，称之为znode。znode是zk中数据的最小单元，每个znode都可以保存数据，同时还可以挂载子节点，因此形成了一棵数据节点组成的树。</li>
<li>事务ID：在zk中，事务是指能够改变zk状态的操作，一般包括节点的创建和删除，节点内容的更新和客户端会话创建与失效等。对于每一个事务操作，zk都会分配一个全局单调递增的唯一的事务id，称之为ZXID。</li>
<li>类似于RDBMS中的事务ID，用于标识一次更新操作的Proposal ID。为了保证顺序性，该zxid必须单调递增。因此ZooKeeper使用一个64位的数来表示，高32位是Leader的epoch，从1开始，每次选出新的Leader，epoch加一。低32位为该epoch内的序号，每次epoch变化，都将低32位的序号重置。这样保证了zxid的全局递增性。</li>
</ul>
<h4 id="节点特性"><a href="#节点特性" class="headerlink" title="节点特性"></a>节点特性</h4><ul>
<li>节点分为持久节点，临时节点，顺序节点。可以组合成四种节点类型。</li>
<li>一旦节点被标记上SEQUENTIAL属性，便成为有序节点，在这个节点被创建的时候，Zookeeper会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</li>
<li>节点状态信息：保存了Stat类的数据结构，包括事务ID，版本信息，子节点个数等。</li>
</ul>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><ul>
<li>每个数据节点具有3种版本信息：当前节点的数据内容的版本号version，当前节点的子节点的版本号cversion，当前节点的ACL变更的版本号aversion。</li>
<li>version代表数据节点的变更次数，初始为0，表示没有变更。version是用来实现乐观锁的写入校验的。</li>
</ul>
<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><ul>
<li>watcher用来实现分布式的通知功能。客户端注册对不同事件的watcher，当事件发生时，服务端会通知监听了此事件的客户端。</li>
<li>watcher被触发后就会失效，如果客户端还想监听，需要再次注册事件。</li>
</ul>
<h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h4><ul>
<li>create：创建子节点的权限</li>
<li>read：读取节点数据和子节点列表的权限</li>
<li>write：更新节点数据的权限</li>
<li>delete：删除子节点的权限</li>
<li>admin:设置节点ACL的权限</li>
</ul>
<h1 id="为什么最好使用奇数台服务器构成ZooKeeper集群？"><a href="#为什么最好使用奇数台服务器构成ZooKeeper集群？" class="headerlink" title="为什么最好使用奇数台服务器构成ZooKeeper集群？"></a>为什么最好使用奇数台服务器构成ZooKeeper集群？</h1><blockquote>
<p>zookeeper容错是指，当宕掉几个zookeeper服务器之后，剩下的个数必须大于宕掉的个数的话整个zookeeper才依然可用。假如我们的集群中有n台zookeeper服务器，那么也就是剩下的服务数必须大于n/2。比如假如我们有3台，那么最大允许宕掉1台zookeeper服务器，如果我们有4台的的时候也同样只允许宕掉1台。所以肯定选择3台较于4台是更优的选择。</p>
</blockquote>
<h1 id="为什么zk没有脑裂问题"><a href="#为什么zk没有脑裂问题" class="headerlink" title="为什么zk没有脑裂问题"></a>为什么zk没有脑裂问题</h1><h2 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h2><ul>
<li>举例子说明：有6台服务器组成的集群，两个机房分别部署了3台，当机房之间网路断开之后，机房内分别选举了自己的leader，导致出现了两个leader。这就是脑裂现象。<h2 id="zk如何避免的"><a href="#zk如何避免的" class="headerlink" title="zk如何避免的"></a>zk如何避免的</h2></li>
<li>zk设置了过半机制，只有在获得一半以上的服务器的选票才会成为leader。比如之前说的6台服务器，需要获得4个选票才能成为leader，所以不会同时出现两个leader。</li>
</ul>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>java类加载</title>
    <url>/2020/03/15/java%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>本文介绍下java类加载的过程。</p>
<a id="more"></a>

<h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><ul>
<li>加载二进制字节流，将这个字节流代表的静态存储结构转化为方法区的运行时数据结构，在内存中生成Class对象，作为方法区这个类的各种数据的访问入口。<h2 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h2></li>
<li>文件格式验证，元数据验证，字节码验证，符号引用验证。<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2></li>
<li>为类变量分配内存并设置类变量初始值。这里的初始值是数据类型的零值。程序员设置的值在初始化阶段设置。<h2 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h2></li>
<li>将常量池内的符号引用转化为直接引用。类或接口的解析，字段解析，类方法解析，接口方法解析。<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2></li>
<li>初始化类变量和其他资源。即执行类构造器clinit方法的过程。clinit方法是由类中所有类变量的赋值动作和静态语句块中的语句合并产生。</li>
<li>遇到以下5种情况时，必须立即对类进行初始化。<ul>
<li>遇到new,getstatic,putstatic,invokestati这4条字节码指令时，如果类没有进行过初始化，需要先触发初始化。对应这4条字节码指令的场景是：new一个对象，获取或者设置一个类的静态字段时，调用一个类的静态方法时。</li>
<li>使用反射包的方法对类进行反射调用时，如果类没有进行过初始化，需要先触发初始化。</li>
<li>当初始化一个类时，如果发现它的父类没有初始化，需要先初始化其父类。</li>
<li>虚拟机启动时执行的主类，需要先进行初始化。</li>
<li>当使用动态语言支持时，如果一个java.lang.invoke.MethodHandler 实例最后的解析结果的方法句柄对应的类没有进行过初始化，需要先进行初始化。</li>
</ul>
</li>
</ul>
<h1 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h1><ul>
<li>如果一个类加载器收到了加载某个类的请求,则该类加载器并不会去加载该类,而是把这个请求委派给父类加载器,每一个层次的类加载器都是如此,因此所有的类加载请求最终都会传送到顶端的启动类加载器;只有当父类加载器在其搜索范围内无法找到所需的类,并将该结果反馈给子类加载器,子类加载器会尝试去自己加载。</li>
</ul>
<h1 id="破坏双亲委派"><a href="#破坏双亲委派" class="headerlink" title="破坏双亲委派"></a>破坏双亲委派</h1><ul>
<li>破坏双亲委派的例子：<ol>
<li>在某些情况下，父类加载器需要委托子类加载器去加载class文件。受到加载范围的限制，父类加载器无法加载到需要的文件。以Driver接口为例，由于Driver接口定义在jdk当中，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能加载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，使用的是线程上下文类加载器，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。</li>
<li>由于用户对程序动态性的追求导致的，比如：代码热替换，模块热部署。OSG实现模块热部署的关键是它自定义的类加载器机制的实现。每一个程序模块都有自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。</li>
</ol>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>spring监听器（观察者模式的应用）</title>
    <url>/2020/03/15/spring%E7%9B%91%E5%90%AC%E5%99%A8(%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<p>本文介绍spring中观察者模式的具体实践：spring监听器。</p>
<a id="more"></a>

<h1 id="spring监听器"><a href="#spring监听器" class="headerlink" title="spring监听器"></a>spring监听器</h1><ul>
<li>熟悉观察者模式的应该都知道实现观察者模式需要的条件：<ul>
<li>事件，在spring中通过继承ApplicationEvent来定义一个事件。</li>
<li>观察者（事件监听器），在spring中需要实现ApplicationListener接口定义观察者。</li>
<li>发布者（事件发布器），在spring中需要实现ApplicationEventPublisherAware或者ApplicationContext去发布事件。</li>
</ul>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul>
<li><p>事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guchunhui</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogEvent</span><span class="params">(Object source, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"监听到日志事件,msg:"</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guchunhui</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">LogEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(LogEvent logEvent)</span> </span>&#123;</span><br><span class="line">        logEvent.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guchunhui</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(LogEvent logEvent)</span> </span>&#123;</span><br><span class="line">        applicationContext.publishEvent(logEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogPublisher logPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishLogEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logPublisher.publish(<span class="keyword">new</span> LogEvent(<span class="keyword">new</span> Object(), <span class="string">"打印日志"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>输出：监听到日志事件,msg:打印日志</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2020/03/14/git/</url>
    <content><![CDATA[<p>本文主要记录一些不常用的git命令。</p>
<a id="more"></a>

<h1 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h1><h2 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h2><ul>
<li>查看文件中每行的author等信息</li>
<li>git blame [filename]</li>
<li>如果你用的是idea,右击编辑框左边栏，可以选择annotate,显示作者。</li>
</ul>
<h2 id="git-cherry-pick-commit-id"><a href="#git-cherry-pick-commit-id" class="headerlink" title="git cherry-pick [commit id]"></a>git cherry-pick [commit id]</h2><ul>
<li>选择某一个分支中的一个或几个commit应用到另一个分支上。</li>
<li>假设需要将a分支的commit（commit id假设为A）应用到分支B上，你需要在a分支上使用git log拿到commit id，然后checkout到b分支上，使用cherry-pick到b分支，如果有冲突，解决掉就行。</li>
</ul>
<h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><ul>
<li>打标签是每次发布版本时都需要做的事</li>
<li>git tag <name> <ul>
<li>示例： git tag v1.0 ，表示标签名是v1.0,看到标签能够很清楚知道当前commit之前是哪个版本的。</li>
</ul>
</li>
<li>git tag <name> <commit id><ul>
<li>上一个命令默认是对本地最新的commit打标签，如果需要对历史指定commit打标签，需要使用命令</li>
</ul>
</li>
<li>git tag -a <name> -m <message> <commit id><ul>
<li>创建带有说明的标签，用-a指定标签名，-m指定说明文字,可以写此次版本增加了哪些功能</li>
</ul>
</li>
<li>git tag 可以查看所有标签</li>
<li>git show <tagname> 看出某个标签的具体信息</li>
<li>git push –tags<ul>
<li>将本地的所有tags推到远程</li>
</ul>
</li>
</ul>
<h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h2><ul>
<li>可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）</li>
<li>git reset –hard commitId</li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式session</title>
    <url>/2020/03/12/%E5%88%86%E5%B8%83%E5%BC%8Fsession/</url>
    <content><![CDATA[<p>分布式session的实现方式：</p>
<ol>
<li>session复制</li>
</ol>
<ul>
<li>应用服务器开启web容器的session复制功能，在集群中的几台服务器之间同步session对象，使得每台服务器上都保存所有的session信息，这样任何一台宕机都不会导致session的数据丢失，服务器使用session时，直接从本地获取。</li>
<li>缺点：这种方式在应用集群达到数千台的时候，就会出现瓶颈，每台都需要备份session，出现内存不够用的情况。<a id="more"></a></li>
</ul>
<ol start="2">
<li>session绑定</li>
</ol>
<ul>
<li>利用hash算法，比如nginx的ip_hash,使得同一个ip的请求分发到同一台服务器上。</li>
<li>缺点：一旦某台服务器宕机，该机器上的session就不存在了，用户请求切换到其他机器后没有session，无法完成业务处理。</li>
</ul>
<ol start="3">
<li>利用cookie记录session</li>
</ol>
<ul>
<li>缺点是：受cookie大小的限制，能记录的信息有限；每次请求响应都需要传递cookie，影响性能，如果用户关闭cookie，访问就不正常。</li>
</ul>
<ol start="4">
<li>session服务器</li>
</ol>
<ul>
<li>利用独立部署的session服务器（集群）统一管理session，服务器每次读写session时，都访问session服务器。</li>
<li>利用分布式缓存（redis), 数据库等统一存储session。</li>
<li>构建单点登录系统（sso)</li>
</ul>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/2020/03/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<p>在分布式系统中，单进程内的锁已然不能适用，为了防止分布式系统中的多个进程之间相互干扰，分布式锁应运而生。本文主要来学习下分布式锁。</p>
<a id="more"></a>
<h1 id="分布式锁的概念"><a href="#分布式锁的概念" class="headerlink" title="分布式锁的概念"></a>分布式锁的概念</h1><ul>
<li>可以先想想我们在单进程内，多个线程操作同一个共享变量时出现的线程安全问题，我们是用来锁来解决。以此类推，在分布式环境下，多个进程之间无法约束访问同一个方法或者同一个资源，会导致安全问题，所以需要第三方进程来实现分布式锁。</li>
<li>在分布式系统环境下，一个方法或同一个资源在同一时间只能被一个机器的一个线程执行。</li>
<li>分布式锁只是一种思想，它的实现有很多方式。</li>
</ul>
<h1 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a>分布式锁的实现</h1><h2 id="redis的setnx-命令"><a href="#redis的setnx-命令" class="headerlink" title="redis的setnx 命令"></a>redis的setnx 命令</h2><ul>
<li>redis锁定的原理是利用setnx命令，能原子的完成加锁和设置过期时间，即只有在某个key不存在情况才能set成功该key，这样就达到了多个进程并发去set同一个key，只有一个进程能set成功。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RedisConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">JedisPool <span class="title">getPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        String host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">6379</span>;</span><br><span class="line">        JedisPool jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig, host, port, <span class="number">5000</span>, <span class="keyword">null</span>);</span><br><span class="line">        logger.info(<span class="string">"初始化JedisPool成功!host:&#123;&#125;,port:&#123;&#125; "</span>, host, port);</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lockKey = <span class="string">"redis_lock"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> internalLockLeaseTime = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SetParams params = SetParams.setParams().nx().px(internalLockLeaseTime);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JedisPool jedisPool;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Jedis jedis = jedisPool.getResource()) &#123;</span><br><span class="line">            Long start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//SET命令返回OK ，则证明获取锁成功</span></span><br><span class="line">                String lock = jedis.set(lockKey, id, params);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"OK"</span>.equals(lock)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"获取锁成功"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则循环等待，在timeout时间内仍未获取到锁，则获取失败</span></span><br><span class="line">                <span class="keyword">long</span> l = System.currentTimeMillis() - start;</span><br><span class="line">                <span class="keyword">if</span> (l &gt;= <span class="number">10000</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"获取锁超时"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        Jedis jedis = jedisPool.getResource();</span><br><span class="line">        String script =</span><br><span class="line">                <span class="string">"if redis.call('get',KEYS[1]) == ARGV[1] then"</span> +</span><br><span class="line">                        <span class="string">"   return redis.call('del',KEYS[1]) "</span> +</span><br><span class="line">                        <span class="string">"else"</span> +</span><br><span class="line">                        <span class="string">"   return 0 "</span> +</span><br><span class="line">                        <span class="string">"end"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = jedis.eval(script, Collections.singletonList(lockKey),</span><br><span class="line">                    Collections.singletonList(id));</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"1"</span>.equals(result.toString()))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DemoApplicationTests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisLock redisLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRedisLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> clientCount =<span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientCount);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(clientCount);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;clientCount;i++)&#123;</span><br><span class="line">            String id = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    redisLock.lock(id);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    redisLock.unlock(id);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(countDownLatch.getCount());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"执行线程数:&#123;&#125;,总耗时:&#123;&#125;,count数为:&#123;&#125;"</span>,clientCount,end-start,count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这里这是针对单机redis实现的分布式锁，缺点很明显，一旦redis挂了，依赖他的服务都挂了，所以实际生产环境更需要redlock，java版本可以看下Redisson。</li>
</ul>
<h3 id="redlock算法"><a href="#redlock算法" class="headerlink" title="redlock算法"></a>redlock算法</h3><blockquote>
<p>假设有N个Redis master节点，这些节点都是完全独立的，我们不用任何复制或者其他隐含的分布式协调算法。前面已经介绍了如何在单节点环境下安全地获取和释放锁。因此我们应当用这个方法在每个单节点里来获取和释放锁。我们需要在不同的计算机或者虚拟机上运行N个master节点来保证他们大多数情况下都不会同时宕机。</p>
</blockquote>
<ul>
<li>假设有5个master节点，一个客户端需要做如下操作来获取锁：</li>
</ul>
<ol>
<li><p>获取当前时间（单位是毫秒）。</p>
</li>
<li><p>轮流用相同的key和随机值在5个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有比总的锁释放时间小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间设置为5-50毫秒的范围，这个可以防止一个客户端在某个宕机的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。</p>
</li>
<li><p>客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（在这里是3个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。</p>
</li>
<li><p>如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。</p>
</li>
<li><p>如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。</p>
</li>
</ol>
<ul>
<li>建议第二步中应该同时向N个Redis实例发出异步的获取锁请求。</li>
</ul>
<h2 id="zookeeper的顺序临时节点"><a href="#zookeeper的顺序临时节点" class="headerlink" title="zookeeper的顺序临时节点"></a>zookeeper的顺序临时节点</h2><ul>
<li><p>zk节点有临时和持久之分，临时节点表示客户端和服务端断开连接后节点会自动删除，持久节点相反不会删除。</p>
</li>
<li><p>不管临时节点还是持久节点，都有顺序和非顺序的节点，顺序节点表示zk会给该节点进行顺序编号。</p>
</li>
<li><p>那临时顺序节点是如何实现分布式锁的呢？</p>
<ul>
<li>创建分布式锁首先会创建一个持久节点作为根节点。</li>
<li>客户端想要获取锁，需要先在根节点下创建一个临时顺序节点，然后查看所有顺序节点，看自己是否是第一个，如果是第一个就拿到了锁，如果不是第一个，获取锁便失败，这时会对自己上一个顺序节点加监听器Watcher，当前一个节点对应的客户端主动释放了锁，或者客户端宕机，相应的临时顺序节点会被删除，这个删除操作会被通知下一个节点的客户端，客户端会重新去获取锁，如果发现自己是第一个节点，便拿到了锁。</li>
</ul>
</li>
<li><p>示例代码</p>
</li>
<li><p>zk可以使用docker很快的搭建出来。可参考<a href="/2019/12/25/docker%E5%91%BD%E4%BB%A4/" title="docker命令">docker命令</a></p>
</li>
<li><p>使用了Curator开源框架的分布式锁实现。ZkClient作为获取zk客户端的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String connectString = <span class="string">"127.0.0.1:2181"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重试策略，初始化每次重试之间需要等待的时间，基准等待时间为1秒。</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用默认的会话时间（60秒）和连接超时时间（15秒）来创建 Zookeeper 客户端</span></span><br><span class="line">        <span class="keyword">return</span> CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(connectString)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">60</span> * <span class="number">100</span>)</span><br><span class="line">                .retryPolicy(retryPolicy)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用两个线程各自开启zk客户端模拟多个进程。doSomeThing是一个需要加分布式锁的方法。使用睡眠模拟做的事情。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TestRunnable()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TestRunnable()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doSomeThing();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CuratorFramework client = ZkClient.build();</span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点如果不存在会自动创建</span></span><br><span class="line">        <span class="keyword">final</span> String lockNode = <span class="string">"/test"</span>;</span><br><span class="line">        InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, lockNode);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> get = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!get)&#123;</span><br><span class="line">                <span class="comment">// 获取锁加了超时时间，超时之后，临时节点会被删除</span></span><br><span class="line">                <span class="keyword">if</span> (lock.acquire(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    Stat stat = client.checkExists().forPath(lockNode);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != stat)&#123;</span><br><span class="line">                        get = <span class="keyword">true</span>;</span><br><span class="line">                        System.out.println(Thread.currentThread()+<span class="string">"获取到了锁"</span>+System.currentTimeMillis());</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread()+<span class="string">"获取锁超时"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.isAcquiredInThisProcess()) &#123;</span><br><span class="line">                lock.release();</span><br><span class="line">            &#125;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>临时顺序节点是这样的,后面的编号按顺序排列，名字都是lock，这个lock name是curator框架默认的，这个用户也可以自己指定。lock前的一串字符串是curator生成的（这里的编号可用来生成分布式id）</p>
<blockquote>
<p><em>c</em>71fb74e3-a75b-47d1-aa90-f88c19e333e6-lock-0000000001<br><em>c</em>88cdcc5b-96d3-4810-8eac-5da5d9a35e3c-lock-0000000002</p>
</blockquote>
</li>
</ul>
<h2 id="Memcached的add指令"><a href="#Memcached的add指令" class="headerlink" title="Memcached的add指令"></a>Memcached的add指令</h2><ul>
<li>memcached带有add函数，利用add函数的特性即可实现分布式锁。add和set的区别在于：如果多线程并发set，则每个set都会成功，但最后存储的值以最后的set的线程为准。而add的话则相反，add会添加第一个到达的值，并返回true，后续的添加则都会返回false。利用该点即可很轻松地实现分布式锁。</li>
<li>缺点：<ul>
<li>memcached采用列入LRU置换策略，所以如果内存不够，可能导致缓存中的锁信息丢失。</li>
<li>memcached无法持久化，一旦重启，将导致信息丢失。<h2 id="Chubby：粗粒度分布式锁服务，底层利用了-Paxos-一致性算法"><a href="#Chubby：粗粒度分布式锁服务，底层利用了-Paxos-一致性算法" class="headerlink" title="Chubby：粗粒度分布式锁服务，底层利用了 Paxos 一致性算法"></a>Chubby：粗粒度分布式锁服务，底层利用了 Paxos 一致性算法</h2></li>
</ul>
</li>
<li>zookeepr是chubby的开源实现</li>
</ul>
<h2 id="数据库实现分布式锁"><a href="#数据库实现分布式锁" class="headerlink" title="数据库实现分布式锁"></a>数据库实现分布式锁</h2><ul>
<li>数据库实现的分布式锁性能比较差，一般不建议使用</li>
</ul>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-问题</title>
    <url>/2020/03/09/mysql-%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>本文主要记录一些工作中遇到的mysql相关的问题。</p>
<a id="more"></a>

<h2 id="字段大小写敏感问题"><a href="#字段大小写敏感问题" class="headerlink" title="字段大小写敏感问题"></a>字段大小写敏感问题</h2><ul>
<li>问题是这样的：有个字符串类型字段且唯一，但是由于一个是’id’,一个是’ID’。查询时本来应该是一条记录，但是出现多条。</li>
<li>这是由于字段大小写不敏感导致查询结果和预想不一致。</li>
<li>解决方法：查询时在字段前加上BINARY。select * from [表名] where BINARY [条件]=’条件’;</li>
</ul>
<h2 id="没用到索引的情况"><a href="#没用到索引的情况" class="headerlink" title="没用到索引的情况"></a>没用到索引的情况</h2><ul>
<li><p>查询中对索引字段有函数操作</p>
</li>
<li><p>隐式类型转换，这里其实也是有函数操作，因为优化器会对需要转换的加cast</p>
</li>
<li><p>隐式字符编码转换，这里其实也是有函数操作，因为优化器会对需要编码转换的加convert</p>
</li>
<li><p>模糊搜索，因为不能根据索引的有序性去查询。</p>
</li>
</ul>
<h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><ul>
<li>性能：count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown学习记录</title>
    <url>/2020/02/26/markdown%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>本文是学习markdown过程中的一些记录。</p>
<a id="more"></a>

<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><table>
<thead>
<tr>
<th>列1</th>
<th>列2</th>
</tr>
</thead>
<tbody><tr>
<td>aaa</td>
<td>bbb</td>
</tr>
<tr>
<td>ccc</td>
<td>dddd</td>
</tr>
</tbody></table>
<ul>
<li>如果表格内字符串太长，需要换行，可使用</br></li>
</ul>
<table>
<thead>
<tr>
<th>列1</th>
<th>列2</th>
</tr>
</thead>
<tbody><tr>
<td>aaaaaaaaaaaaa</br>acaa</td>
<td>bbb</td>
</tr>
<tr>
<td>ccc</td>
<td>dddd</td>
</tr>
</tbody></table>
<ul>
<li>设置表格列的宽度，在表格前加如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt; table th:first-of-type &#123; width: 100px; &#125; &lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><ul>
<li>段落的换行是使用两个以上空格加上回车。示例：</li>
<li>fggfg<br>kkkk</li>
</ul>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul>
<li><p>文字两边各1个*或者_,字体会变成斜体<br>示例： <code>*</code>斜体<code>*</code> , _斜体_<br>效果： <em>斜体</em> , <em>斜体</em></p>
</li>
<li><p>文字两边各2个*或者_,字体会变成粗体<br>示例：<code>**</code>粗体<code>**</code> , __粗体__<br>效果：<strong>粗体</strong> , <strong>粗体</strong></p>
</li>
<li><p>文字两边各3个*或者_,字体会变成粗斜体<br>示例：<code>***</code>粗斜体<code>***</code> , ___粗斜体___<br>效果：<strong><em>粗斜体</em></strong> , <strong><em>粗斜体</em></strong></p>
</li>
</ul>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><ul>
<li>一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。<br><code>***</code><br><code>---</code><br><code>* * *</code><br><code>- - -</code><br>效果：  </li>
</ul>
<hr>
<hr>
<hr>
<hr>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><ul>
<li>只需要在文字的两端加上两个波浪线~~。  </li>
<li>示例：~~删除线~~ </li>
<li>效果：<del>删除线</del></li>
</ul>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><ul>
<li>下划线可以通过HTML的&lt;u&gt;&lt;/u&gt;标签来实现。<br>示例： &lt;u&gt;下划线&lt;/u&gt;<br>效果：<u>下划线</u></li>
</ul>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><ul>
<li>示例:<br><code>[^1]</code><br><code>[^1]:gch</code></li>
</ul>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul>
<li>使用星号(*)、加号(+)或是减号(-)作为列表标记。我一般使用-。示例：<br><code>- 第1</code><br><code>- 第2</code><br><code>- 第3</code><br>效果：  </li>
<li>第1 </li>
<li>第2  </li>
<li>第3 </li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ul>
<li>使用数字并加上 . 号来表示。示例：<br><code>1. gg</code><br><code>2. ff</code><br><code>3. fff</code><br>效果：  </li>
</ul>
<ol>
<li>gg </li>
<li>ff  </li>
<li>ff</li>
</ol>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li><code>[链接名称](链接地址)</code>或者<code>&lt;链接地址&gt;</code></li>
<li>示例：<br><code>[百度](http://www.baidu.com)</code><br><code>&lt;http://www.baidu.com&gt;</code></li>
<li>效果：<br><a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a><br><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></li>
</ul>
<h1 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h1><ul>
<li>在VScode中下载插件Markdown Preview Enhanced插件。</li>
<li>示例：<br>```sequence<br>title:communication<br>participant main<br>participant FuncA as A<br>participant FuncB as B<br>A–&gt;B:<br>B-&gt;main:sendmessage<br>Note over A:NOTE_A<br>Note right of B:NOTE_B<br>```</li>
</ul>
<p>效果：<br><img src="http://ww1.sinaimg.cn/large/dbf344a4ly1gcef6pnpqrj20zc0zc0vl.jpg" alt="时序图.jpg"></p>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>数仓</title>
    <url>/2020/02/22/%E6%95%B0%E4%BB%93/</url>
    <content><![CDATA[<p>本文是学习《大数据之路》的一些记录。</p>
<a id="more"></a>

<h1 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h1><ul>
<li><p>ODS层：操作数据层。是最接近数据源中数据的一层，数据源中的数据，经过抽取、洗净、传输，即ETL之后，装入本层。本层的数据，总体上大多是按照源头业务系统的分类方式而分类的。但是，这一层面的数据却不等同于原始数据。在源数据装入这一层时，要进行诸如去噪（例如去掉明显偏离正常水平的银行刷卡信息）、去重（例如银行账户信息、公安局人口信息中均含有人的姓名，但是只保留一份即可）、提脏（例如有的人的银行卡被盗刷，在十分钟内同时有两笔分别在中国和日本的刷卡信息，这便是脏数据）、业务提取、单位统一、砍字段（例如用于支撑前端系统工作，但是在数据挖掘中不需要的字段）、业务判别等多项工作。</p>
</li>
<li><p>CMD层：公共维度模型层。细分为DWD层和DWS层，采用维度模型方法作为理论基础。更多地采用一些维度退化手法，将维度退化至事实表中，减少事实表和维表的关联，提高明细数据易用性，同时在汇总数据层，加强指标的维度退化，采取更多的宽表手段构建公共指标数据层，提升公共指标的复用性，减少重复加工。</p>
<ul>
<li><p>DWD层：明细数据层。</p>
</li>
<li><p>DWS层：汇总数据层。针对不同的维度对数据进行聚合。</p>
</li>
</ul>
</li>
<li><p>ADS层：应用数据层。存放数据产品个性化的统计指标数据，根据CDM层与ODS层加工生成。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>数仓</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s学习--实践</title>
    <url>/2020/02/08/k8s%E5%AD%A6%E4%B9%A0--%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>本文记录一些对于k8s的学习。</p>
<a id="more"></a>

]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令入门</title>
    <url>/2020/02/08/linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>本文是对于linux命令的学习。</p>
<a id="more"></a>

<h1 id="查看文件夹大小"><a href="#查看文件夹大小" class="headerlink" title="查看文件夹大小"></a>查看文件夹大小</h1><ul>
<li>du -h –max-depth=1 <ul>
<li>h:以K，M，G为单位，提高信息的可读性，不加h默认是以byte为单位</li>
<li>目录层数限制为1</li>
</ul>
</li>
</ul>
<h1 id="查看当前目录各文件大小"><a href="#查看当前目录各文件大小" class="headerlink" title="查看当前目录各文件大小"></a>查看当前目录各文件大小</h1><ul>
<li>ls -lh <ul>
<li>以K，M，G为单位</li>
</ul>
</li>
</ul>
<h1 id="显示目前在Linux系统上的文件系统的磁盘使用情况统计"><a href="#显示目前在Linux系统上的文件系统的磁盘使用情况统计" class="headerlink" title="显示目前在Linux系统上的文件系统的磁盘使用情况统计"></a>显示目前在Linux系统上的文件系统的磁盘使用情况统计</h1><ul>
<li>df :显示文件系统的磁盘使用情况统计</li>
<li>df -h ：-h选项，通过它可以产生可读的格式df命令的输出</li>
</ul>
<h1 id="计算文件字数命令"><a href="#计算文件字数命令" class="headerlink" title="计算文件字数命令"></a>计算文件字数命令</h1><ul>
<li>wc filename ：将返回文件的行数、字数，以及字节数。</li>
<li>wc -l : 只显示行数</li>
<li>wc -w : 只显示字数</li>
<li>wc -c : 只显示Byte数</li>
</ul>
<h1 id="不同后缀文件的解压缩命令"><a href="#不同后缀文件的解压缩命令" class="headerlink" title="不同后缀文件的解压缩命令"></a>不同后缀文件的解压缩命令</h1><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><ul>
<li>解压：tar -xzvf xxx.tar.gz</li>
<li>压缩：tar –czvf xxx.tar.gz *<blockquote>
<p>-z:对应gz  </p>
</blockquote>
</li>
<li>x: 解压 –extract的简写，从备份中还原文件  </li>
<li>c: 压缩 –create的简写，创建新的备份文件  </li>
<li>v：显示所有过程</li>
<li>f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名</li>
</ul>
<h1 id="a-sh"><a href="#a-sh" class="headerlink" title=". ./a.sh"></a>. ./a.sh</h1><ul>
<li>. ./a.sh  第一个.代表source,所以相当于source ./a.sh</li>
</ul>
<h1 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h1><ul>
<li>tr [OPTION]… SET1 [SET2]<ul>
<li>OPTION:-s,-t,-d,-c</li>
</ul>
</li>
</ul>
<h2 id="tr-s-替换重复的字符"><a href="#tr-s-替换重复的字符" class="headerlink" title="tr -s 替换重复的字符"></a>tr -s 替换重复的字符</h2><ol>
<li>echo “aaabbbaacccfdc” | tr -s [abcdf]<ul>
<li>返回abacfdc</li>
</ul>
</li>
<li>删除空白行</li>
</ol>
<ul>
<li>tr -s [“\n”]</li>
<li><img src="http://ww1.sinaimg.cn/large/dbf344a4gy1ginzjdyhlwj212c0eumz7.jpg" alt="1599902157734.jpg"></li>
</ul>
<h2 id="tr-d-删除字符"><a href="#tr-d-删除字符" class="headerlink" title="tr -d 删除字符"></a>tr -d 删除字符</h2><ul>
<li>echo “a13HJ14fdaADff” | tr -d “[a-z][A-Z]”<ul>
<li>返回1314</li>
</ul>
</li>
</ul>
<h2 id="tr-t-字符替换"><a href="#tr-t-字符替换" class="headerlink" title="tr -t 字符替换"></a>tr -t 字符替换</h2><ul>
<li><p>echo “a1314fdasf” | tr -t [afd] [AFD]</p>
<ul>
<li>返回A1314FDsF</li>
</ul>
</li>
<li><p>实现大小写转换</p>
<ul>
<li>echo “Hello World I Love You” |tr -t [a-z] [A-Z]</li>
<li>echo “HELLO WORLD I LOVE YOU” |tr -t [A-Z] [a-z]</li>
<li>使用字符集转换</li>
<li>echo “Hello World I Love You” |tr -t [:lower:] [:upper:]</li>
<li>echo “HELLO WORLD I LOVE YOU” |tr -t [:upper:] [:lower:]</li>
</ul>
</li>
<li><p>字符集</p>
</li>
</ul>
<h2 id="tr-c-字符补集替换"><a href="#tr-c-字符补集替换" class="headerlink" title="tr -c 字符补集替换"></a>tr -c 字符补集替换</h2><ul>
<li>tr -c “[a-z][A-Z]” “#”<ul>
<li>除大小字母以外的所有的字符都替换为#</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s学习--基础概念</title>
    <url>/2020/02/08/k8s%E5%AD%A6%E4%B9%A0--%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>本文记录一些对于k8s的学习。</p>
<a id="more"></a>

<h2 id="k8s的基本知识"><a href="#k8s的基本知识" class="headerlink" title="k8s的基本知识"></a>k8s的基本知识</h2><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><ul>
<li>在k8s中，Service(服务)是分布式集群架构的核心。一个service对象拥有如下特征：<ul>
<li>拥有一个唯一指定的名字</li>
<li>拥有一个唯一的虚拟ip和端口</li>
<li>能够提供某种远程服务能力</li>
<li>被映射到了提供这种服务能力的一组容器应用上</li>
</ul>
</li>
<li>Service的服务进程目前都基于Socket,Service本身一旦创建就不再变化。</li>
</ul>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><ul>
<li>pod运行在一个称之为节点（Node）的环境中，node可以是物理机，也可以是虚拟机。通常一个节点可以运行上百个pod。</li>
<li>将每个服务进程包装到pod中，使其成为pod中运行的一个容器。</li>
<li>通过标签建立Service和pod之间的关联关系。为pod设置name=xxx的标签，Service设置标签选择器，选择条件为name=xxx,这样service会作用于具有name=xxx标签的所有pod。</li>
<li>每个pod中都有一个Pause容器，pause容器的状态代表了整个pod的状态。</li>
</ul>
<h3 id="Master和Node"><a href="#Master和Node" class="headerlink" title="Master和Node"></a>Master和Node</h3><ul>
<li>k8s集群包含一个Master节点和多个工作节点Node。<h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4></li>
<li>在Master节点上运行了集群管理相关的进程：kube-apiserver,kube-controller-manager,kube-schedule。这些进程实现了整个集群的资源管理，pod调度，弹性伸缩，安全控制，系统监控和纠错等管理功能。k8s的所有控制命令都是发给Master，由Master负责具体的执行过程。</li>
<li>kube-apiserver：提供了HTTP Rest接口的廉服务进程，是k8s里所有资源增、删、改、查等操作的唯一入口。是集群控制的入口进程。</li>
<li>kube-controller-manager：k8s里所有资源对象的自动化控制中心。</li>
<li>kube-schedule：负责资源调度（pod调度）的进程。</li>
<li>etcd server：Master节点往往还启动了一个etcd Server进程，k8s所有资源对象的数据全部保存在etcd中。</li>
</ul>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><ul>
<li>Node节点运行真正的应用程序，Node上运行着k8s的kubelet,kube-proxy进程，这些进程负责pod的创建，启动，监控，重启，销毁以及实现软件模式负载均衡器。还有docker引擎，负责本机容器的创建和管理工作。</li>
<li>kubelet:默认会向Master注册自己。注册完成，kubelet会定期向master汇报自身的情报，例如：操作系统、docker版本、机器的cpu和内存情况、以及有哪些pod在运行，这样master便可以知道每个node的资源使用情况，并实现高效均衡的资源调度策略。</li>
</ul>
<h3 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h3><ul>
<li>label是一个key=value的键值对，key和value都由用户指定。</li>
<li>label使得被管理对象能够被分组管理，同时实现整个群的高可用性。</li>
</ul>
<h3 id="Replication-Controller（RC）"><a href="#Replication-Controller（RC）" class="headerlink" title="Replication Controller（RC）"></a>Replication Controller（RC）</h3><ul>
<li>RC能够解决服务扩容和服务升级的问题。</li>
<li>创建一个RC定义文件，包含以下内容：目标pod的定义、目标pod需要运行的副本数量、要监控的目标pod的标签。</li>
<li>创建好RC定义文件并提交到k8s集群后，Master节点上的ontroller Manager组件就会得到通知，通过RC中定义的标签筛选出对应的pod实例并实时监控其状态和数量，如果实例数量少于定义的副本数量，则根据RC中定义的pod模板创建一个新的pod,然后将pod调度到何时的Node上运行，直到pod数量达到设置的副本数量。</li>
<li>kubectl提供了top和delete命令来一次性删除RC和RC控制的所有pod。</li>
</ul>
<h3 id="Replica-Set"><a href="#Replica-Set" class="headerlink" title="Replica Set"></a>Replica Set</h3><ul>
<li>是RC的升级版，唯一的区别是：支持基于集合的label selector。</li>
</ul>
<h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><ul>
<li>Deployment相对于RC的升级是：可以随时知道pod的部署进度。</li>
</ul>
<h3 id="Horizontal-Pod-AutoScaler-HPA"><a href="#Horizontal-Pod-AutoScaler-HPA" class="headerlink" title="Horizontal Pod AutoScaler (HPA)"></a>Horizontal Pod AutoScaler (HPA)</h3><ul>
<li>pod横向扩容，和RC、Deployment一样，也属一种k8s的资源对象。</li>
<li>通过追踪分析RC控制的所有Pod的负载变化情况，来确定是否需要针对性调整目标Pod的副本数。</li>
</ul>
<h3 id="k8s中的3种ip"><a href="#k8s中的3种ip" class="headerlink" title="k8s中的3种ip"></a>k8s中的3种ip</h3><ul>
<li><p>Node IP :k8s集群中每个节点的物理网卡的IP地址，</p>
</li>
<li><p>Pod IP：每个Pod的IP地址，它是Docker Engine 根据docker0网桥的IP地址段进行分配的，通常是一个虚拟的二层网络，不同Node上的Pod能够进行通信，就是通过Pod IP所在的虚拟二层网络进行通信的，而真实的TCP/IP流量则是通过Node IP所在的物理网卡流出的。</p>
</li>
<li><p>Cluster IP：</p>
<ul>
<li>仅仅作用Kubernetes Service这个对象，并由k8s管理和分配ip地址。</li>
<li>无法被ping</li>
<li>只能结合Service Port组成一个具体的通信端口，单独的Cluster IP不具备TCP/IP 通信的基础，并且它们属于k8s集群这样一个封闭的空间，集群之外的节点如果需要访问这个通信端口，则需要做一些额外的工作。</li>
</ul>
</li>
</ul>
<h3 id="Volume-存储卷"><a href="#Volume-存储卷" class="headerlink" title="Volume(存储卷)"></a>Volume(存储卷)</h3><ul>
<li>是pod中能被多个容器访问的共享目录。</li>
</ul>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><ul>
<li>用于实现多租户的资源隔离，k8s集群启动后默认会新建一个名为”default”的Namespace</li>
<li>kubectl get pods –namespace=development 用来查看命名空间是development的对象。</li>
</ul>
<h3 id="Annotation-注解"><a href="#Annotation-注解" class="headerlink" title="Annotation(注解)"></a>Annotation(注解)</h3><ul>
<li>Annotation和Label类似，也是用key/valuef方式进行定义。用来标记资源对象的一些特殊信息：build信息、release信息、Docker镜像信息、日志库等资源库的地址信息、程序调试工具信息、团队的联系信息。</li>
</ul>
<blockquote>
<p>摘自《Kuberetes权威指南》</p>
</blockquote>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型</title>
    <url>/2020/02/02/io%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>本文主要介绍IO模型。</p>
<a id="more"></a>

<h1 id="Linux中IO模型"><a href="#Linux中IO模型" class="headerlink" title="Linux中IO模型"></a>Linux中IO模型</h1><ul>
<li>在Linux操作系统中有5中IO模型：阻塞IO模型，非阻塞IO模型，IO复用模型，信号驱动IO模型，异步IO模型。</li>
</ul>
<h2 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h2><ul>
<li>应用进程通过系统调用 recvfrom 接收数据，但由于内核还未准备好数据报，应用进程就会阻塞住，直到内核准备好数据报，recvfrom 完成数据报复制工作，应用进程才能结束阻塞状态。</li>
<li>在阻塞的时候什么也做不了，比较浪费时间。</li>
</ul>
<h2 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h2><ul>
<li>该模型在阻塞的时候可以做其他事情，提高了时间利用率。</li>
<li>应用进程通过 recvfrom 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回error，应用进程在得到error后，过一段时间再发送recvfrom请求。在两次发送请求的时间段，进程可以先做别的事情。</li>
</ul>
<h2 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h2><ul>
<li>非阻塞模型需要隔一段时间检查数据是否准备好，我们可以在数据准备好的时候通知应用进程。</li>
<li>应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。</li>
</ul>
<h2 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h2><ul>
<li>多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。</li>
<li>IO多路复用是多了一个select函数，多个进程的IO可以注册到同一个select上，当用户进程调用该select，select会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，select调用进程会阻塞。当任意一个IO所需的数据准备好之后，select调用就会返回，然后进程在通过recvfrom来进行数据拷贝。</li>
<li>IO复用模型，并没有向内核注册信号处理函数，所以并不是非阻塞的。进程在发出select后，要等到select监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。</li>
</ul>
<h2 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h2><ul>
<li>上述IO模型都是同步的，因为真正的数据拷贝过程是同步的。</li>
<li>应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。</li>
<li>用户进程发起aio_read操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到aio_read后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户空间，然后再通知进程本次IO已经完成。</li>
</ul>
<h1 id="java中的IO模型"><a href="#java中的IO模型" class="headerlink" title="java中的IO模型"></a>java中的IO模型</h1><ul>
<li>java中有3中IO模型：BIO,NIO,AIO。</li>
</ul>
<h2 id="BIO-同步阻塞模型"><a href="#BIO-同步阻塞模型" class="headerlink" title="BIO 同步阻塞模型"></a>BIO 同步阻塞模型</h2><ul>
<li>拿微波炉热饭举例，假设热饭结束没有响声，同步阻塞是一直在微波炉前面等待着，不做其他事情，直到饭热了。</li>
</ul>
<h2 id="NIO-同步非阻塞模型"><a href="#NIO-同步非阻塞模型" class="headerlink" title="NIO 同步非阻塞模型"></a>NIO 同步非阻塞模型</h2><ul>
<li>假设热饭结束没有响声，同步非阻塞是打开微波炉热饭，然后去做其他事情，比如炒菜，然后过一段时间去看下有没有热好，没好再去做其他事情。</li>
</ul>
<h2 id="AIO-异步非阻塞模型"><a href="#AIO-异步非阻塞模型" class="headerlink" title="AIO 异步非阻塞模型"></a>AIO 异步非阻塞模型</h2><ul>
<li>微波炉热好饭有响声通知饭热好了，异步非阻塞就是打开微波炉，饭放进去，就可以去做其他事情了，然后饭热好了会有响声通知你。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java获取集合的交集，差集，并集的不同方式</title>
    <url>/2020/01/18/java%E8%8E%B7%E5%8F%96%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%A4%E9%9B%86%EF%BC%8C%E5%B7%AE%E9%9B%86%EF%BC%8C%E5%B9%B6%E9%9B%86%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>本文主要介绍java获取set的交集，差集，并集的不同方式。</p>
<a id="more"></a>

<h1 id="使用java原生集合实现"><a href="#使用java原生集合实现" class="headerlink" title="使用java原生集合实现"></a>使用java原生集合实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guchunhui</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set1.add(<span class="number">1</span>);</span><br><span class="line">        set1.add(<span class="number">2</span>);</span><br><span class="line">        set1.add(<span class="number">3</span>);</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set2.add(<span class="number">1</span>);</span><br><span class="line">        set2.add(<span class="number">4</span>);</span><br><span class="line">        set2.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交集</span></span><br><span class="line">        Set&lt;Integer&gt; set3 = <span class="keyword">new</span> HashSet&lt;&gt;(set1);</span><br><span class="line">        set3.retainAll(set2);</span><br><span class="line">        System.out.println(set3); <span class="comment">// 输出 [1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 差集</span></span><br><span class="line">        Set&lt;Integer&gt; set4 = <span class="keyword">new</span> HashSet&lt;&gt;(set1);</span><br><span class="line">        set4.removeAll(set2);</span><br><span class="line">        System.out.println(set4);<span class="comment">// 输出 [2,3]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并集</span></span><br><span class="line">        Set&lt;Integer&gt; set5 = <span class="keyword">new</span> HashSet&lt;&gt;(set1);</span><br><span class="line">        set5.addAll(set2);</span><br><span class="line">        System.out.println(set5);<span class="comment">// 输出 [1,2,3,4,5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用guava实现"><a href="#使用guava实现" class="headerlink" title="使用guava实现"></a>使用guava实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guchunhui</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = Sets.newHashSet(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        Set&lt;Integer&gt; set2 = Sets.newHashSet(<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交集</span></span><br><span class="line">        Sets.SetView&lt;Integer&gt; intersection = Sets.intersection(set1, set2);</span><br><span class="line">        System.out.println(intersection); <span class="comment">//输出 [1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 差集, 返回第一个集合有。但在第二个集合中没有的元素</span></span><br><span class="line">        Sets.SetView&lt;Integer&gt; diff = Sets.difference(set1, set2);</span><br><span class="line">        System.out.println(diff); <span class="comment">// 输出 [2,3]</span></span><br><span class="line"></span><br><span class="line">        Sets.SetView&lt;Integer&gt; diff2 = Sets.difference(set2, set1);</span><br><span class="line">        System.out.println(diff2); <span class="comment">// 输出 [4,5]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并集</span></span><br><span class="line">        Sets.SetView&lt;Integer&gt; union = Sets.union(set1, set2);</span><br><span class="line">        System.out.println(union); <span class="comment">//输出 [1,2,3,4,5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>再看看guava其他实现<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guchunhui</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = Sets.newHashSet(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        Set&lt;Integer&gt; set2 = Sets.newHashSet(<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除了交集，差集，并集，guava还提供了其他实用功能</span></span><br><span class="line"></span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; listSet = Sets.cartesianProduct(set1,set2);</span><br><span class="line">        <span class="comment">// 返回 [[1, 1], [1, 4], [1, 5], [2, 1], [2, 4], [2, 5], [3, 1], [3, 4], [3, 5]]</span></span><br><span class="line">        <span class="comment">// 从结果应该就能看出这个方法是干什么用的。从两个set[1,2,3] [1,4,5] 中各取出一个元素组成list的所有可能。</span></span><br><span class="line">        System.out.println(listSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// list也有类似功能</span></span><br><span class="line">        List&lt;Integer&gt; list1 = Lists.newArrayList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">        List&lt;Integer&gt; list2 = Lists.newArrayList(<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = Lists.cartesianProduct(list1,list2);</span><br><span class="line">        <span class="comment">// 返回 [[1, 1], [1, 5], [1, 6], [2, 1], [2, 5], [2, 6], [4, 1], [4, 5], [4, 6]]</span></span><br><span class="line">        System.out.println(lists);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们在看看实际工作中经常用的Map</span></span><br><span class="line">        Map&lt;String,Integer&gt; map1 = Maps.newHashMap();</span><br><span class="line">        map1.put(<span class="string">"1"</span>,<span class="number">1</span>);</span><br><span class="line">        map1.put(<span class="string">"3"</span>,<span class="number">3</span>);</span><br><span class="line">        map1.put(<span class="string">"4"</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Integer&gt; map2 = Maps.newHashMap();</span><br><span class="line">        map2.put(<span class="string">"1"</span>,<span class="number">1</span>);</span><br><span class="line">        map2.put(<span class="string">"2"</span>,<span class="number">2</span>);</span><br><span class="line">        map2.put(<span class="string">"4"</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        MapDifference&lt;String,Integer&gt; difference = Maps.difference(map1,map2);</span><br><span class="line">        System.out.println(difference.areEqual()); <span class="comment">// 输出 false</span></span><br><span class="line">        System.out.println(difference.entriesInCommon());<span class="comment">// 输出 &#123;1=1&#125;</span></span><br><span class="line">        System.out.println(difference.entriesOnlyOnLeft());<span class="comment">// 输出 &#123;3=3&#125;</span></span><br><span class="line">        System.out.println(difference.entriesOnlyOnRight());<span class="comment">// 输出 &#123;2=2&#125;</span></span><br><span class="line">        <span class="comment">// 返回具有相同key，但value不一样，将不一样的value放入ValueDifference。</span></span><br><span class="line">        System.out.println(difference.entriesDiffering());<span class="comment">// 输出 &#123;4=(4,5)&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还有一种map是实际工作中经常需要用到的，value是List类型</span></span><br><span class="line">        <span class="comment">// 我们可以使用Multimap,ArrayListMultimap或者LinkedListMultimap;</span></span><br><span class="line">        Multimap&lt;String,Integer&gt; multimap = ArrayListMultimap.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相同key的值并不会覆盖，而是加入list。</span></span><br><span class="line">        multimap.put(<span class="string">"a"</span>,<span class="number">1</span>);</span><br><span class="line">        multimap.put(<span class="string">"a"</span>,<span class="number">2</span>);</span><br><span class="line">        multimap.put(<span class="string">"a"</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String key:multimap.keySet()) &#123;</span><br><span class="line">            System.out.println(key);<span class="comment">//输出a</span></span><br><span class="line">            Collection&lt;Integer&gt; value = multimap.get(key);</span><br><span class="line">            System.out.println(value);<span class="comment">//输出 [1,2,3]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="guava中其他集合实现"><a href="#guava中其他集合实现" class="headerlink" title="guava中其他集合实现"></a>guava中其他集合实现</h2><ul>
<li><p>Multiset</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multiset&lt;Long&gt; set = HashMultiset.create();</span><br><span class="line">set.add(<span class="number">1L</span>);</span><br><span class="line">set.add(<span class="number">1L</span>);</span><br><span class="line">set.add(<span class="number">2L</span>);</span><br><span class="line">set.add(<span class="number">4L</span>);</span><br><span class="line"><span class="keyword">for</span> (Multiset.Entry&lt;Long&gt; entry:set.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getElement()+<span class="string">":"</span>+entry.getCount());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：<br>1:2<br>2:1<br>4:1  </p>
</blockquote>
</li>
<li><p>BiMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiMap&lt;String, String&gt; biMap = HashBiMap.create();</span><br><span class="line">biMap.put(<span class="string">"a"</span>,<span class="string">"b"</span>);</span><br><span class="line">biMap.put(<span class="string">"a"</span>,<span class="string">"c"</span>);<span class="comment">// 上一个b会被覆盖</span></span><br><span class="line">biMap.put(<span class="string">"b"</span>,<span class="string">"c"</span>);<span class="comment">// 这个会报错，因为value也不可重复</span></span><br><span class="line">biMap.put(<span class="string">"b"</span>,<span class="string">"d"</span>);</span><br><span class="line"><span class="keyword">for</span> (BiMap.Entry&lt;String,String&gt; entry:biMap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">":"</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：<br>a:c<br>b:d  </p>
</blockquote>
</li>
<li><p>Table</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Table&lt;String,String,String&gt; table = HashBasedTable.create();</span><br><span class="line">table.put(<span class="string">"r1"</span>,<span class="string">"c1"</span>,<span class="string">"1"</span>);</span><br><span class="line">table.put(<span class="string">"r1"</span>,<span class="string">"c2"</span>,<span class="string">"2"</span>);</span><br><span class="line">table.put(<span class="string">"r1"</span>,<span class="string">"c3"</span>,<span class="string">"3"</span>);</span><br><span class="line">table.put(<span class="string">"r2"</span>,<span class="string">"c1"</span>,<span class="string">"4"</span>);</span><br><span class="line">table.put(<span class="string">"r2"</span>,<span class="string">"c2"</span>,<span class="string">"5"</span>);</span><br><span class="line">table.put(<span class="string">"r2"</span>,<span class="string">"c3"</span>,<span class="string">"6"</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String,Map&lt;String,String&gt;&gt; entry:table.rowMap().entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String s:table.columnKeySet())&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Table.Cell&lt;String,String,String&gt; cell:table.cellSet()) &#123;</span><br><span class="line">    System.out.println(cell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出:<br>r1<br>{c1=1, c2=2, c3=3}<br>r2<br>{c1=4, c2=5, c3=6}<br>c1<br>c2<br>c3<br>(r1,c1)=1<br>(r1,c2)=2<br>(r1,c3)=3<br>(r2,c1)=4<br>(r2,c2)=5<br>(r2,c3)=6  </p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>druid参数配置</title>
    <url>/2020/01/15/druid%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>本文介绍druid数据源的参数配置。</p>
<a id="more"></a>

<ul>
<li>spring.druid.initialSize<ul>
<li>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时。</li>
</ul>
</li>
<li>spring.druid.minIdle <ul>
<li>最小连接池数量</li>
</ul>
</li>
<li>spring.druid.maxActive <ul>
<li>最大连接池数量</li>
</ul>
</li>
<li>spring.druid.maxWait <ul>
<li>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</li>
</ul>
</li>
<li>spring.druid.testWhileIdle<ul>
<li>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</li>
</ul>
</li>
<li>spring.druid.timeBetweenEvictionRunsMillis<ul>
<li>Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。</li>
<li>testWhileIdle的判断依据，详细看testWhileIdle属性的说明</li>
</ul>
</li>
<li>spring.druid.minEvictableIdleTimeMillis<ul>
<li>连接保持空闲而不被驱逐的最小时间</li>
</ul>
</li>
<li>spring.druid.validationQuery<ul>
<li>用来检测连接是否有效的sql，要求是一个查询语句，常用SELECT 1 FROM DUAL。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。</li>
</ul>
</li>
<li>spring.druid.testOnBorrow<ul>
<li>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</li>
</ul>
</li>
<li>spring.druid.testOnReturn<ul>
<li>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</li>
</ul>
</li>
<li>spring.druid.poolPreparedStatements<ul>
<li>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</li>
</ul>
</li>
<li>spring.druid.maxPoolPreparedStatementPerConnectionSize<ul>
<li>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</li>
</ul>
</li>
<li>spring.druid.filters=stat,wall,log4j<ul>
<li>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：</li>
<li>监控统计用的filter:stat</li>
<li>日志用的filter:log4j</li>
<li>防御sql注入的filter:wall</li>
</ul>
</li>
<li>spring.druid.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</li>
</ul>
]]></content>
      <tags>
        <tag>druid</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>java线上诊断工具-阿里Arthas</title>
    <url>/2020/01/14/java%E7%BA%BF%E4%B8%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-%E9%98%BF%E9%87%8CArthas/</url>
    <content><![CDATA[<p>本文记录一下Arthas的命令。Arthas是一个非常好的java诊断工具。在遇到线上问题时，能够在不停止应用的前提下观察应用状态。</p>
<a id="more"></a>

<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><blockquote>
<p>curl -L <a href="https://alibaba.github.io/arthas/install.sh" target="_blank" rel="noopener">https://alibaba.github.io/arthas/install.sh</a> | sh</p>
</blockquote>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><blockquote>
<p>java -jar arthas-boot.jar 进程pid</p>
</blockquote>
<h1 id="所有命令"><a href="#所有命令" class="headerlink" title="所有命令"></a>所有命令</h1><h2 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h2><ul>
<li>当前系统的实时数据面板。包含线程、cpu、内存等内容。</li>
</ul>
<h2 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h2><ul>
<li>thread 1 | grep ‘main’</li>
<li>打印线程ID 1的栈, grep出自己想看的内容。</li>
</ul>
<h2 id="heapdump"><a href="#heapdump" class="headerlink" title="heapdump"></a>heapdump</h2><ul>
<li>dump java heap, 类似jmap命令的heap dump功能。</li>
<li>heapdump /Users/guchunhui/dump.hprof  (dump到指定文件)</li>
</ul>
<h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><ul>
<li>查看当前 JVM 的信息</li>
</ul>
<h2 id="sysenv"><a href="#sysenv" class="headerlink" title="sysenv"></a>sysenv</h2><ul>
<li>查看jvm的环境变量</li>
</ul>
<h2 id="sysprop"><a href="#sysprop" class="headerlink" title="sysprop"></a>sysprop</h2><ul>
<li>查看或者修改jvm的系统属性<br>示例：<br>java.version=1.8.0_191<br>java.runtime.version=1.8.0_191-b12</li>
</ul>
<h2 id="vmoption"><a href="#vmoption" class="headerlink" title="vmoption"></a>vmoption</h2><ul>
<li>查看和修改JVM里诊断相关的option</li>
</ul>
<h2 id="getstatic"><a href="#getstatic" class="headerlink" title="getstatic"></a>getstatic</h2><ul>
<li>查看类的静态属性</li>
</ul>
<h2 id="jad"><a href="#jad" class="headerlink" title="jad"></a>jad</h2><ul>
<li>反编译class</li>
<li>jad 类路径</li>
</ul>
<h2 id="mc"><a href="#mc" class="headerlink" title="mc"></a>mc</h2><ul>
<li>编译.java文件生成.class</li>
</ul>
<h2 id="tt"><a href="#tt" class="headerlink" title="tt"></a>tt</h2><ul>
<li>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测。</li>
</ul>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><ul>
<li>方法执行数据观测。让你能方便的观察到指定方法的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写OGNL表达式进行对应变量的查看。</li>
<li>watch class-pattern method-pattern express condition-express</li>
<li>express是观察表达式，观察表达式的构成主要由 ognl 表达式组成，所以你可以这样写”{params,returnObj}”，只要是一个合法的 ognl 表达式，都能被正常支持。</li>
<li>watch 命令定义了4个观察事件点，即 -b 方法调用前，-e 方法异常后，-s 方法返回后，-f 方法结束后。</li>
<li>4个观察事件点 -b、-e、-s 默认关闭，-f 默认打开，当指定观察点被打开后，在相应事件点会对观察表达式进行求值并输出。</li>
<li>观察异常信息例子：<ul>
<li>watch 类名 方法 “{params[0],throwExp}” -e -x 2 -n 5</li>
<li>-e 表示抛出异常才触发，throwExp表示异常信息</li>
<li>-x 表示遍历深度。</li>
<li>-n 只执行指定次数。</li>
</ul>
</li>
</ul>
<h2 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h2><ul>
<li>trace class-pattern method-pattern condition-express</li>
<li>condition-express：条件表达式是用来过滤的。</li>
<li>trace demo.Main main ‘#cost &gt; 10’    只展示Main类main方法调用耗时超过10ms的调用路径。</li>
</ul>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><ul>
<li>输出当前方法被调用的调用路径。</li>
<li>stack class-pattern method-pattern condition-express</li>
</ul>
<h2 id="ognl"><a href="#ognl" class="headerlink" title="ognl"></a>ognl</h2><ul>
<li>ognl表达式官方指南：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li>
<li></li>
</ul>
<h2 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h2><ul>
<li>dump 已加载类的bytecode到特定目录。</li>
</ul>
<h2 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h2><ul>
<li>查看JVM已加载的类信息。</li>
</ul>
<h2 id="sm"><a href="#sm" class="headerlink" title="sm"></a>sm</h2><ul>
<li>查看已加载类的方法信息。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞队列-LinkedBlockingQueue</title>
    <url>/2020/01/13/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-LinkedBlockingQueue/</url>
    <content><![CDATA[<p>本文主要介绍阻塞队列其中一种实现：LinkedBlockingQueue。</p>
<a id="more"></a>

<blockquote>
<p>LinkedBlockingQueue是一个基于链表的、范围任意的阻塞队列。按FIFO排序元素，队列的头部是在队列中时间最长的元素。队列的尾部是在队列中时间最短的元素。新元素插入到队列的尾部，并且队列检索操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。</p>
</blockquote>
<ul>
<li>LinkedBlockingQueue多用于任务队列（单线程发布任务，任务满了就停止等待阻塞，当任务被完成消费，任务少了又开始发布任务)如果不指定容量默认为Integer.MAX_VALUE。通过putLock和takeLock两个锁进行同步，两个锁分别实例化notFull和notEmpty两个Condtion，用来协调多线程的存取动作。</li>
</ul>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h2><ul>
<li>入队时使用putLock锁<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123; <span class="comment">//入队</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><ul>
<li>出队时使用takeLock锁,队列头结点是一个空节点。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;   <span class="comment">//出队</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">//循环引用，虚拟机的可达性分析算法帮助回收</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;   <span class="comment">//因为头结点是一个空节点</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中某些方法(如remove,toArray,toString,clear等)的同步需要同时获得这两个锁，并且总是先putLock.lock紧接着takeLock.lock(在同一方法fullyLock中)，这样的顺序是为了避免可能出现的死锁情况。</li>
</ul>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    fullyLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">             p != <span class="keyword">null</span>;</span><br><span class="line">             trail = p, p = p.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;</span><br><span class="line">                unlink(p, trail);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    takeLock.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>java-阻塞队列</title>
    <url>/2020/01/12/java%E5%B9%B6%E5%8F%91-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>本文主要介绍有哪几种阻塞队列，具体各个队列的原理在其他文章介绍。</p>
<a id="more"></a>
<blockquote>
<p>因为是阻塞队列，所以都会使用到锁，他们都使用的是ReentrantLock。阻塞队列在线程池中用的比较多。</p>
</blockquote>
<h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><blockquote>
<p>一个使用数组实现的有界阻塞队列。在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象必须明确大小，像数组一样。默认采用非公平锁。见<a href="/2020/01/12/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-ArrayBlockingQueue/" title="阻塞队列-ArrayBlockingQueue">阻塞队列-ArrayBlockingQueue</a></p>
</blockquote>
<h1 id="LinkedBlockQueue"><a href="#LinkedBlockQueue" class="headerlink" title="LinkedBlockQueue"></a>LinkedBlockQueue</h1><blockquote>
<p>一个使用链表实现的阻塞队列，按FIFO顺序排序。队列大小不指定的话，最大值是Integer.MAX_VALUE。</p>
</blockquote>
<h1 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h1><blockquote>
<p>延迟阻塞队列。内部使用优先级队列PriorityQueue，按延迟时间delay排序。和类似，都是BlockingQueue的子类，都是延迟阻塞队列。</p>
</blockquote>
<h1 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h1><blockquote>
<p>使用数组实现的优先级阻塞队列，按优先级排序。</p>
</blockquote>
<h1 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h1><blockquote>
<p>一种无缓冲的等待队列。该队列没有缓冲，生产者和消费者类似于电影中黑帮交易，必须一手交钱，一手交货，直接交易，没有中间商赚差价。</p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞队列-ArrayBlockingQueue</title>
    <url>/2020/01/12/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-ArrayBlockingQueue/</url>
    <content><![CDATA[<p>本文主要介绍阻塞队列其中一种实现：ArrayBlockingQueue。</p>
<a id="more"></a>

<blockquote>
<p>ArrayBlockingQueue是用数组实现的线程安全的有界的阻塞队列。ArrayBlockingQueue实现了BlockingQueue接口，继承了AbstractQueue，内部使用Object数组存储元素，容量capacity在构造器中给出，之后不会自动扩容。使用ReentrantLock和两个Condition变量，实现互斥访问。构造器中可以指定锁是公平锁还是非公平锁。使用两个变量putIndex，takeIndex表示入队和出队的位置。</p>
</blockquote>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="comment">// 队列已满,返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 队列没满，可以入队</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>队列满了，返回false；不满，入队，返回true。</li>
</ul>
<h2 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h2><ul>
<li>入队<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        <span class="comment">//因为队列由数组实现,当队列末尾没空间时,从数组开端入队</span></span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>队列的实现是一个循环数组，当数组最后一个有元素时，设置下一个入队的位置为0。</li>
</ul>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><ul>
<li>put和offer都是入队，但是不一样的地方是：put方法会一直阻塞到有空间加入，当收到notFull.signal()时，便可以入队，且入队的操作可能会被中断。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 锁可中断</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里是和offer不一样的地方,一直阻塞到有空间加入,当收到notFull.signal()时,便可以入队</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><ul>
<li>从队列中取出元素。</li>
<li>第一个方法，队列中没有元素，直接返回null，否则返回第一个。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- 第二个方法比第一个方法多了一个超时时间参数，超时之后还没元素可取，便返回<span class="keyword">null</span>。</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h2><ul>
<li>出队<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();<span class="comment">// 有元素出队，队列现在不满了，通知其他线程</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="take"><a href="#take" class="headerlink" title="take"></a>take</h2><ul>
<li>一直阻塞，直到有队列中有元素。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>offer和poll对应,put和take对应。</li>
</ul>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><ul>
<li>删除元素<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="comment">// 遍历队列，从对头到对尾，找到元素删除。</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(items[i])) &#123;</span><br><span class="line">                    removeAt(i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="removeAt"><a href="#removeAt" class="headerlink" title="removeAt"></a>removeAt</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> removeIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">if</span> (removeIndex == takeIndex) &#123;</span><br><span class="line">        <span class="comment">//如果正好等于出队下标,正常出队</span></span><br><span class="line">        items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将要删除的元素后面的元素往前移</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = removeIndex;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (next == items.length)</span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (next != putIndex) &#123;</span><br><span class="line">                items[i] = items[next];</span><br><span class="line">                i = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                items[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.putIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.removedAt(removeIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    notFull.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ArrayBlockingQueue使用示例"><a href="#ArrayBlockingQueue使用示例" class="headerlink" title="ArrayBlockingQueue使用示例"></a>ArrayBlockingQueue使用示例</h1><h2 id="生产者Producer"><a href="#生产者Producer" class="headerlink" title="生产者Producer"></a>生产者Producer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayBlockingQueue&lt;Bread&gt; queue;</span><br><span class="line">    Producer(ArrayBlockingQueue&lt;Bread&gt; queue)&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            produce();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * put()方法是如果容器满了的话就会把当前线程挂起</span></span><br><span class="line"><span class="comment">         * offer()方法是容器如果满的话就会返回false。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bread bread = <span class="keyword">new</span> Bread();</span><br><span class="line">            queue.put(bread);</span><br><span class="line">            System.out.println(<span class="string">"Producer:"</span>+bread);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消费者Consumer"><a href="#消费者Consumer" class="headerlink" title="消费者Consumer"></a>消费者Consumer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayBlockingQueue&lt;Bread&gt; queue;</span><br><span class="line"></span><br><span class="line">    Consumer(ArrayBlockingQueue&lt;Bread&gt; queue)&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * take()方法和put()方法是对应的，从中拿一个数据，如果拿不到线程挂起</span></span><br><span class="line"><span class="comment">         * poll()方法和offer()方法是对应的，从中拿一个数据，如果没有直接返回null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bread bread = queue.take();</span><br><span class="line">            System.out.println(<span class="string">"consumer:"</span>+bread);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生产的元素"><a href="#生产的元素" class="headerlink" title="生产的元素"></a>生产的元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试Test"><a href="#测试Test" class="headerlink" title="测试Test"></a>测试Test</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">10</span>;</span><br><span class="line">        ArrayBlockingQueue&lt;Bread&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(capacity);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(queue)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(queue)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(queue)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(queue)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(queue)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>producer和consumer会一直在生产和消费，输出就不贴了。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>ArrayBlockingQueue是用数组实现的线程安全的有界的阻塞队列。使用ReentrantLock和两个Condition变量实现生产和消费的阻塞。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>延迟队列DelayedWorkQueue</title>
    <url>/2020/01/12/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97DelayedWorkQueue/</url>
    <content><![CDATA[<p>本文主要介绍ScheduledThreadPoolExecutor的内部类DelayedWorkQueue，它是周期线程池专用的延迟队列。</p>
<a id="more"></a>

<h1 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h1><ul>
<li><p>先看下它的fields</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedWorkQueue</span> <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">Runnable</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// DelayedWorkQueue是基于堆实现的。每个ScheduledFutureTask还将其索引记录到堆数组中。这消除了在取消时查找任务的需要，极大地加快了删除速度（从O（n）降到O（log n））。</span></span><br><span class="line">    <span class="comment">// 所有堆操作都必须记录索引更改-主要在siftUp和siftDown中。删除后，任务的heapIndex设置为-1。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 堆的底层数据结构是数组</span></span><br><span class="line">    <span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue =</span><br><span class="line">        <span class="keyword">new</span> RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leader线程用于在队列头等待任务。类似于主从模式，用于最大程度地减少不必要的定时等待。当一个线程成为leader时，它仅等待下一个延迟过去，而其他线程将无限期地等待。 leader线程必须在从take或poll返回之前通知其他线程，除非其他线程成为过渡期间的leader。每当队列头被过期时间更早的任务替换时，leader字段都会被重置为null来使之无效，并且会通知一些等待线程（但不一定是当前领导者）。 因此，等待线程必须准备好在等待时获得并失去领导能力。</span></span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当较新的任务在队列的开头可用或新的线程可能需要成为领导者时，会使用这个condition通知。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure>
</li>
<li><p>从这可以知道DelayedWorkQueue基于最小堆（数组实现）实现，但也有一些优化。下面具体看看如何操作这个延迟队列的。通过队列的结构变化了解延迟队列的实现。</p>
</li>
</ul>
<h2 id="setIndex"><a href="#setIndex" class="headerlink" title="setIndex"></a>setIndex</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果任务是ScheduledFutureTask，记录它在堆中的下标，这是前面所说的为了更快的删除，具体为什么更快，后面会看到。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(RunnableScheduledFuture&lt;?&gt; f, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ScheduledFutureTask)</span><br><span class="line">        ((ScheduledFutureTask)f).heapIndex = idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h2><ul>
<li>向队列增加任务<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow();<span class="comment">//数组满了之后扩容</span></span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 增加的是堆里的第一个任务</span></span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">            setIndex(e, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不是第一个,调用siftUp，下面看下具体逻辑，大概就是排序，将最小delay的任务放到第一个</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前任务是第一个，leader置null,通知其他线程任务可用</span></span><br><span class="line">        <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="grow"><a href="#grow" class="headerlink" title="grow"></a>grow</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// grow 50%</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        newCapacity = Integer.MAX_VALUE;</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>扩容比较简单，新数组容量增加50%，复制到新数组。</li>
</ul>
<h2 id="siftUp"><a href="#siftUp" class="headerlink" title="siftUp"></a>siftUp</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 跟它的父节点比较，如果比父节点小，和父节点交换，直到到达堆顶，否则退出。</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        setIndex(e, k);</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">    setIndex(key, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>和之前的猜想一样，通过比较delay值从下往上将新的任务移动到合适的位置，保证delay值比父节点的大，即最小delay的任务必须在第一个。</li>
</ul>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><ul>
<li>从队列取任务，没有合适的直接返回null<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll() &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 如果第一个为null或者第一个delay值大于0，直接返回null。否则执行finishPoll方法。</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;</span><br><span class="line">    <span class="comment">// 把最后一个元素拿出来，执行siftDown方法，返回第一个元素。</span></span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; x = queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x); <span class="comment">// 大概也是排序，保证第一个元素是最小的。</span></span><br><span class="line">    setIndex(f, -<span class="number">1</span>); <span class="comment">// 第一个任务被取出，heapIndex置为-1.</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>从代码中可以看到，如果第一个任务为null或者第一个任务的delay值大于0，直接返回null。否则返回第一个任务，并执行siftDown方法，从上往下调整。</li>
</ul>
<h2 id="siftDown"><a href="#siftDown" class="headerlink" title="siftDown"></a>siftDown</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 概念上key是放在k的位置上， 然后从上往下比较</span></span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 选出key的两个子节点中小的那个，然后和最小的那个比较，如果key最小，退出，否则和小的那个互换，继续下一轮循环。</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        setIndex(c, k);</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">    setIndex(key, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>和siftUp不同的是：方向不一样，该方法是从上往下进行调整，目标一致，都是为了保证节点比它的子节点的delay值小。即维持最小堆的性质。</li>
</ul>
<h2 id="take"><a href="#take" class="headerlink" title="take"></a>take</h2><ul>
<li>取任务，必须等到有可以执行的任务才退出。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 死循环，直到拿到可以执行的任务</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// 等待的时候引用置null</span></span><br><span class="line">                <span class="comment">// 主线程等待delay时间</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第一个任务的delay大于0的时候：<ul>
<li>leader不为null, 释放锁，等待唤醒，因为leader在等待任务</li>
<li>leader为null,设置当前线程为leader线程，等待delay时间，释放锁，因为leader是当前线程，其他线程只能等待，当过了delay时间之后，当前线程会拿到第一个任务返回。返回之前如果堆顶任务不为null,唤醒其他任意一个线程去取任务。</li>
</ul>
</li>
</ul>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 拿到任务在堆中的下标，即数组的下标</span></span><br><span class="line">        <span class="keyword">int</span> i = indexOf(x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        setIndex(queue[i], -<span class="number">1</span>);<span class="comment">// 删除这个任务</span></span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; replacement = queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 把最后一个任务放到当前位置，进行调整</span></span><br><span class="line">        <span class="keyword">if</span> (s != i) &#123;</span><br><span class="line">            <span class="comment">// 先尝试往下调整</span></span><br><span class="line">            siftDown(i, replacement);</span><br><span class="line">            <span class="comment">// 如果siftDown没动过位置，当前就是最小的，便往上调整。</span></span><br><span class="line">            <span class="keyword">if</span> (queue[i] == replacement)</span><br><span class="line">                siftUp(i, replacement);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里可以看到前面记录index的好处了，当删除ScheduledFutureTask任务时是获取下标，可以快速拿到</span></span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = ((ScheduledFutureTask) x).heapIndex;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; size &amp;&amp; queue[i] == x)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历拿到下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (x.equals(queue[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除时，利用增加ScheduledFutureTask任务时记录了其下标，提高了部分任务的删除速度。</li>
</ul>
<h2 id="drainTo"><a href="#drainTo" class="headerlink" title="drainTo"></a>drainTo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Runnable&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; first;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从队列头把所有可以执行的任务取出放到c中</span></span><br><span class="line">        <span class="keyword">while</span> ((first = peekExpired()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c.add(first);   <span class="comment">// In this order, in case add() throws.</span></span><br><span class="line">            finishPoll(first);</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>drainTo方法是一次性将多个可以执行的任务取出。</li>
<li>这是具有不同参数的drainTo方法，限制了取出的最大任务数，其他的和drain没区别。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Runnable&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; first;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; maxElements &amp;&amp; (first = peekExpired()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c.add(first);</span><br><span class="line">            finishPoll(first);</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="peekExpired"><a href="#peekExpired" class="headerlink" title="peekExpired"></a>peekExpired</h2><ul>
<li>取出第一个超时的任务，但和poll不一样的是这里不会从堆中删除。否则返回null<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt; peekExpired() &#123;</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>) ?</span><br><span class="line">        <span class="keyword">null</span> : first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>DelayedWorkQueue是阻塞队列，使用最小堆（数组）和ReentrantLock实现。比较的是任务的delay值，delay值最小的永远在堆顶。</li>
<li>线程获取锁才可以去拿任务，任务delay小于0，直接取出。释放锁。但是任务delay大于0的时候就需要leader线程了。<ul>
<li>leader不为null, 释放锁，等待唤醒，因为leader在等待任务。</li>
<li>leader为null,设置当前线程为leader线程，等待delay时间之后释放锁，因为leader是当前线程，其他线程只能等待，当过了delay时间之后，当前线程会拿到第一个任务返回。返回之前如果堆顶任务不为null,唤醒其他任意一个线程去取任务。</li>
</ul>
</li>
<li>加入ScheduledFutureTask任务时，会记录其下标，所以删除时可以立即拿到下标，不需要线性搜索，提高了部分任务的删除速度。</li>
<li>其他的操作跟一般的堆类似。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发-CAS</title>
    <url>/2020/01/11/java%E5%B9%B6%E5%8F%91-CAS/</url>
    <content><![CDATA[<p>本文主要介绍CAS的原理，存在的问题及解决方法，CAS在操作系统级别是如何实现的。</p>
<a id="more"></a>

<h1 id="CAS介绍"><a href="#CAS介绍" class="headerlink" title="CAS介绍"></a>CAS介绍</h1><ul>
<li>CAS:compareAndSwap，字面上是说比较再交换。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</li>
</ul>
<blockquote>
<p>CAS比较与交换的伪代码可以表示为：<br>do{<br>    备份旧数据；<br>    基于旧数据构造新数据；<br>}while(!CAS( 内存地址，备份的旧数据，新数据 ))</p>
</blockquote>
<ul>
<li>就是说，当旧数据和内存值相等时更新数据，如果不等，说明数据已经被其他线程修改，CAS失败，再次进入循环。</li>
</ul>
<h1 id="CAS存在的问题及解决方法"><a href="#CAS存在的问题及解决方法" class="headerlink" title="CAS存在的问题及解决方法"></a>CAS存在的问题及解决方法</h1><ul>
<li><p>ABA问题：当你获取的旧值是A，然后获得内存的值也是A，但你不能保证是没有被改变过的，因为可能被改变成B，然后又被改变成A。</p>
<ul>
<li>java并发包中提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。</li>
</ul>
</li>
<li><p>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<ul>
<li>如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</li>
</ul>
</li>
<li><p>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，</p>
<ul>
<li>这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。</li>
<li>从Java1。5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</li>
</ul>
</li>
</ul>
<h1 id="CAS在操作系统级别是如何实现的"><a href="#CAS在操作系统级别是如何实现的" class="headerlink" title="CAS在操作系统级别是如何实现的"></a>CAS在操作系统级别是如何实现的</h1><ul>
<li>x86处理器的cmpxchg指令<ul>
<li>确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。<ul>
<li>从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li>
</ul>
</li>
<li>禁止该指令与之前和之后的读和写指令重排序。</li>
<li>把写缓冲区中的所有数据刷新到内存中。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发-锁</title>
    <url>/2020/01/11/java%E5%B9%B6%E5%8F%91-%E9%94%81/</url>
    <content><![CDATA[<p>本文主要介绍java锁的实现和使用中会出现的问题，比如死锁，以及如何避免。</p>
<a id="more"></a>

<h1 id="java中锁的实现"><a href="#java中锁的实现" class="headerlink" title="java中锁的实现"></a>java中锁的实现</h1><ul>
<li>java中锁的实现有两种：synchronized和ReentrantLock。synchronized是一个悲观锁，而ReentrantLock是一个乐观锁，底层使用的是CAS。</li>
</ul>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ul>
<li><p>synchronized是java虚拟机的内置锁</p>
<ul>
<li>对于同步块：编译之后，会在同步块的前后形成 monitorenter 和 monitorexit 两个字节码指令，每个对象都具有一个monitor与之关联，拥有了monitor的线程便锁住了对象。</li>
<li>对于同步方法：编译之后，该同步方法有一个同步标志来表明该方法是同步方法。</li>
</ul>
</li>
<li><p>synchronized对同一个线程是可重入的，进去一次monitor，count就加1。</p>
</li>
<li><p>java的线程是映射到操作系统的原生系统之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，状态转换需要耗费很多的时间。所以synchronized属于一个重量级锁。之后虚拟机也进行了优化，比如：自旋锁，自适应自旋锁，轻量级锁，偏向锁。</p>
<ul>
<li>自旋锁：线程没有获取到锁便进入忙循环，直到获取到锁。</li>
<li>自适应自旋：因为锁占用的时间长的话，自旋的时间太长浪费处理器资源，所以有了自适应自旋，自适应自旋的自旋时间不再固定，而是根据前一次在同一个锁上的自旋时间决定的。如果对于某个锁自旋很少成功，则省掉自旋过程，避免浪费资源，如果刚刚获得过成功，则自旋等待的时间持续相对的更长。</li>
<li>轻量级锁：在不存在锁竞争的时候起作用，当有锁竞争时会膨胀为重量级锁。轻量级锁是使用CAS操作完成的加锁解锁过程。虚拟机的对象头中有Mark Word，其中有两位用来存储锁标志位，代码进入同步块时，如果同步对象没有被锁定，虚拟机先在栈帧中建立一个锁记录，来存储锁对象目前的Mark Word的拷贝，然后虚拟机使用CAS操作将对象的Mark Word更新为指向锁记录的指针。如果更新成功了，这个线程就拥有了这个对象锁，否则，先检查Mark Word是否指向当前线程的栈帧，如果是直接进入同步块执行，否则说明锁已经被其他线程抢占了。</li>
<li>偏向锁：在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。意思是这个所锁会偏向与第一个获得它的线程，只要这个锁没有被其他线程获取，则持有偏向锁的线程将永远不需要同步。线程第一次获取锁时，对象头中的标志位设置为偏向模式，使用CAS将线程ID记录在Mark Word中，如果CAS成功，持有偏向锁的线程之后都不需要进行同步操作。当有另一个线程尝试获取锁时，偏向模式结束。</li>
</ul>
</li>
</ul>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><ul>
<li>ReentrantLock没有直接来继承AQS,而是定义了一个Sync类去继承AQS。</li>
<li>AQS维护了一个同步状态state，子类通过继承同步器并实现它的抽象方法来管理同步状态。(模板方法模式：定义一个操作中算法的骨架，而将一些步骤的实现延迟到子类中)</li>
<li>AQS维护了一个FIFO的同步队列，AQS则会将当前线程以及等待状态等信息构造成一个节点Node并将其加入到同步队列的队尾并一直保持着自旋。在同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</li>
<li>需要阻塞或者唤醒一个线程的时候，AQS都是使用LockSupport这个工具类来完成。</li>
<li>reentrantLock有两个内部类继承了AQS，是公平锁和非公平锁,实现了自己的获取和释放同步状态的方法。</li>
<li>ReentrantLock 也是可重入的。</li>
<li>同时ReentrantLock还增加了一些高级功能:<ul>
<li>可中断:当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</li>
<li>公平锁: 因为synchroized是非公平的，ReentrantLock有公平和非公平锁(默认是非公平锁)，所以公平锁是和sychronized的区别。多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁。</li>
<li>锁可绑定多个条件:一个ReentrantLock对象可以同时绑定多个Condition对象。</li>
</ul>
</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ul>
<li>说到死锁一般都会想到底什么情况下才叫作死锁。下面看下死锁的4个必要条件，即这4个条件都满足的情况就是发生了死锁，只要其中一个条件不满足，死锁就不存在。<ul>
<li>互斥：同一个资源每次只能一个进程使用。</li>
<li>资源不可抢占：不可抢占其他进程持有的资源。</li>
<li>循环等待：若干进程互相循环等待资源。</li>
<li>请求与保持：持有一个资源，又在请求另一个资源，请求不到资源就一直保持这个资源。</li>
</ul>
</li>
<li>既然说只要一个条件不满足就不是死锁，那为了不发生死锁，只要让其中一个条件不满足就行了。针对每一个条件，看看如何才能不发生死锁：<ul>
<li>互斥：这个条件一般不可避免，因为加锁就是为了互斥。</li>
<li>资源不可抢夺：只要准许抢夺，这个条件就不成立了。</li>
<li>循环等待：避免这个条件可以事先约定好锁的请求顺序，所有线程获取锁的顺序保持一致。</li>
<li>请求与保持：持有一个资源，想要获取其他资源，必须先释放当前持有的资源，才能请求其他资源。</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>在需要使用一些sychronized没有的功能时，一般使用ReentrantLock来实现同步，否则一般使用sychronized，在synchronized进行了优化之后，性能不再是优先选择ReentrantLock的条件。</li>
<li>synchronized和ReenttrantLock的相同点：<ul>
<li>都可重入</li>
<li>都实现了非公平锁</li>
</ul>
</li>
<li>synchronized和ReenttrantLock的不同点：<ul>
<li>synchronized是悲观锁，而ReentrantLock是乐观锁。</li>
<li>synchronized是java语法层面的锁，而ReentrantLock是api层面的锁</li>
<li>ReentrantLock需要手动解锁，而synchronized不需要</li>
<li>ReentrantLock可中断</li>
<li>ReentrantLock还实现了公平锁</li>
<li>ReentrantLock锁可绑定多个条件</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql学习</title>
    <url>/2020/01/11/mysql%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本篇介绍mysql。</p>
<a id="more"></a>

<h1 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h1><ol>
<li>MyISAM只支持表锁，InnoDB支持表锁和行锁。</li>
<li>MyISAM 强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持。InnoDB支持事务，外部键等高级数据库功能。 具有事务、回滚和崩溃修复能力。</li>
<li>MyISAM不支持外键，而InnoDB支持外键。</li>
<li>InnoDB支持MVVC多版本控制。应对高并发事务，MVCC比单纯的加锁更高效;MVCC只在<strong>读已提交</strong>和<strong>可重复读</strong>两个隔离级别下工作;MVCC可以使用乐观锁和悲观锁来实现;各数据库中MVCC实现并不统一。</li>
</ol>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><ul>
<li>mysql的InnodDB引擎有4种隔离级别：未提交读、已提交读、可重复读、串行化。隔离级别是为了定义各个事务之间是否会有影响，有什么影响。</li>
</ul>
<h2 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h2><p>未提交读的隔离级别最低，当前事务可以读取到其他还没有提交的事务里已经改变的数据。这个隔离级别会导致脏读，即读到脏数据。</p>
<ul>
<li>脏读：因为其他事务还未提交，当前事务读取了其他事务里改变的数据，但是其他事务回退了，这就导致当前事务读取了实际上并没有出现的数据。</li>
</ul>
<h2 id="已提交读"><a href="#已提交读" class="headerlink" title="已提交读"></a>已提交读</h2><p>已提交读隔离级别解决了上一个级别的脏读问题。只有事务提交了，其他事务才可以读取到当前事务里改变的数据。但是已提交读也会有两个问题：不可重复读和幻读。</p>
<ul>
<li>不可重复读：当前事务读取两次相同数据行数的数据，读取到数据行数相同，但是数据不一致。这个问题针对其他事务的修改操作，修改了当前事务读取到的数据行中的数据。</li>
<li>幻读：当前事务读取两次相同数据行数的数据，读取到数据行数不同。这个问题针对其他事务的增加和删除操作，增加或者删除了当前事务读取到的数据行中的数据。</li>
</ul>
<h2 id="可重复读-默认"><a href="#可重复读-默认" class="headerlink" title="可重复读(默认)"></a>可重复读(默认)</h2><p>可重复读级别使用行锁和间隙锁解决了上一个级别的两个问题。</p>
<ul>
<li>间隙锁：这个锁会锁住当前事务读取的范围内的数据，保证其他事务修改不了改范围内的数据。所以可以保证不会发生不可重复读和幻读的问题。</li>
</ul>
<h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><ul>
<li>串行化：顾名思义，事务串行执行，互不影响。一般很少用到，因为串行执行，效率不高。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>远程debug</title>
    <url>/2020/01/10/%E8%BF%9C%E7%A8%8Bdebug/</url>
    <content><![CDATA[<p>本篇主要介绍远程debug的方法和原理。</p>
<a id="more"></a>

<h1 id="远程debug的方法"><a href="#远程debug的方法" class="headerlink" title="远程debug的方法"></a>远程debug的方法</h1><p><img src="http://ww1.sinaimg.cn/large/dbf344a4ly1garr9qdj5lj21tk11gx2s.jpg" alt="e26987facabe4fe880b3bbd5d5dca99e_039a1fb5d3b29cc76b1177e798211722.jpg"></p>
<ul>
<li>在Edit Configurations中新建一个Remote</li>
<li>配置下远程服务的host和port。</li>
<li>远程服务启动时必须使用如下参数才能debug</li>
<li>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9806<ul>
<li>jdwp:是 Java Debug Wire Protocol的缩写</li>
<li>server=y表示是监听其他debugclient端的请求</li>
<li>address=9806表示服务会在端口号9806监听debug请求，客户端必须设置这个端口号才能进行dubug</li>
<li>suspend表示是否在调试客户端建立连接之后启动VM。如果为y，那么当前的VM就是suspend直到有debug client连接进来才开始执行程序。如果你的程序不是服务器监听模式并且很快就执行完毕的，那么可以选择在y来阻塞它的启动。为n则先启动，并监听端口，等待客户端连接。</li>
</ul>
</li>
<li>调试模式有两种：attach和listen。图中选的是attach。<ul>
<li>attach:远程服务启动一个端口等待调试客户端去连接。</li>
<li>listen:调试客户端去监听一个端口，当调试服务端准备好了，就会进行连接。</li>
</ul>
</li>
<li>传输方式：mac和linux默认使用Socket进行数据传输，windows使用共享内存方式。</li>
</ul>
<h1 id="远程debug的原理"><a href="#远程debug的原理" class="headerlink" title="远程debug的原理"></a>远程debug的原理</h1><p>远程服务是用来上述的参数启动后，会在指定的端口上进行监听，等待调试客户端去连接。我们在idea使用remote debug时就是启了一个客户端，连接远程服务器。两者使用debug协议（jdwp）进行通信实现远程调试。</p>
<h1 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h1><ul>
<li>在远程debug时，打断点不要打在可能被其他请求也使用的方法中，这会造成混淆。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2020/01/06/redis/</url>
    <content><![CDATA[<p>本文主要介绍redis。</p>
<a id="more"></a>

<h1 id="redis支持的数据结构"><a href="#redis支持的数据结构" class="headerlink" title="redis支持的数据结构"></a>redis支持的数据结构</h1><ul>
<li><p>字符串（String）</p>
<ul>
<li>字符串对象的编码可以是：int,raw或者embstr</li>
<li>如果一个字符串对象保存的是整数，则使用int编码；如果保存的是长度大于32字节的字符串值，则使用raw编码，否则使用embstr编码。</li>
</ul>
</li>
<li><p>散列（Hash）</p>
<ul>
<li>hash对象的编码可以是ziplist和hashtable</li>
<li>ziplist编码的hash对象使用压缩列表实现；hashtable编码的hash对象使用字典实现。</li>
</ul>
</li>
<li><p>列表（List）</p>
<ul>
<li>列表对象的编码可以是ziplist或者linkelist</li>
<li>ziplist编码的列表对象使用压缩列表实现，linkedlist编码的列表对象使用双端队列实现。</li>
<li>列表对象保存的所有字符串元素的长度都小于64字节，元素数量小于512个，列表对象使用ziplist编码，否则使用linkedlist.</li>
</ul>
</li>
<li><p>集合（Set）</p>
<ul>
<li>集合对象的编码可以是intset或者hashtable。</li>
<li>intset编码的集合对象使用整数集合实现；hashtable编码的集合对象使用字典实现，字典的每一个键是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值都是null。</li>
<li>inset编码的集合对象在不满足条件：所有元素都是整数，且元素数量不超过512个时，编码会转换成hashtable。</li>
</ul>
</li>
<li><p>有序集合（Sorted Set）</p>
<ul>
<li>有序集合对象编码可以是ziplist或skiplist。</li>
<li>ziplist编码的有序集合对象使用压缩列表实现，每个集合元素使用两个紧挨在一起的压缩列表来保存,第一个节点保存元素的成员，第二个节点保存元素的分值；压缩列表内集合元素按分值从小到大排序；skiplist编码的有序集合对象使用zset实现，zset结构包含了一个字典和一个跳表。字典为有序集合创建了一个从成员到分值的映射，通过字典可以以O(1)复杂度查找给定成员的分值；跳表可以对有序集合进行范围性型操作。</li>
<li>有序集合的元素数量小于128个且所有元素长度都小于64字节时使用ziplist编码，否则使用skiplist编码。</li>
</ul>
</li>
<li><p>Bitmaps</p>
<ul>
<li>通过一个bit位来表示某个元素对应的值或者状态,其中的key就是对应元素本身。本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。</li>
</ul>
</li>
<li><p>Hyperloglogs</p>
<ul>
<li>用来做基数统计的算法，优点是:在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的，并且是很小的。</li>
</ul>
</li>
<li><p>地理空间（Geospatial）及索引半径查询</p>
</li>
</ul>
<h1 id="redis为什么这么快"><a href="#redis为什么这么快" class="headerlink" title="redis为什么这么快"></a>redis为什么这么快</h1><ul>
<li><p>基于内存。数据存在内存中，类似于HashMap，查找和操作的时间复杂度都是O(1)</p>
</li>
<li><p>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。</p>
</li>
<li><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p>
</li>
<li><p>使用多路I/O复用模型，非阻塞IO。</p>
</li>
<li><p>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p>
</li>
</ul>
<h1 id="redis-为什么是单线程"><a href="#redis-为什么是单线程" class="headerlink" title="redis 为什么是单线程"></a>redis 为什么是单线程</h1><ul>
<li>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</li>
<li>单线程，只是说在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis服务器运行的时候肯定是不止一个线程的，例如Redis进行持久化的时候会以子进程或者子线程的方式执行。</li>
</ul>
<h1 id="键过期策略"><a href="#键过期策略" class="headerlink" title="键过期策略"></a>键过期策略</h1><ul>
<li>保证Redis不会超过可用内存的方法是为键设置超时时间。三种过期策略：<ul>
<li>定时删除：在设置key的过期时间的同时，创建一个定时器(timer)，让定时器在key的过期时间来临时，立即执行对key的删除操作。<ul>
<li>优点：能及时删除过期key，内存被释放。</li>
<li>缺点：占用太多CPU时间，影响服务器的响应时间和吞吐量</li>
</ul>
</li>
<li>惰性删除：放任key过期不管，但是每次去数据库获取key的时候去检查是否过期，若过期，则删除，返回null。<ul>
<li>优点：在进行get或setnx等操作时，先检查key是否过期，不会占用太多cpu。</li>
<li>缺点：可能有大量过期的key没有再次被访问，不会被清除，这样会浪费太多内存，有内存泄漏的危险。</li>
</ul>
</li>
<li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面过期的key。<ul>
<li>是前两种策略的折中。</li>
</ul>
</li>
</ul>
</li>
<li>redis实现的是惰性删除和定期删除。</li>
</ul>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><ul>
<li>缓存宕机或缓存同时失效，请求都打到数据库，造成数据库崩溃，这是缓存雪崩。</li>
<li>解决方法：<ul>
<li>事前：redis 高可用，避免全盘崩溃；失效时间加随机值</li>
<li>事中：本地缓存 + hystrix限流&amp;降级，避免MySQL被打死</li>
<li>事后：redis持久化，快速恢复缓存数据</li>
</ul>
</li>
</ul>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><ul>
<li>恶意查找数据库一定不存在的数据，缓存不起作用，数据库被打死。</li>
<li>解决方法：<ul>
<li>1，不存在的值也放到缓存，过期时间设置的短</li>
<li>2，布隆过滤器，不存在的值直接过滤</li>
</ul>
</li>
</ul>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><ul>
<li>有两个命令可以生成RBD文件：SAVE和BGSAVE。SAVE命令会阻塞服务器进程，直到RDB文件创建完成为止；而BIGSAVE命令会派生出一个子进程，由子进程来生成RDB文件。</li>
<li>RDB文件的载入在redis重启检测到RDB文件时自动执行。如果服务器开启了AOF功能，因为通常AOF的更新频率比RDB高，会优先使用AOF文件来还原数据库状态。</li>
<li>RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。</li>
<li>BIGSAVE命令执行期间，客户端发送的SAVE，BIGSAVE命令都会被拒绝。</li>
<li>BIGREWRITEAOF和BIGSAVE命令不能同时执行，BIGSAVE正在执行，收到的BIGREWRITEAOF会被延迟；BIGREWRITEAOF正在执行，收到的BIGSAVE会被拒绝。</li>
<li>可以通过设置save选项设置保存条件，只要其中一个条件满足，就会自动执行BIGSAVE命令。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><ul>
<li>AOF是通过保存redis执行的写命令来记录数据库状态的。</li>
<li>命令追加：打开AOP持久化功能时，服务器在执行完一个写命令后，会以协议格式将命令追加到服务器状态的aof_buf缓冲区的末尾。</li>
<li>appendfsync决定了如何进行持久化：always,everysec,no。</li>
<li>AOF的载入和数据还原：通过创建一个不带网络连接的伪客户端，解析每一条aof命令并执行。</li>
<li>AOF重写：目的是减少aof的空间占用。从数据库读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。</li>
<li>解决重写导致的不一致问题：设置了一个AOF重写缓冲区，这个缓冲区在创建子进程之后开始使用，当redis执行完一个写命令之后，需要同时将这个写命令发送给AOF缓存区和AOF重写缓冲区。这样可以保证：1，AOF缓冲区的内容会定期被写入到和同步到AOF文件中，对现有AOF文件的处理工作会如常进行。2，从创建子进程之后，所有写命令都会被写入到AOF重写缓冲区中。当子进程完成AOF重写工作之后，它会向父进程发送信号，父进程会执行以下工作：1，将AOF重写缓冲区中的所有内容写入到AOF文件中，这时新AOF文件的状态和数据库状态是一致的。 2， 对新AOF文件进行改名，原子的覆盖旧AOF文件。</li>
</ul>
<h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><ul>
<li>PSYNC具有完整重同步和部分重同步功能。<h2 id="完整重同步"><a href="#完整重同步" class="headerlink" title="完整重同步"></a>完整重同步</h2></li>
<li>完整重同步用于处理初次复制的情况，通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓存区中的写命令来进行同步。<h2 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h2></li>
<li>主从服务器分别维护一个复制偏移量，传播N个字节数据，偏移量增加N。通过比较偏移量，可以很容易知道主从服务器是否一致。</li>
<li>复制积压缓冲区：是一个由主服务器维护的固定长度的先进先出的队列，默认大小为1MB。保存着一部分最近传播的写命令。所以根据从服务器的偏移量是否在复制积压缓冲区中存在来决定使用哪种同步。如果在使用部分重同步，否则使用完整重同步。</li>
<li>服务器运行ID：redis服务器都会有自己的运行ID,在启动时自动生成，由40个随机的十六进制字符组成。断线重连之后，如果从服务器保存的主服务器运行ID和重写连接的主服务器运行Id不一样，则使用完整重同步。</li>
</ul>
<h1 id="哨兵模式sentinel"><a href="#哨兵模式sentinel" class="headerlink" title="哨兵模式sentinel"></a>哨兵模式sentinel</h1><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ul>
<li>redis通过MULTI,EXEC,WATCH,DISCARD命令实现事务的功能。</li>
<li>在MUTLI命令之后的命令会放入到一个事务队列中去，当遇到MULTI,ISCARD,EXEC,WATCH命令时 ，会立即执行。遇到EXEC命令，会将事务队列中的命令都执行。</li>
<li>WATCH命令可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个被修改过，如果是的话，服务器将拒绝执行事务。</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>spring的@schedule注解调度任务原理</title>
    <url>/2020/01/06/spring%E7%9A%84@schedule%E6%B3%A8%E8%A7%A3%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>本篇文章主要阅读源码看看@schdule注解是如何工作的。</p>
<a id="more"></a>

<blockquote>
<p>问题写在前面：</p>
<ul>
<li>schedule注解的任务是何时实例化成任务的</li>
<li>调度任务如何调度的</li>
</ul>
</blockquote>
<h1 id="schedule注解"><a href="#schedule注解" class="headerlink" title="schedule注解"></a>schedule注解</h1><ul>
<li><p>首先看下@schedule注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// Schedules注解可以包含多个Scheduled，即多个调度任务</span></span><br><span class="line"><span class="meta">@Repeatable</span>(Schedules<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">Scheduled</span> </span>&#123;</span><br><span class="line">	<span class="comment">// corn 表达式</span></span><br><span class="line">	<span class="function">String <span class="title">cron</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">	<span class="comment">//时区，默认服务器本地时区</span></span><br><span class="line">	<span class="function">String <span class="title">zone</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一次任务调用结束和下一次调用开始之间的间隔</span></span><br><span class="line">	<span class="function"><span class="keyword">long</span> <span class="title">fixedDelay</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">	<span class="comment">// 上一个的string格式</span></span><br><span class="line">	<span class="function">String <span class="title">fixedDelayString</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两次任务执行开始之间的间隔</span></span><br><span class="line">	<span class="function"><span class="keyword">long</span> <span class="title">fixedRate</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">	<span class="comment">// 上一个的string格式</span></span><br><span class="line">	<span class="function">String <span class="title">fixedRateString</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始延迟</span></span><br><span class="line">	<span class="function"><span class="keyword">long</span> <span class="title">initialDelay</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">	<span class="comment">// 上一个的string格式</span></span><br><span class="line">	<span class="function">String <span class="title">initialDelayString</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过查看这个注解里的方法的调用方，可以看到是在ScheduledAnnotationBeanPostProcessor里的processScheduled方法调用的。</p>
</li>
</ul>
<h1 id="ScheduledAnnotationBeanPostProcessor"><a href="#ScheduledAnnotationBeanPostProcessor" class="headerlink" title="ScheduledAnnotationBeanPostProcessor"></a>ScheduledAnnotationBeanPostProcessor</h1><ul>
<li>ScheduledAnnotationBeanPostProcessor也被初始配置成了bean。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulingConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span>(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)</span><br><span class="line">	<span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ScheduledAnnotationBeanPostProcessor <span class="title">scheduledAnnotationProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ScheduledAnnotationBeanPostProcessor();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ScheduledAnnotationBeanPostProcessor实例中包含了ScheduledTaskRegistrar实例，这个实例中有线程池TaskScheduler，后面会讲到线程池是如何设置的。</li>
</ul>
<h2 id="processScheduled方法"><a href="#processScheduled方法" class="headerlink" title="processScheduled方法"></a>processScheduled方法</h2><ul>
<li><p>该方法负责解析schedule注解里参数并生成调度任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processScheduled</span><span class="params">(Scheduled scheduled, Method method, Object bean)</span> </span>&#123;</span><br><span class="line">    Method invocableMethod = AopUtils.selectInvocableMethod(method, bean.getClass());</span><br><span class="line">    Runnable runnable = <span class="keyword">new</span> ScheduledMethodRunnable(bean, invocableMethod);</span><br><span class="line">    <span class="keyword">boolean</span> processedSchedule = <span class="keyword">false</span>;</span><br><span class="line">    String errorMessage =</span><br><span class="line">            <span class="string">"Exactly one of the 'cron', 'fixedDelay(String)', or 'fixedRate(String)' attributes is required"</span>;</span><br><span class="line">    Set&lt;ScheduledTask&gt; tasks = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出初始延迟参数</span></span><br><span class="line">    <span class="keyword">long</span> initialDelay = scheduled.initialDelay();</span><br><span class="line">    String initialDelayString = scheduled.initialDelayString();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(initialDelayString)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.embeddedValueResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            initialDelayString = <span class="keyword">this</span>.embeddedValueResolver.resolveStringValue(initialDelayString);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(initialDelayString)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                initialDelay = parseDelayAsLong(initialDelayString);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析cron表达式，生成CronTask任务</span></span><br><span class="line">    String cron = scheduled.cron();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(cron)) &#123;</span><br><span class="line">        String zone = scheduled.zone();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.embeddedValueResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cron = <span class="keyword">this</span>.embeddedValueResolver.resolveStringValue(cron);</span><br><span class="line">            zone = <span class="keyword">this</span>.embeddedValueResolver.resolveStringValue(zone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(cron)) &#123;</span><br><span class="line">            Assert.isTrue(initialDelay == -<span class="number">1</span>, <span class="string">"'initialDelay' not supported for cron triggers"</span>);</span><br><span class="line">            processedSchedule = <span class="keyword">true</span>;</span><br><span class="line">            TimeZone timeZone;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(zone)) &#123;</span><br><span class="line">                timeZone = StringUtils.parseTimeZoneString(zone);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                timeZone = TimeZone.getDefault();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 任务注册到registrar中</span></span><br><span class="line">            tasks.add(<span class="keyword">this</span>.registrar.scheduleCronTask(<span class="keyword">new</span> CronTask(runnable, <span class="keyword">new</span> CronTrigger(cron, timeZone))));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始延迟&lt;0的都设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (initialDelay &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        initialDelay = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析fixed delay，生成FixedDelayTask任务</span></span><br><span class="line">    <span class="keyword">long</span> fixedDelay = scheduled.fixedDelay();</span><br><span class="line">    <span class="keyword">if</span> (fixedDelay &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Assert.isTrue(!processedSchedule, errorMessage);</span><br><span class="line">        processedSchedule = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 任务注册到registrar中</span></span><br><span class="line">        tasks.add(<span class="keyword">this</span>.registrar.scheduleFixedDelayTask(<span class="keyword">new</span> FixedDelayTask(runnable, fixedDelay, initialDelay)));</span><br><span class="line">    &#125;</span><br><span class="line">    String fixedDelayString = scheduled.fixedDelayString();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(fixedDelayString)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.embeddedValueResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fixedDelayString = <span class="keyword">this</span>.embeddedValueResolver.resolveStringValue(fixedDelayString);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(fixedDelayString)) &#123;</span><br><span class="line">            Assert.isTrue(!processedSchedule, errorMessage);</span><br><span class="line">            processedSchedule = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fixedDelay = parseDelayAsLong(fixedDelayString);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 任务注册到registrar中</span></span><br><span class="line">            tasks.add(<span class="keyword">this</span>.registrar.scheduleFixedDelayTask(<span class="keyword">new</span> FixedDelayTask(runnable, fixedDelay, initialDelay)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析fixed rate,生成FixedRateTask任务</span></span><br><span class="line">    <span class="keyword">long</span> fixedRate = scheduled.fixedRate();</span><br><span class="line">    <span class="keyword">if</span> (fixedRate &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Assert.isTrue(!processedSchedule, errorMessage);</span><br><span class="line">        processedSchedule = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 任务注册到registrar中</span></span><br><span class="line">        tasks.add(<span class="keyword">this</span>.registrar.scheduleFixedRateTask(<span class="keyword">new</span> FixedRateTask(runnable, fixedRate, initialDelay)));</span><br><span class="line">    &#125;</span><br><span class="line">    String fixedRateString = scheduled.fixedRateString();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(fixedRateString)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.embeddedValueResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fixedRateString = <span class="keyword">this</span>.embeddedValueResolver.resolveStringValue(fixedRateString);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(fixedRateString)) &#123;</span><br><span class="line">            Assert.isTrue(!processedSchedule, errorMessage);</span><br><span class="line">            processedSchedule = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fixedRate = parseDelayAsLong(fixedRateString);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 任务注册到registrar中</span></span><br><span class="line">            tasks.add(<span class="keyword">this</span>.registrar.scheduleFixedRateTask(<span class="keyword">new</span> FixedRateTask(runnable, fixedRate, initialDelay)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.scheduledTasks) &#123;</span><br><span class="line">        Set&lt;ScheduledTask&gt; registeredTasks = <span class="keyword">this</span>.scheduledTasks.get(bean);</span><br><span class="line">        <span class="keyword">if</span> (registeredTasks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            registeredTasks = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">this</span>.scheduledTasks.put(bean, registeredTasks);</span><br><span class="line">        &#125;</span><br><span class="line">        registeredTasks.addAll(tasks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>processScheduled方法负责解析schedule注解的参数，生成相应的调度任务，存入ScheduledTaskRegistrar实例中。</p>
</li>
<li><p>解析生成的任务都放入了线程池中执行，执行任务的逻辑在下面的scheduleTasks方法里。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">scheduleTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.taskScheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.localExecutor = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        <span class="keyword">this</span>.taskScheduler = <span class="keyword">new</span> ConcurrentTaskScheduler(<span class="keyword">this</span>.localExecutor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.triggerTasks != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (TriggerTask task : <span class="keyword">this</span>.triggerTasks) &#123;</span><br><span class="line">            <span class="comment">// 调度triggerTask</span></span><br><span class="line">            addScheduledTask(scheduleTriggerTask(task));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cronTasks != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (CronTask task : <span class="keyword">this</span>.cronTasks) &#123;</span><br><span class="line">            <span class="comment">// 调度CronTask</span></span><br><span class="line">            addScheduledTask(scheduleCronTask(task));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fixedRateTasks != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (IntervalTask task : <span class="keyword">this</span>.fixedRateTasks) &#123;</span><br><span class="line">            <span class="comment">// 调度FixedRateTask</span></span><br><span class="line">            addScheduledTask(scheduleFixedRateTask(task));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fixedDelayTasks != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (IntervalTask task : <span class="keyword">this</span>.fixedDelayTasks) &#123;</span><br><span class="line">            <span class="comment">// 调度FixedDelayTask</span></span><br><span class="line">            addScheduledTask(scheduleFixedDelayTask(task));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用TaskScheduler调度各种调度任务，并将返回结果future封装在ScheduleTask中，可以看到最底层的线程池其实就是ScheduledThreadPoolExecutor。见另一篇</p>
</li>
<li><p>此方法是在afterPropertiesSet方法中调用的，从下面的代码可以看到afterPropertiesSet是在ScheduledAnnotationBeanPostProcessor类的onApplicationEvent方法中调用的，而onApplicationEvent则是重写了ApplicationListener接口的方法。后面会说这个ApplicationListener。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.getApplicationContext() == <span class="keyword">this</span>.applicationContext) &#123;</span><br><span class="line">        finishRegistration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishRegistration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.scheduler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.registrar.setScheduler(<span class="keyword">this</span>.scheduler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">        Map&lt;String, SchedulingConfigurer&gt; beans =</span><br><span class="line">                ((ListableBeanFactory) <span class="keyword">this</span>.beanFactory).getBeansOfType(SchedulingConfigurer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;SchedulingConfigurer&gt; configurers = <span class="keyword">new</span> ArrayList&lt;&gt;(beans.values());</span><br><span class="line">        AnnotationAwareOrderComparator.sort(configurers);</span><br><span class="line">        <span class="keyword">for</span> (SchedulingConfigurer configurer : configurers) &#123;</span><br><span class="line">            configurer.configureTasks(<span class="keyword">this</span>.registrar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registrar.hasTasks() &amp;&amp; <span class="keyword">this</span>.registrar.getScheduler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.registrar.setTaskScheduler(resolveSchedulerBean(beanFactory, TaskScheduler<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>))</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoUniqueBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.registrar.setTaskScheduler(resolveSchedulerBean(beanFactory, TaskScheduler<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.registrar.setScheduler(resolveSchedulerBean(beanFactory, ScheduledExecutorService<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>))</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NoUniqueBeanDefinitionException ex2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.registrar.setScheduler(resolveSchedulerBean(beanFactory, ScheduledExecutorService<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.registrar.afterPropertiesSet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面的finishRegistration方法主要负责通过by-type/by-name方式找到可用的线程池bean,并设置给ScheduledTaskRegistrar实例，用于调度任务。</p>
</li>
<li><p>但是还有个疑问onApplicationEvent是什么时候调用的。这时候就需要研究下ApplicationListener这个类。看<br>onApplicationEvent方法的参数是ContextRefreshedEvent，可以知道监听的是ContextRefreshedEvent事件。只要知道事件在何时发布就可以知道任务在什么时候会被调度了。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    。。。</span><br><span class="line">    <span class="comment">// 发布事件</span></span><br><span class="line">    publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以看到事件是在finishRefresh方法中发布的，往上还可以追溯到SpringApplication的run方法，这里就不贴代码了，所以是在web启动时，refresh最后阶段，广播了ContextRefreshedEvent事件。web启动的过程以后再总结。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>schedule注解何时实例化任务的：有schedule注解的方法在其所在的类实例化成bean的时候已经被解析成Scheduled，解析Scheduled里的参数生成调度任务是在ScheduledAnnotationBeanPostProcessor初始化之后调用的。</li>
<li>任务如何调度的：应用启动的最后阶段会发布ContextRefreshedEvent事件，作为监听了这个事件的bean(ScheduledAnnotationBeanPostProcessor)当接收到事件时，会获取可用线程池，设置在ScheduledTaskRegistrar实例中，ScheduledTaskRegistrar负责调度任务。</li>
</ul>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>周期调度线程池ScheduledThreadPoolExecutor</title>
    <url>/2020/01/01/%E5%91%A8%E6%9C%9F%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0ScheduledThreadPoolExecutor/</url>
    <content><![CDATA[<blockquote>
<p>java中实现周期性任务调度的方式有多种，比如Timer，@Schedule注解，还有就是本篇将要介绍的周期调度线程池ScheduledThreadPoolExecutor，主要看看是如何进行周期调度的。</p>
</blockquote>
<a id="more"></a>
<ul>
<li>我们从他的周期调度方法scheduleAtFixedRate和scheduleWithFixedDelay着手：</li>
<li>写在前面，scheduleAtFixedRate和scheduleWithFixedDelay的区别是：scheduleWithFixedDelay是在任务执行完之后延迟一段时间再执行下一次任务；scheduleAtFixedRate是每隔一段时间就执行一次，但如果任务执行时间比周期时间长，下一次任务会在上次任务执行完立即执行，所以周期时间设置一般需要比任务执行时间长。</li>
</ul>
<h1 id="scheduleAtFixedRate"><a href="#scheduleAtFixedRate" class="headerlink" title="scheduleAtFixedRate"></a>scheduleAtFixedRate</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> period,TimeUnit unit)&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 生成周期任务ScheduledFutureTask</span></span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft = <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(</span><br><span class="line">        command,</span><br><span class="line">        <span class="keyword">null</span>,</span><br><span class="line">        <span class="comment">// triggerTime是计算出执行的时间</span></span><br><span class="line">        triggerTime(initialDelay, unit),</span><br><span class="line">        <span class="comment">// 这里和scheduleWithFixedDelay不一样，另一个是unit.toNanos(-delay)</span></span><br><span class="line">        unit.toNanos(period));</span><br><span class="line">    <span class="comment">// 这个方法默认只是原样返回了sft</span></span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    <span class="comment">// 核心方法在这</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们进一步看下delayedExecute方法，scheduleWithFixedDelay方法最终也是执行的该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 任务加入到队列中</span></span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp;</span><br><span class="line">            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</span><br><span class="line">            remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 预启动线程，运行的线程数小于核心线程数，启动一个线程；运行的线程数==0，启动一个非核心线程数。保证至少有一个运行的线程</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的代码逻辑是线程池正常，会把任务放进队列中，从构造函数能够看到是DelayedWorkQueue。但是没看到任务是何时怎么被执行的。所以我们得找到从队列取出任务执行的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">        <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在需要知道的是任务何时从队列中取出，和如何进行周期执行任务。</p>
</li>
<li><p>任务被取出执行是在父类ThreadPoolExecutor中执行的，是线程从队列中任务进行执行，对于ScheduledThreadPoolExecutor线程池来说，即从DelayedWorkQueue队列中取出ScheduledFutureTask任务来执行。这时候我们先去看下DelayedWorkQueue的取出逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 取出第一个任务</span></span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第一个任务的delay延时时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 如果delay&lt;0,会被立即取出，剩余任务根据delay时间重新将最小的delay放到第一个。</span></span><br><span class="line">                    <span class="comment">// 其实就是一个最小树</span></span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// delay&gt;0,即需要等待，将引用置null</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 等待delay时间，进入下一次循环，取出第一个任务</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delay = time-now</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(time - now(), NANOSECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从上面可以看出从DelayedWorkQueue队列中取出ScheduledFutureTask任务，是获取第一个delay最小的任务，如果delay&lt;0,会被立即执行，否知等待delay时间再取出执行，下面看下任务执行逻辑以及如何周期执行的。</p>
</li>
<li><p>下面是ScheduledFutureTask的run方法，是ScheduledThreadPoolExecutor的内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先判断是否是周期性任务(period!=0)</span></span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">        <span class="comment">// runAndReset是任务执行完成</span></span><br><span class="line">        <span class="comment">// 主要看周期任务的逻辑，首先设置下一次任务时间</span></span><br><span class="line">        setNextRunTime();</span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>周期性任务首先设置下一次任务时间，执行reExecutePeriodic方法，下面分别看下setNextRunTime和reExecutePeriodic方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = period;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 对应scheduleAtFixedRate的period，算出每次执行的时间</span></span><br><span class="line">        time += p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 对应scheduleAtFixedDelay的period，执行时间是当前时间+period</span></span><br><span class="line">        time = triggerTime(-p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now() +</span><br><span class="line">        ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里就看出了scheduleAtFixedRate和scheduleAtFixedDelay的不同了，他们计算下一次任务执行时间的方式不一样。scheduleAtFixedRate的执行时间是确定的，每隔period执行一次，但是真正执行的时间不一定，因为是在上一个任务执行完后才会将下一个任务加到队列中，所以下一个任务取决于上一个任务的执行结束时间和周期时间，如果超过了本来算好应该执行的时间，即这时delay=time-now&lt;0,任务被取出时会立即执行；scheduleAtFixedDelay的执行时间是上一个任务执行完，当前时间加period。</p>
</li>
<li><p>下面看下reExecutePeriodic方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// 将重新设置时间的任务放进DelayedWorkQueue</span></span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="keyword">true</span>) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>ScheduleThreadPoolExecutor可以使用scheduleAtFixedRate和scheduleAtFixedDelay两种周期调度方式。</p>
</li>
<li><p>scheduleAtFixedRate和scheduleAtFixedDelay的不同是：他们计算下一次任务执行时间的方式不一样。</p>
<ul>
<li>scheduleAtFixedRate的执行时间是确定的，每隔period执行一次，但是真正执行的时间不一定，因为是在上一个任务执行完后才会将下一个任务加到队列中，所以下一个任务取决于上一个任务的执行结束时间和周期时间，如果超过了本来算好应该执行的时间，即这时delay=time-now&lt;0,任务被取出时会立即执行。</li>
<li>scheduleAtFixedDelay的执行时间是上一个任务执行完，当前时间+period。</li>
</ul>
</li>
<li><p>scheduleAtFixedRate和scheduleAtFixedDelay的相同点是：都是将任务放入延迟队列中来是实现周期性调度的效果，任务执行完计算下一次执行的时间并放入队列。</p>
</li>
<li><p>见。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis加载配置</title>
    <url>/2019/12/29/mybatis-%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>本文主要看下mybatis的配置文件配置了哪些东西，做了什么工作。</p>
<a id="more"></a>

<blockquote>
<p>查看源码可以追踪到XMLConfigBuilder类，这个类主要是做加载配置工作，生成Configution。通过Configuration新建SqlSessionFactory，这个以后再细看，这篇主要看加载配置过程。</p>
</blockquote>
<h1 id="XMLConfigBuilder"><a href="#XMLConfigBuilder" class="headerlink" title="XMLConfigBuilder"></a>XMLConfigBuilder</h1><ul>
<li>先看下这个类的代码，主要代码如下，</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    parsed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 从根节点configuration开始解析</span></span><br><span class="line">    parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Properties settings = settingsAsPropertiess(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">      <span class="comment">//issue #117 read properties first</span></span><br><span class="line">      propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">      pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">      objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">      reflectionFactoryElement(root.evalNode(<span class="string">"reflectionFactory"</span>));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">      environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">      typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">      mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从上面代码能够看到，在根节点下配置了10个子节点， 分别为：properties、typeAliases、plugins、objectFactory、objectWrapperFactory、settings、environments、databaseIdProvider、typeHandlers、mappers。</li>
</ul>
<p>下面分别对10个子节点进行解析,进入具体的方法中找寻答案：</p>
<h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><ul>
<li>一起看下代码，注释写在其中：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">propertiesElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取properties所有子节点property作为default，其实就是一个map</span></span><br><span class="line">      Properties defaults = context.getChildrenAsProperties();</span><br><span class="line">      <span class="comment">// properties有resource和url属性，接着往下看</span></span><br><span class="line">      String resource = context.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">      String url = context.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">      <span class="comment">// 这里表明resource和url只能有一个</span></span><br><span class="line">      <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 接下来是对resource和url的不同处理</span></span><br><span class="line">      <span class="comment">// 获取到的k-v如果有相同k会覆盖之前property节点的值,因为是map，所以会覆盖</span></span><br><span class="line">      <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        defaults.putAll(Resources.getResourceAsProperties(resource));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">        defaults.putAll(Resources.getUrlAsProperties(url));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将这个节点下的配置加入到全局的configuration和parser中。</span></span><br><span class="line">      Properties vars = configuration.getVariables();</span><br><span class="line">      <span class="keyword">if</span> (vars != <span class="keyword">null</span>) &#123;</span><br><span class="line">        defaults.putAll(vars);</span><br><span class="line">      &#125;</span><br><span class="line">      parser.setVariables(defaults);</span><br><span class="line">      configuration.setVariables(defaults);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>接下来看下resource和url有什么不同：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">getResourceAsProperties</span><span class="params">(String resource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    InputStream in = getResourceAsStream(resource);</span><br><span class="line">    props.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">return</span> props;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">getUrlAsProperties</span><span class="params">(String urlString)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    InputStream in = getUrlAsStream(urlString);</span><br><span class="line">    props.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">return</span> props;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到差别只在getResourceAsStream和getUrlAsStream方法之间，他们的入参不同，返回对象相同。分别看到最底层方法。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputStream <span class="title">getResourceAsStream</span><span class="params">(ClassLoader loader, String resource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream in = classLoaderWrapper.getResourceAsStream(resource, loader);</span><br><span class="line">    <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Could not find resource "</span> + resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputStream <span class="title">getUrlAsStream</span><span class="params">(String urlString)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    URL url = <span class="keyword">new</span> URL(urlString);</span><br><span class="line">    URLConnection conn = url.openConnection();</span><br><span class="line">    <span class="keyword">return</span> conn.getInputStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>resource是用来引入类路径下的资源，url是用来引入网络路径的资源，两者只能选其一。</li>
<li>共同点都是转成流获取到属性，只是获取的源头不一样而已。</li>
</ul>
<h2 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h2><ul>
<li>下面看下typeAliases节点，主要用途是定义别名<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">typeAliasesElement</span><span class="params">(XNode parent)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//子节点如果是package，即指定包名，该包下的类都会有别名，别名默认是转成小写</span></span><br><span class="line">      <span class="comment">//也可以使用@Alias注解进行加别名，这个优先级比在配置文件里写的要高</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">        String typeAliasPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是typeAlias子节点，一个一个进行设置别名</span></span><br><span class="line">        String alias = child.getStringAttribute(<span class="string">"alias"</span>);</span><br><span class="line">        String type = child.getStringAttribute(<span class="string">"type"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Class&lt;?&gt; clazz = Resources.classForName(type);</span><br><span class="line">          <span class="keyword">if</span> (alias == <span class="keyword">null</span>) &#123;</span><br><span class="line">            typeAliasRegistry.registerAlias(clazz);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typeAliasRegistry.registerAlias(alias, clazz);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error registering typeAlias for '"</span> + alias + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void pluginElement(XNode parent) throws Exception &#123;</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 解析每个Interceptor节点，生成Interceptor对象，并设置属性，加入到拦截器链中</span><br><span class="line">        String interceptor &#x3D; child.getStringAttribute(&quot;interceptor&quot;);</span><br><span class="line">        Properties properties &#x3D; child.getChildrenAsProperties();</span><br><span class="line">        Interceptor interceptorInstance &#x3D; (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">        interceptorInstance.setProperties(properties);</span><br><span class="line">        configuration.addInterceptor(interceptorInstance);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Interceptor有三个方法：intercept,plugin,setProperties。setProperties是用来设置属性给拦截器使用，主要方法是intercept和plugin。拦截器示例可见</p>
<ul>
<li><p>@Intercepts({ @Signature(type = StatementHandler.class, method = “prepare”, args = { Connection.class, Integer.class }) })</p>
<ul>
<li>此注解是表名拦截那个类的哪个方法和方法的入参类型。其实就是拦截的规则，对哪些方法进行拦截。</li>
<li>也可以写同一个类的不同方法，即对同一个类的不同方法进行拦截。</li>
</ul>
</li>
<li><p>interceptor ，该方法是拦截后的操作。</p>
</li>
<li><p>plugin ,该方法一般这么写，Plugin.wrap(o, this); 作用是为目标类生成代理类。Plugin实现了InvocationHandler，熟悉动态代理的就知道了。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">  Class&lt;?&gt; type = target.getClass();</span><br><span class="line">  Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">  <span class="comment">// 目标类的接口和Intercepts注解中signature的类有相同的，即符合注解中规则的，为其生成代理类</span></span><br><span class="line">  <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">        type.getClassLoader(),</span><br><span class="line">        interfaces,</span><br><span class="line">        <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看下代理类的执行方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">      <span class="comment">// 这里便是执行我们自己写的拦截器的intercept方法</span></span><br><span class="line">      <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="objectFactory"><a href="#objectFactory" class="headerlink" title="objectFactory"></a>objectFactory</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">objectFactoryElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// type是对象工厂类的类名,默认是DefaultObjectFactory</span></span><br><span class="line">    String type = context.getStringAttribute(<span class="string">"type"</span>);</span><br><span class="line">    Properties properties = context.getChildrenAsProperties();</span><br><span class="line">    ObjectFactory factory = (ObjectFactory) resolveClass(type).newInstance();</span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    factory.setProperties(properties);</span><br><span class="line">    configuration.setObjectFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>知道了这个标签是生成对象工厂类，但是对象工厂类到底是做什么用的？</li>
<li>我们看先默认的对象工厂类DefaultObjectFactory<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultObjectFactory</span> <span class="keyword">implements</span> <span class="title">ObjectFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8855120656740914948L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(type, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; classToCreate = resolveInterface(type);</span><br><span class="line">    <span class="comment">// we know types are assignable</span></span><br><span class="line">    <span class="keyword">return</span> (T) instantiateClass(classToCreate, constructorArgTypes, constructorArgs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// no props for default</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Constructor&lt;T&gt; constructor;</span><br><span class="line">      <span class="keyword">if</span> (constructorArgTypes == <span class="keyword">null</span> || constructorArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        constructor = type.getDeclaredConstructor();</span><br><span class="line">        <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">          constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">      &#125;</span><br><span class="line">      constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]));</span><br><span class="line">      <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      StringBuilder argTypes = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">if</span> (constructorArgTypes != <span class="keyword">null</span> &amp;&amp; !constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; argType : constructorArgTypes) &#123;</span><br><span class="line">          argTypes.append(argType.getSimpleName());</span><br><span class="line">          argTypes.append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        argTypes.deleteCharAt(argTypes.length() - <span class="number">1</span>); <span class="comment">// remove trailing ,</span></span><br><span class="line">      &#125;</span><br><span class="line">      StringBuilder argValues = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">if</span> (constructorArgs != <span class="keyword">null</span> &amp;&amp; !constructorArgs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object argValue : constructorArgs) &#123;</span><br><span class="line">          argValues.append(String.valueOf(argValue));</span><br><span class="line">          argValues.append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        argValues.deleteCharAt(argValues.length() - <span class="number">1</span>); <span class="comment">// remove trailing ,</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"Error instantiating "</span> + type + <span class="string">" with invalid types ("</span> + argTypes + <span class="string">") or values ("</span> + argValues + <span class="string">"). Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt; resolveInterface(Class&lt;?&gt; type) &#123;</span><br><span class="line">    Class&lt;?&gt; classToCreate;</span><br><span class="line">    <span class="keyword">if</span> (type == List<span class="class">.<span class="keyword">class</span> || <span class="title">type</span> </span>== Collection<span class="class">.<span class="keyword">class</span> || <span class="title">type</span> </span>== Iterable<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      classToCreate = ArrayList<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Map<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      classToCreate = HashMap<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == SortedSet<span class="class">.<span class="keyword">class</span>) </span>&#123; <span class="comment">// issue #510 Collections Support</span></span><br><span class="line">      classToCreate = TreeSet<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Set<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      classToCreate = HashSet<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      classToCreate = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classToCreate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collection<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="objectWrapperFactory"><a href="#objectWrapperFactory" class="headerlink" title="objectWrapperFactory"></a>objectWrapperFactory</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">objectWrapperFactoryElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// type类的类型，实例化这个类</span></span><br><span class="line">    String type = context.getStringAttribute(<span class="string">"type"</span>);</span><br><span class="line">    ObjectWrapperFactory factory = (ObjectWrapperFactory) resolveClass(type).newInstance();</span><br><span class="line">    configuration.setObjectWrapperFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于包装Object实例。默认是DefaultObjectWrapperFactory类。</li>
</ul>
<h2 id="reflectionFactory"><a href="#reflectionFactory" class="headerlink" title="reflectionFactory"></a>reflectionFactory</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reflectionFactoryElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String type = context.getStringAttribute(<span class="string">"type"</span>);</span><br><span class="line">      ReflectorFactory factory = (ReflectorFactory) resolveClass(type).newInstance();</span><br><span class="line">      configuration.setReflectorFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReflectorFactory的默认实现：DefaultReflectorFactory。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用ConcurrentMap存储了以Class对象为key，Reflector为value.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Reflector&gt; reflectorMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Reflector&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li>也就是说ReflectorFactory是Reflector的工厂，需要哪个就从工厂里面获取。</li>
<li>下面看下Reflector的实现：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h2><p>全局设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">settingsElement</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 设置autoMappingBehavior，默认PARTIAL。有3种，NONE：表示取消自动映射；PARTIAL：只会自动映射没有定义嵌套结果集映射的结果集；FULL：会自动映射任意复杂的结果集（无论是否嵌套）。</span></span><br><span class="line">  configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty(<span class="string">"autoMappingBehavior"</span>, <span class="string">"PARTIAL"</span>)));</span><br><span class="line">  <span class="comment">// 设置自动mapping检测到未知列时的行为。默认NONE：设么也不做；WARNING:打warn日志；FAILING:抛出SqlSessionException；</span></span><br><span class="line">  configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty(<span class="string">"autoMappingUnknownColumnBehavior"</span>, <span class="string">"NONE"</span>)));</span><br><span class="line">  <span class="comment">// 设置是否缓存。默认为true.</span></span><br><span class="line">  configuration.setCacheEnabled(booleanValueOf(props.getProperty(<span class="string">"cacheEnabled"</span>), <span class="keyword">true</span>));</span><br><span class="line">  <span class="comment">// 设置proxyFactory代理工厂。默认是JavassistProxyFactory</span></span><br><span class="line">  configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty(<span class="string">"proxyFactory"</span>)));</span><br><span class="line">  <span class="comment">// 设置是否延迟加载。默认flase.</span></span><br><span class="line">  configuration.setLazyLoadingEnabled(booleanValueOf(props.getProperty(<span class="string">"lazyLoadingEnabled"</span>), <span class="keyword">false</span>));</span><br><span class="line">  <span class="comment">// 设置aggressiveLazyLoading，默认为true，即不按需加载。lazyLoadingEnabled属性启用时只要加载对象，就会加载该对象的所有属性；设置为false则会按需加载，即使用到某关联属性时，实时执行嵌套查询加载该属性。</span></span><br><span class="line">  configuration.setAggressiveLazyLoading(booleanValueOf(props.getProperty(<span class="string">"aggressiveLazyLoading"</span>), <span class="keyword">true</span>));</span><br><span class="line">  <span class="comment">// 设置multipleResultSetsEnabled，默认为true.允许/不允许一条SQL返回多个结果集.</span></span><br><span class="line">  configuration.setMultipleResultSetsEnabled(booleanValueOf(props.getProperty(<span class="string">"multipleResultSetsEnabled"</span>), <span class="keyword">true</span>));</span><br><span class="line">  <span class="comment">// 设置useColumnLabel，默认为true。列标签代替列名，即sql里的字段别名。设置成false，别名映射会不生效。</span></span><br><span class="line">  configuration.setUseColumnLabel(booleanValueOf(props.getProperty(<span class="string">"useColumnLabel"</span>), <span class="keyword">true</span>));</span><br><span class="line">  <span class="comment">// 设置useGeneratedKeys，默认false.在执行添加记录之后可以获取到数据库自动生成的主键ID。在settings元素中设置useGeneratedKeys是一个全局参数，但是只会对接口映射器产生影响，对xml映射器不起效。所以一般我们会在xml映射器中增加useGeneratedKeys。</span></span><br><span class="line">  configuration.setUseGeneratedKeys(booleanValueOf(props.getProperty(<span class="string">"useGeneratedKeys"</span>), <span class="keyword">false</span>));</span><br><span class="line">  <span class="comment">// 设置defaultExecutorType.配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</span></span><br><span class="line">  configuration.setDefaultExecutorType(ExecutorType.valueOf(props.getProperty(<span class="string">"defaultExecutorType"</span>, <span class="string">"SIMPLE"</span>)));</span><br><span class="line">  <span class="comment">// 设置defaultStatementTimeout，默认为null。</span></span><br><span class="line">  configuration.setDefaultStatementTimeout(integerValueOf(props.getProperty(<span class="string">"defaultStatementTimeout"</span>), <span class="keyword">null</span>));</span><br><span class="line">  <span class="comment">// 设置defaultFetchSize。查询每次返回的数据条数，可以在select参数中使用fetchSize覆盖，mysql不支持这个参数。</span></span><br><span class="line">  configuration.setDefaultFetchSize(integerValueOf(props.getProperty(<span class="string">"defaultFetchSize"</span>), <span class="keyword">null</span>));</span><br><span class="line">  <span class="comment">// 设置是否开启下划线转驼峰命名规则，默认false。</span></span><br><span class="line">  configuration.setMapUnderscoreToCamelCase(booleanValueOf(props.getProperty(<span class="string">"mapUnderscoreToCamelCase"</span>), <span class="keyword">false</span>));</span><br><span class="line">  <span class="comment">// 设置是否允许在嵌套语句中使用分页，默认false。</span></span><br><span class="line">  configuration.setSafeRowBoundsEnabled(booleanValueOf(props.getProperty(<span class="string">"safeRowBoundsEnabled"</span>), <span class="keyword">false</span>));</span><br><span class="line">  <span class="comment">// MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。</span></span><br><span class="line">  configuration.setLocalCacheScope(LocalCacheScope.valueOf(props.getProperty(<span class="string">"localCacheScope"</span>, <span class="string">"SESSION"</span>)));</span><br><span class="line">  <span class="comment">// 当没有为参数提供特定的 JDBC 类型时,不设置的都默认为OTHER。</span></span><br><span class="line">  configuration.setJdbcTypeForNull(JdbcType.valueOf(props.getProperty(<span class="string">"jdbcTypeForNull"</span>, <span class="string">"OTHER"</span>)));</span><br><span class="line">  <span class="comment">// 设置懒加载触发方法：equals,clone,hascode,toString</span></span><br><span class="line">  configuration.setLazyLoadTriggerMethods(stringSetValueOf(props.getProperty(<span class="string">"lazyLoadTriggerMethods"</span>), <span class="string">"equals,clone,hashCode,toString"</span>));</span><br><span class="line">  <span class="comment">// 设置resultHandler检查。</span></span><br><span class="line">  configuration.setSafeResultHandlerEnabled(booleanValueOf(props.getProperty(<span class="string">"safeResultHandlerEnabled"</span>), <span class="keyword">true</span>));</span><br><span class="line">  <span class="comment">// 指定动态SQL生成的默认语言。默认XMLLanguageDriver。</span></span><br><span class="line">  configuration.setDefaultScriptingLanguage(resolveClass(props.getProperty(<span class="string">"defaultScriptingLanguage"</span>)));</span><br><span class="line">  <span class="comment">// 指定当结果集中值为null的时候是否调用映射对象的setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。</span></span><br><span class="line">  configuration.setCallSettersOnNulls(booleanValueOf(props.getProperty(<span class="string">"callSettersOnNulls"</span>), <span class="keyword">false</span>));</span><br><span class="line">  <span class="comment">// 指定MyBatis增加到日志名称的前缀。</span></span><br><span class="line">  configuration.setLogPrefix(props.getProperty(<span class="string">"logPrefix"</span>));</span><br><span class="line">  <span class="comment">// 指定MyBatis所用日志的具体实现，未指定时将自动查找。</span></span><br><span class="line">  configuration.setLogImpl(resolveClass(props.getProperty(<span class="string">"logImpl"</span>)));</span><br><span class="line">  <span class="comment">// 设置configurationFactory。</span></span><br><span class="line">  configuration.setConfigurationFactory(resolveClass(props.getProperty(<span class="string">"configurationFactory"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h2><p>设置多个环境配置,默认环境使用default指定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">environmentsElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">      environment = context.getStringAttribute(<span class="string">"default"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : context.getChildren()) &#123;</span><br><span class="line">      String id = child.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">      <span class="keyword">if</span> (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">        TransactionFactory txFactory = transactionManagerElement(child.evalNode(<span class="string">"transactionManager"</span>));</span><br><span class="line">        DataSourceFactory dsFactory = dataSourceElement(child.evalNode(<span class="string">"dataSource"</span>));</span><br><span class="line">        DataSource dataSource = dsFactory.getDataSource();</span><br><span class="line">        Environment.Builder environmentBuilder = <span class="keyword">new</span> Environment.Builder(id)</span><br><span class="line">            .transactionFactory(txFactory)</span><br><span class="line">            .dataSource(dataSource);</span><br><span class="line">        configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="databaseIdProvider"><a href="#databaseIdProvider" class="headerlink" title="databaseIdProvider"></a>databaseIdProvider</h2><p>设置根据不同的数据库厂商执行不同的语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">databaseIdProviderElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  DatabaseIdProvider databaseIdProvider = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String type = context.getStringAttribute(<span class="string">"type"</span>);</span><br><span class="line">    <span class="comment">// awful patch to keep backward compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"VENDOR"</span>.equals(type)) &#123;</span><br><span class="line">        type = <span class="string">"DB_VENDOR"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Properties properties = context.getChildrenAsProperties();</span><br><span class="line">    databaseIdProvider = (DatabaseIdProvider) resolveClass(type).newInstance();</span><br><span class="line">    databaseIdProvider.setProperties(properties);</span><br><span class="line">  &#125;</span><br><span class="line">  Environment environment = configuration.getEnvironment();</span><br><span class="line">  <span class="keyword">if</span> (environment != <span class="keyword">null</span> &amp;&amp; databaseIdProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String databaseId = databaseIdProvider.getDatabaseId(environment.getDataSource());</span><br><span class="line">    configuration.setDatabaseId(databaseId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="typeHandlers"><a href="#typeHandlers" class="headerlink" title="typeHandlers"></a>typeHandlers</h2><p>配置一些自定义的类型处理器，查询数据库完成后，调用TypeHandler的方法读取数据转换成java对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">typeHandlerElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">        String typeHandlerPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">        typeHandlerRegistry.register(typeHandlerPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String javaTypeName = child.getStringAttribute(<span class="string">"javaType"</span>);</span><br><span class="line">        String jdbcTypeName = child.getStringAttribute(<span class="string">"jdbcType"</span>);</span><br><span class="line">        String handlerTypeName = child.getStringAttribute(<span class="string">"handler"</span>);</span><br><span class="line">        Class&lt;?&gt; javaTypeClass = resolveClass(javaTypeName);</span><br><span class="line">        JdbcType jdbcType = resolveJdbcType(jdbcTypeName);</span><br><span class="line">        Class&lt;?&gt; typeHandlerClass = resolveClass(handlerTypeName);</span><br><span class="line">        <span class="keyword">if</span> (javaTypeClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          typeHandlerRegistry.register(typeHandlerClass);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h2><p>配置xml映射，即配置在哪找到sql语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">// 包下的所有文件</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">        String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 一个一个文件配置</span></span><br><span class="line">        String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">        String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">        String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">          InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一般都用包来配置</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>properties节点首先读取子节点property属性，然后从由resource或者url标记的地方获取属性，有相同key的属性会覆盖之前读取的值。</li>
</ul>
]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis拦截器分页</title>
    <url>/2019/12/29/mybatis%E6%8B%A6%E6%88%AA%E5%99%A8%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<p>本文主要介绍mybatis拦截器分页的实现。</p>
<a id="more"></a>

<ul>
<li>分页有两种实现方式：内存分页，物理分页。<ul>
<li>内存分页，将所有数据存入内存再分页，这个做法在大数据量下性能很差，只适合在小数据量下使用；</li>
<li>物理分页，通过在sql层面实现，在sql后面加上limit 1,5 的语句来实现，但是这样每个需要分页的sql都要加上这个语句。</li>
</ul>
</li>
<li>所以最优的方法是使用拦截器拦截需要分页的sql实现物理分页，这样能够节省工作量，也能提高性能。本篇文章主要介绍mybatis的拦截器分页的实现，具体原理这里不讲。</li>
</ul>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author guchunhui</span><br><span class="line"> * 2019-12-29 13:51</span><br><span class="line"> **&#x2F;</span><br><span class="line"> &#x2F;&#x2F; 高版本得使用这个，否则会报错</span><br><span class="line">@Intercepts(&#123; @Signature(type &#x3D; StatementHandler.class, method &#x3D; &quot;prepare&quot;, args &#x3D; &#123; Connection.class, Integer.class &#125;) &#125;)</span><br><span class="line">@Component</span><br><span class="line">public class PageInterceptor implements Interceptor &#123;</span><br><span class="line">    Logger logger &#x3D; LoggerFactory.getLogger(PageInterceptor.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        StatementHandler statementHandler &#x3D; (StatementHandler)invocation.getTarget();</span><br><span class="line">        MetaObject metaObject &#x3D; MetaObject.forObject(statementHandler, SystemMetaObject.DEFAULT_OBJECT_FACTORY, SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY,new DefaultReflectorFactory());</span><br><span class="line">        MappedStatement mappedStatement &#x3D; (MappedStatement) metaObject.getValue(&quot;delegate.mappedStatement&quot;);</span><br><span class="line">        String id &#x3D; mappedStatement.getId();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;所有以ByPage结尾的dao层方法会被拦截</span><br><span class="line">        if(id.matches(&quot;.+ByPage$&quot;))&#123;</span><br><span class="line"></span><br><span class="line">            BoundSql boundSql &#x3D; statementHandler.getBoundSql();</span><br><span class="line">            PaginationParam params &#x3D; (PaginationParam)boundSql.getParameterObject();</span><br><span class="line">            int currPage &#x3D; params.getPageNum();</span><br><span class="line">            int pageSize &#x3D; params.getPageSize();</span><br><span class="line"></span><br><span class="line">            String sql &#x3D; boundSql.getSql();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 获取总数</span><br><span class="line">            String countSql &#x3D; &quot;select count(*) from (&quot; + sql + &quot;)a&quot;;</span><br><span class="line">            Connection connection &#x3D; (Connection) invocation.getArgs()[0];</span><br><span class="line">            PreparedStatement countStatement &#x3D; connection.prepareStatement(countSql);</span><br><span class="line">            ParameterHandler parameterHandler &#x3D; (ParameterHandler) metaObject.getValue(&quot;delegate.parameterHandler&quot;);</span><br><span class="line">            parameterHandler.setParameters(countStatement);</span><br><span class="line">            ResultSet rs &#x3D; countStatement.executeQuery();</span><br><span class="line">            if(rs.next())&#123;</span><br><span class="line">                params.setTotalNum(rs.getInt(1));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 生成分页语句</span><br><span class="line">            String pageSql &#x3D; sql + &quot; limit &quot; + (currPage-1) * pageSize + &quot;,&quot; + pageSize;</span><br><span class="line">            metaObject.setValue(&quot;delegate.boundSql.sql&quot;, pageSql);</span><br><span class="line">        &#125;</span><br><span class="line">        return invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object o) &#123;</span><br><span class="line">        return Plugin.wrap(o, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties properties) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PaginationParam负责分页参数和存储结果总数，你自己也可以算出总页数存入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author guchunhui</span><br><span class="line"> * 2019-12-29 14:42</span><br><span class="line"> **&#x2F;</span><br><span class="line">@Data</span><br><span class="line">public class PaginationParam extends BaseParam &#123;</span><br><span class="line">    private Integer pageNum;</span><br><span class="line">    private Integer pageSize;</span><br><span class="line">    private Integer totalNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用分页拦截器需要在你之前使用mybatis操作数据库正常的情况下增加。<br>dao层需要分页的方法只需要使用ByPage结尾就可以实现分页。</p>
</blockquote>
]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>docker命令</title>
    <url>/2019/12/25/docker%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>本文主要记录一些docker中使用到的命令。</p>
<a id="more"></a>
<h2 id="docker-search-mysql"><a href="#docker-search-mysql" class="headerlink" title="docker search mysql"></a>docker search mysql</h2><ul>
<li>搜索可用的镜像</li>
</ul>
<h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><ul>
<li>docker pull mysql:5.6<ul>
<li>拉取mysql镜像，版本是5.6</li>
<li>不加版本的话，默认是最新版本</li>
</ul>
</li>
</ul>
<h2 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h2><ul>
<li>查看本地有哪些镜像</li>
</ul>
<h2 id="docker-inspect-IMAGE-ID"><a href="#docker-inspect-IMAGE-ID" class="headerlink" title="docker inspect [IMAGE ID]"></a>docker inspect [IMAGE ID]</h2><ul>
<li>查看镜像的详情</li>
<li>如果不是自己想要的版本，可以在docker pull时指定版本号</li>
</ul>
<h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h2><ul>
<li><p>列出所有在运行的容器信息<br><img src="http://ww1.sinaimg.cn/large/dbf344a4ly1gacqxc6dxfj22iq04ytav.jpg" alt="hello"></p>
</li>
<li><p>docker ps -n 5</p>
<ul>
<li>列出最近创建的5个容器信息</li>
</ul>
</li>
<li><p>docker ps -a 显示所有符合条件的，包括未运行的</p>
</li>
<li><p>docker ps -f 根据条件过滤</p>
<ul>
<li>docker ps -f ancestor=mysql  根据镜像过滤</li>
<li>docker ps -f status=running  根据状态过滤</li>
<li>docker ps -f name=mysql 根据名称过滤</li>
<li>docker ps -f label=a 根据标签过滤</li>
<li>docker ps -f before=容器id 根据启动顺序过滤</li>
</ul>
</li>
</ul>
<h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><ul>
<li>docker run -p 3316:3306 –name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6<ul>
<li>–name：为容器指定名称</li>
<li>-p：指定端口映射，格式为（主机端口:容器端口）</li>
<li>-e：设置环境变量</li>
<li>-d：后台运行容器，并返回容器ID</li>
</ul>
</li>
</ul>
<h2 id="docker-port-容器id-别名-端口"><a href="#docker-port-容器id-别名-端口" class="headerlink" title="docker port 容器id/别名 [端口]"></a>docker port 容器id/别名 [端口]</h2><ul>
<li>查看端口绑定情况</li>
</ul>
<h2 id="docker-start-容器id"><a href="#docker-start-容器id" class="headerlink" title="docker start [容器id]"></a>docker start [容器id]</h2><ul>
<li>启动容器</li>
</ul>
<h2 id="docker-stop-容器id-别名"><a href="#docker-stop-容器id-别名" class="headerlink" title="docker stop [容器id/别名]"></a>docker stop [容器id/别名]</h2><ul>
<li>停止容器</li>
</ul>
<h2 id="docker-restart-容器id-别名"><a href="#docker-restart-容器id-别名" class="headerlink" title="docker restart [容器id/别名]"></a>docker restart [容器id/别名]</h2><ul>
<li>重启容器</li>
</ul>
<h2 id="docker-logs-容器id"><a href="#docker-logs-容器id" class="headerlink" title="docker logs [容器id]"></a>docker logs [容器id]</h2><ul>
<li>查看日志</li>
</ul>
<h2 id="docker-exec-it-容器id-别名-bin-bash"><a href="#docker-exec-it-容器id-别名-bin-bash" class="headerlink" title="docker exec -it [容器id/别名] /bin/bash"></a>docker exec -it [容器id/别名] /bin/bash</h2><ul>
<li>进入容器,使用这个命令进入容器有个好处，在exit退出时不会导致容器停止。</li>
<li>-i:交互式操作</li>
<li>-t:终端</li>
<li>输入exit退出终端</li>
</ul>
<h2 id="docker-rm-f-容器id"><a href="#docker-rm-f-容器id" class="headerlink" title="docker rm -f 容器id"></a>docker rm -f 容器id</h2><ul>
<li>删除容器</li>
</ul>
<h2 id="docker-network-ls"><a href="#docker-network-ls" class="headerlink" title="docker network ls"></a>docker network ls</h2><ul>
<li>查看网络模式</li>
<li>在你创建容器的时候，不指定–network默认是bridge。</li>
</ul>
<h2 id="docker-mysql-修改时区"><a href="#docker-mysql-修改时区" class="headerlink" title="docker mysql 修改时区"></a>docker mysql 修改时区</h2><ul>
<li>查看时区：docker exec [容器id/别名]  date  </li>
<li>进入容器：docker exec -it [容器id/别名] /bin/bash</li>
<li>找到通用时区文件夹： cd /usr/share/zoneinfo/Asia</li>
<li>复制当前文件夹下Shanghai：cp Shanghai /etc/localtime</li>
<li>重启容器：docker restart [容器id/别名]</li>
</ul>
<h2 id="使用redis的布隆过滤器插件"><a href="#使用redis的布隆过滤器插件" class="headerlink" title="使用redis的布隆过滤器插件"></a>使用redis的布隆过滤器插件</h2><ul>
<li>安装布隆过滤器：docker pull redislabs/rebloom</li>
<li>启动：docker run -p 6379:6379 –name redis-redisbloom redislabs/rebloom:latest</li>
<li>打开另一个窗口，进入启动的容器：docker exec -it redis-redisbloom bash</li>
<li>进入redis客户端：redis-cli</li>
<li>这时候便可以执行布隆过滤器的命令：<ul>
<li>增加一个值：BF.ADD newFilter foo</li>
<li>查看是否存在：BF.EXISTS newFilter foo</li>
</ul>
</li>
</ul>
<h2 id="zk"><a href="#zk" class="headerlink" title="zk"></a>zk</h2><ul>
<li>docker pull zookeeper</li>
<li>docker run –privileged=true -d –name zookeeper –publish 2181:2181 zookeeper:latest</li>
<li>进入容器,name上条命令起的是zookeeper：docker exec -it zookeeper bash</li>
<li>启动zk客户端：./bin/zkClient.sh</li>
</ul>
<h3 id="本地创建zk集群"><a href="#本地创建zk集群" class="headerlink" title="本地创建zk集群"></a>本地创建zk集群</h3><ul>
<li>先创建3个挂载目录<ul>
<li>mkdir zk-cluster</li>
<li>mkdir ./zk-cluster/node1</li>
<li>mkdir ./zk-cluster/node2</li>
<li>mkdir ./zk-cluster/node3</li>
</ul>
</li>
<li>创建自己的bridge网络<ul>
<li>docker network create –driver bridge –subnet=172.18.0.0/16 –gateway=172.18.0.1 test-net</li>
</ul>
</li>
<li>创建运行容器</li>
</ul>
<blockquote>
<p>docker run -d -p 2181:2181 –name    zookeeper_node1 –privileged –restart always –network test-net –ip 172.18.0.2 \<br>-v /Users/guchunhui/zk-cluster/node1/volumes/data:/data \<br>-v /Users/guchunhui/zk-cluster/node1/volumes/datalog:/datalog \<br>-v /Users/guchunhui/zk-cluster/node1/volumes/logs:/logs \<br>-e ZOO_MY_ID=1 \<br>-e “ZOO_SERVERS=server.1=172.18.0.2:2888:3888;2181 server.2=172.18.0.3:2888:3888;2181 server.3=172.18.0.4:2888:3888;2181” bbebb888169c</p>
</blockquote>
<blockquote>
<p>docker run -d -p 2182:2181 –name zookeeper_node2 –privileged –restart always –network test-net –ip 172.18.0.3 \<br>-v /Users/guchunhui/zk-cluster/node2/volumes/data:/data \<br>-v /Users/guchunhui/zk-cluster/node2/volumes/datalog:/datalog \<br>-v /Users/guchunhui/zk-cluster/node2/volumes/logs:/logs \<br>-e ZOO_MY_ID=2 \<br>-e “ZOO_SERVERS=server.1=172.18.0.2:2888:3888;2181 server.2=172.18.0.3:2888:3888;2181 server.3=172.18.0.4:2888:3888;2181” bbebb888169c</p>
</blockquote>
<blockquote>
<p>docker run -d -p 2183:2181 –name   zookeeper_node3 –privileged –restart always –network test-net –ip 172.18.0.4 \<br>-v /Users/guchunhui/zk-cluster/node3/volumes/data:/data \<br>-v /Users/guchunhui/zk-cluster/node3/volumes/datalog:/datalog \<br>-v /Users/guchunhui/zk-cluster/node3/volumes/logs:/logs \<br>-e ZOO_MY_ID=3 \<br>-e “ZOO_SERVERS=server.1=172.18.0.2:2888:3888;2181 server.2=172.18.0.3:2888:3888;2181 server.3=172.18.0.4:2888:3888;2181” bbebb888169c</p>
</blockquote>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>spring事务传播机制</title>
    <url>/2019/12/24/spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>本文主要介绍spring事务传播机制。</p>
<a id="more"></a>

<ul>
<li>spring事务传播机制有以下几种：<ul>
<li>REQUIRED：如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)。</li>
<li>NOT_SUPPORTED：不为这个方法开启事务，相当于没有事务。</li>
<li>REQUIRES_NEW：不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务。</li>
<li>MANDATORY：必须在一个已有的事务中执行,否则抛出异常。</li>
<li>NEVER：必须在一个没有事务的方法中执行,否则抛出异常(与Propagation.MANDATORY相反)。</li>
<li>SUPPORTS：如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务。</li>
<li>NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与REQUIRED类似的操作。</li>
</ul>
</li>
</ul>
<blockquote>
<p>假设方法a调用方法b,两个方法分别加上事务不同的传播机制。看会发生什么。</p>
</blockquote>
<h2 id="REQUIRED"><a href="#REQUIRED" class="headerlink" title="REQUIRED"></a>REQUIRED</h2><ul>
<li>两个都是REQUIRED机制，b方法发现a已经有事务了，就不再新建事务了，加入a事务。</li>
<li>a使用NOT_SUPPORTED,b使用REQUIRED,b方法发现a没有事务，会自己新建一个事务。</li>
</ul>
<h2 id="NOT-SUPPORTED"><a href="#NOT-SUPPORTED" class="headerlink" title="NOT_SUPPORTED"></a>NOT_SUPPORTED</h2><ul>
<li>这个相当于没有Spring事务，每条执行语句单独执行，单独提交。</li>
</ul>
<h2 id="REQUIRES-NEW"><a href="#REQUIRES-NEW" class="headerlink" title="REQUIRES_NEW"></a>REQUIRES_NEW</h2><ul>
<li>a使用REQUIRED，b使用REQUIRES_NEW，b会新建一个独立事务，a的事务挂起，b的事务先提交，然后a的事务执行再提交。</li>
<li>外层事务的回滚不影响REQUIRES_NEW事务的执行，即a事务回滚，b事务不会回滚，不受影响。</li>
</ul>
<h2 id="MANDATORY"><a href="#MANDATORY" class="headerlink" title="MANDATORY"></a>MANDATORY</h2><ul>
<li>a使用NOT_SUPPORTED,b使用MANDATORY，会发生错误。</li>
<li>MANDATORY必须在已有的事务中执行。</li>
</ul>
<h2 id="NEVER"><a href="#NEVER" class="headerlink" title="NEVER"></a>NEVER</h2><ul>
<li>a使用REQUIRED,b使用NEVER，即a使用事务，b使用NEVER传播机制会发生错误。</li>
<li>因为b使用了NEVER机制，必须在一个没有事务的方法中执行，否则报错。</li>
</ul>
<h2 id="SUPPORTS"><a href="#SUPPORTS" class="headerlink" title="SUPPORTS"></a>SUPPORTS</h2><ul>
<li>a使用REQUIRED，b使用SUPPORTS,b会复用a的事务。</li>
<li>a使用NOT_SUPPORTED，b使用SUPPORTS,b便不会使用事务。</li>
<li>是否使用事务取决于调用方法是否有事务，如果有则直接用，如果没有则不使用事务。</li>
</ul>
<h2 id="NESTED"><a href="#NESTED" class="headerlink" title="NESTED"></a>NESTED</h2><ul>
<li>a使用REQUIRED，b使用NESTED,b直接在a事务的基础上创建一个嵌套事务，本质上还是同一个事务，做一次提交。</li>
<li>a使用NOT_SUPPORTED，b使用NESTED，b直接创建一个新的事务，单独提交。</li>
</ul>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>工作中遇到的问题</title>
    <url>/2019/12/24/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>本文主要记录和分享一些工作中遇到的问题。</p>
<a id="more"></a>

<h1 id="spring事务传播的问题"><a href="#spring事务传播的问题" class="headerlink" title="spring事务传播的问题"></a>spring事务传播的问题</h1><blockquote>
<p>问题描述:在一个事务中查询一个之前创建的数据行为空，查mysql这个数据行是存在的。</p>
</blockquote>
<ul>
<li>经debug之后知道创建数据行的操作调用的新的类里的方法，该方法新起了一个REQUIRES_NEW事务。因为REQUIRES_NEW新建的事务是独立于当前事务的，又因为数据库默认隔离级别是可重复读，所以在当前事务查询REQUIRES_NEW新建的独立事务中新建的数据行，是看不到变化的。所以查询结果是null。</li>
<li>解决方法：需要查询的新建数据行的方法也在一个REQUIRES_NEW事务中，这样能保证查询到数据。</li>
</ul>
<blockquote>
<p>下面分别介绍下spring事务传播机制和mysql事务隔离级别</p>
</blockquote>
<h2 id="spring事务传播机制"><a href="#spring事务传播机制" class="headerlink" title="spring事务传播机制"></a>spring事务传播机制</h2><p>见<a href="/2019/12/24/spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/" title="spring事务传播机制">spring事务传播机制</a></p>
<h2 id="mysql事务隔离级别"><a href="#mysql事务隔离级别" class="headerlink" title="mysql事务隔离级别"></a>mysql事务隔离级别</h2><p>见</p>
<h1 id="java-stream-toMap报重复键问题"><a href="#java-stream-toMap报重复键问题" class="headerlink" title="java-stream-toMap报重复键问题"></a>java-stream-toMap报重复键问题</h1><ul>
<li>问题描述：java stream API的toMap方法，当遇到重复键时，会报Duplicate key错误。</li>
<li>解决方法：在toMap方法中增加一个BinaryOperator作为第三个参数，表示遇到重复键时，进行哪种操作，可以选择旧值或者新值，也可以对旧值和新值进行一些转换作为最终的值。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>java垃圾回收</title>
    <url>/2019/03/01/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>本文主要介绍java垃圾回收，包括：可回收对象判定，垃圾回收算法，垃圾回收器。</p>
<a id="more"></a>

<h1 id="可回收对象判定"><a href="#可回收对象判定" class="headerlink" title="可回收对象判定"></a>可回收对象判定</h1><h2 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h2><ul>
<li>为每个对象维护一个引用计数器，当对象被引用，计数器值就加1；引用失效时，计数器值就减1，当计数器的值为0时，此对象就是可回收对象。</li>
<li>缺点：会有循环引用问题，导致两个本来可以回收的对象回收不了。</li>
</ul>
<h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><ul>
<li>选取GC Roots,判断对象是否存在到任意GC Roots的引用链，没有则是可回收对象。</li>
<li>可作为GC Roots的有：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法区JNI引用的对象。<ul>
<li>因为这些都是当前存活对象。其他的比如被classloader加载的class对象，monitor的对象，被JVM持有的对象也可能是GC Roots对象。</li>
</ul>
</li>
<li>真正宣告一个对象死亡，至少要经过两次标记的的过程。<ul>
<li>如果对象在经过可达性分析后发现没有和GC Roots连接的路径，那它将会被第一次标记并且进行一次筛选，筛选的条件是：此对象是否有必要执行finalize方法，即对象覆盖了finalize方法或者finalize方法还没被虚拟机执行过，称为有必要执行。如果有必要执行finalize方法，那这个对象会被放入F-Queue队列中，由虚拟机自动建立的低优先级的Finalizer线程去执行。这里的执行是指挥触发这个finalize方法，但是不能保证会等待它结束。(因为如果其中一个对象的finalize方法执行缓慢，或者出现了死循环，将可能导致内存回收系统崩溃)</li>
<li>稍后GC将对F-Queue队列中的对象进行第二次标记，如果这时候对象和GC Roots有了和引用链,则这次不会被回收。</li>
</ul>
</li>
</ul>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="回收算法介绍及其优缺点"><a href="#回收算法介绍及其优缺点" class="headerlink" title="回收算法介绍及其优缺点"></a>回收算法介绍及其优缺点</h2><ul>
<li><p>标记清理算法</p>
<ul>
<li>标记完可回收对象后进行清理</li>
<li>缺点：内存碎片</li>
</ul>
</li>
<li><p>复制算法</p>
<ul>
<li>eden区和两个survrior区，默认比例为8：1，初始对象储存在eden区和其中一个survrior区中，当eden区内存满了的时候，会进行Minor GC,将存回对象放入另一个空闲survior区，如果放不下，会通过年老代进行分配担保，将对象存入年老代，如果年老代也烦不下，会进行一次Full GC.</li>
<li>缺点：在对象存活率高的情况下，效率会降低</li>
</ul>
</li>
<li><p>标记整理算法</p>
<ul>
<li>标记完可回收对象后将存活对象向一边移动，清理可回收对象，解决了标记清理的内存碎片问题</li>
<li>缺点：需要进行移动，吞吐量较低</li>
</ul>
</li>
</ul>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><h1 id="Minor-GC-和Full-GC的触发条件"><a href="#Minor-GC-和Full-GC的触发条件" class="headerlink" title="Minor GC 和Full GC的触发条件"></a>Minor GC 和Full GC的触发条件</h1><ul>
<li>Minor GC触发：<ul>
<li>在eden区没有足够空间分配时触发</li>
<li>在发生Minor GC之前，检查如果老年代最大可用连续空间 &gt; 新生代所有对象总空间或者历次晋升到老年代的对象平均大小，进行Minor GC，否则进行先进行Full GC</li>
</ul>
</li>
<li>Full GC触发：<ul>
<li>老年代最大可用连续空间 &lt; 新生代所有对象总空间或者历次晋升到老年代的对象平均大小</li>
<li>System.gc</li>
<li>方法区空间不足</li>
<li>担保失败后也会进行Full GC</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>flink-Checkpoint</title>
    <url>/2019/02/26/flink-Checkpoint/</url>
    <content><![CDATA[<p>本文主要介绍flink的checkpoint机制。</p>
<a id="more"></a>

<ul>
<li><p>Flink 容错机制的核心就是持续创建分布式数据流及其状态的一致快照。Flink的checkpoint 是通过分布式快照实现的,所以在flink中这两个词是一个意思。</p>
<ul>
<li>checkpoint用来保证任务的错误恢复。任务失败可以从最新的checkpoint恢复。</li>
<li>checkpoint机制需要一个可靠的可以回放数据的数据源(kafka,RabbitMQ,HDFS…)和一个存放state的持久存储（HDFS,S3…）。<h2 id="checkpointConfig"><a href="#checkpointConfig" class="headerlink" title="checkpointConfig"></a>checkpointConfig</h2></li>
</ul>
</li>
<li><p>通过调用StreamExecutionEnvironment.enableCheckpointing(internal，mode)启用checkpoint。 internal默认是-1，表示checkpoint不开启，mode默认是EXACTLY_ONCE模式。</p>
</li>
<li><p>可设置checkpoint timeout,超过这个时间checkpoint没有成功，checkpoint终止。默认10分钟。</p>
</li>
<li><p>可设置checkpoint失败任务是否也失败，默认是true。</p>
</li>
<li><p>可设置同时进行的checkpoint数量，默认为1。</p>
</li>
</ul>
<h2 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h2><ul>
<li>将barrier插入到数据流中，作为数据流的一部分和数据一起向下流动。Barrier 不会干扰正常数据，数据流严格有序。一个 barrier 把数据流分割成两部分：一部分进入到当前快照，另一部分进入下一个快照。每一个 barrier 都带有快照 ID，并且 barrier 之前的数据都进入了此快照。Barrier 不会干扰数据流处理，所以非常轻量。多个不同快照的多个 barrier 会在流中同时出现，即多个快照可能同时创建。</li>
<li>Barrier 在数据源端插入，当 snapshot n 的 barrier 插入后，系统会记录当前 snapshot 位置值 n (用Sn表示)。例如，在 Apache Kafka 中，这个变量表示某个分区中最后一条数据的偏移量。这个位置值 Sn 会被发送到一个称为 checkpoint coordinator 的模块。</li>
<li>然后 barrier 继续往下流动，当一个 operator 从其输入流接收到所有标识 snapshot n 的 barrier 时，它会向其所有输出流插入一个标识 snapshot n 的 barrier。当 sink operator （DAG 流的终点）从其输入流接收到所有 barrier n 时，它向 the checkpoint coordinator 确认 snapshot n 已完成。当所有 sink 都确认了这个快照，快照就被标识为完成。</li>
</ul>
<h2 id="如何触发checkpoint？"><a href="#如何触发checkpoint？" class="headerlink" title="如何触发checkpoint？"></a>如何触发checkpoint？</h2><ul>
<li>在生成EcecutionGraph过程中会注册状态监听器CheckpointCoordinatorDeActivator，负责监听job状态，job变为运行状态时，执行startCheckpointScheduler方法定时执行ScheduledTrigger，ScheduledTrigger中执行的是triggerCheckpoint方法。</li>
<li>在进行一些条件检查之后，首先会构造出一个PendingCheckpoint实例，然后再放到队列里，只有当jobmanager收到SinkTask发来的checkpoint保存成功的消息后，这个PendingCheckpoint才会变成CompletedCheckpoint，这才代表一次checkpoint保存操作真正的完成了。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> PendingCheckpoint checkpoint = </span><br><span class="line"><span class="keyword">new</span> PendingCheckpoint(</span><br><span class="line">    job,</span><br><span class="line">    checkpointID,</span><br><span class="line">    timestamp,</span><br><span class="line">    ackTasks,</span><br><span class="line">    props,</span><br><span class="line">    checkpointStorageLocation,</span><br><span class="line">    executor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (statsTracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">    PendingCheckpointStats callback = statsTracker.reportPendingCheckpoint(</span><br><span class="line">        checkpointID,</span><br><span class="line">        timestamp,</span><br><span class="line">        props);</span><br><span class="line"></span><br><span class="line">    checkpoint.setStatsCallback(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
再往下看，最重要的方法是向executions发送保存checkpoint的消息，通知taskmanager进行本地的checkpoint保存。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// send the messages to the tasks that trigger their checkpoint</span></span><br><span class="line"><span class="keyword">for</span> (Execution execution: executions) &#123;</span><br><span class="line">    execution.triggerCheckpoint(checkpointID, timestamp, checkpointOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
下面看看executions从哪来,下面这段代码在PendingCheckpoint生成之前执行：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Execution[] executions = <span class="keyword">new</span> Execution[tasksToTrigger.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasksToTrigger.length; i++) &#123;</span><br><span class="line">    Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt();</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="keyword">null</span>) &#123;</span><br><span class="line">        LOG.info(<span class="string">"Checkpoint triggering task &#123;&#125; of job &#123;&#125; is not being executed at the moment. Aborting checkpoint."</span>,</span><br><span class="line">                tasksToTrigger[i].getTaskNameWithSubtaskIndex(),</span><br><span class="line">                job);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CheckpointTriggerResult(CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ee.getState() == ExecutionState.RUNNING) &#123;</span><br><span class="line">        executions[i] = ee;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG.info(<span class="string">"Checkpoint triggering task &#123;&#125; of job &#123;&#125; is not in state &#123;&#125; but &#123;&#125; instead. Aborting checkpoint."</span>,</span><br><span class="line">                tasksToTrigger[i].getTaskNameWithSubtaskIndex(),</span><br><span class="line">                job,</span><br><span class="line">                ExecutionState.RUNNING,</span><br><span class="line">                ee.getState());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CheckpointTriggerResult(CheckpointDeclineReason.NOT_ALL_REQUIRED_TASKS_RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到execution中的元素都是从tasksToTrigger中获得，那t<br>asksToTrigger是什么呢？可以追溯到ExecutionGraph中：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutionVertex[] tasksToTrigger = collectExecutionVertices(verticesToTrigger);</span><br></pre></td></tr></table></figure>
看了下collectExecutionVertices方法，并没有说明来源，继续看verticesToTrigger从哪里来，追溯到StreamingJobGraphGenerator中：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (JobVertex vertex : jobVertices.values()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vertex.isInputVertex()) &#123;</span><br><span class="line">        triggerVertices.add(vertex.getID());</span><br><span class="line">    &#125;</span><br><span class="line">    commitVertices.add(vertex.getID());</span><br><span class="line">    ackVertices.add(vertex.getID());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInputVertex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.inputs.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
就是说triggerVertices是那些没有输入的节点，即数据源。</li>
<li>综上，配置了checkpoint，job状态监听器在监听到状态为running时，会开启定时器，定时向TaskManager发送TriggerCheckpoint消息。</li>
</ul>
<p>下面看看TaskManager收到TriggerCheckpoint消息之后如何处理<br>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> message: TriggerCheckpoint =&gt;</span><br><span class="line">    val taskExecutionId = message.getTaskExecutionId</span><br><span class="line">    val checkpointId = message.getCheckpointId</span><br><span class="line">    val timestamp = message.getTimestamp</span><br><span class="line">    val checkpointOptions = message.getCheckpointOptions</span><br><span class="line"></span><br><span class="line">    log.debug(s<span class="string">"Receiver TriggerCheckpoint $checkpointId@$timestamp for $taskExecutionId."</span>)</span><br><span class="line"></span><br><span class="line">    val task = runningTasks.get(taskExecutionId)</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        task.triggerCheckpointBarrier(checkpointId, timestamp, checkpointOptions)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.debug(s<span class="string">"TaskManager received a checkpoint request for unknown task $taskExecutionId."</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>关键在triggerCheckpointBarrier方法，方法中最核心的是这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> success = invokable.triggerCheckpoint(checkpointMetaData, checkpointOptions);</span><br></pre></td></tr></table></figure>
<p>因为之前已经知道消息是发往数据源task的，所以在所有triggerCheckpoint实现中看下SourceStreamTask的,最终追溯到StreamTask的performCheckpoint方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performCheckpoint</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        CheckpointMetaData checkpointMetaData,</span></span></span><br><span class="line"><span class="function"><span class="params">        CheckpointOptions checkpointOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">        CheckpointMetrics checkpointMetrics)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRunning) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 第一步：为checkpoint做一些准备工作，默认什么都不做</span></span><br><span class="line">            operatorChain.prepareSnapshotPreBarrier(checkpointMetaData.getCheckpointId());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二步：向下游广播发送checkpoint barrier</span></span><br><span class="line">            operatorChain.broadcastCheckpointBarrier(</span><br><span class="line">                    checkpointMetaData.getCheckpointId(),</span><br><span class="line">                    checkpointMetaData.getTimestamp(),</span><br><span class="line">                    checkpointOptions);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第三步：异步存储状态快照</span></span><br><span class="line">            checkpointState(checkpointMetaData, checkpointOptions, checkpointMetrics);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            。。。任务不是运行状态，不触发checkpoint，向下游广播取消checkpoint的消息。</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实下游每个task收到checkpoint barrier都会执行上述操作。</p>
<ul>
<li>异步储存快照</li>
</ul>
<p>进入checkpointState方法，追溯至executeCheckpointing方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCheckpointing</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        startSyncPartNano = System.nanoTime();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (StreamOperator&lt;?&gt; op : allOperators) &#123;</span><br><span class="line">                checkpointStreamOperator(op);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startAsyncPartNano = System.nanoTime();</span><br><span class="line"></span><br><span class="line">            checkpointMetrics.setSyncDurationMillis((startAsyncPartNano - startSyncPartNano) / <span class="number">1_000_000</span>);</span><br><span class="line"></span><br><span class="line">            AsyncCheckpointRunnable asyncCheckpointRunnable = <span class="keyword">new</span> AsyncCheckpointRunnable(</span><br><span class="line">                owner,</span><br><span class="line">                operatorSnapshotsInProgress,</span><br><span class="line">                checkpointMetaData,</span><br><span class="line">                checkpointMetrics,</span><br><span class="line">                startAsyncPartNano);</span><br><span class="line"></span><br><span class="line">            owner.cancelables.registerCloseable(asyncCheckpointRunnable);</span><br><span class="line">            owner.asyncOperationsThreadPool.submit(asyncCheckpointRunnable);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对task中所有operator执行checkpointStreamOperator方法，这个方法是opertor存储快照的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkpointStreamOperator</span><span class="params">(StreamOperator&lt;?&gt; op)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> != op) &#123;</span><br><span class="line">				OperatorSnapshotFutures snapshotInProgress = op.snapshotState(</span><br><span class="line">						checkpointMetaData.getCheckpointId(),</span><br><span class="line">						checkpointMetaData.getTimestamp(),</span><br><span class="line">						checkpointOptions,</span><br><span class="line">						storageLocation);</span><br><span class="line">				operatorSnapshotsInProgress.put(op.getOperatorID(), snapshotInProgress);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接着看snapshotState方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> OperatorSnapshotFutures <span class="title">snapshotState</span><span class="params">(<span class="keyword">long</span> checkpointId, <span class="keyword">long</span> timestamp, CheckpointOptions checkpointOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">			CheckpointStreamFactory factory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    KeyGroupRange keyGroupRange = <span class="keyword">null</span> != keyedStateBackend ?</span><br><span class="line">            keyedStateBackend.getKeyGroupRange() : KeyGroupRange.EMPTY_KEY_GROUP_RANGE;</span><br><span class="line"></span><br><span class="line">    OperatorSnapshotFutures snapshotInProgress = <span class="keyword">new</span> OperatorSnapshotFutures();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (StateSnapshotContextSynchronousImpl snapshotContext = <span class="keyword">new</span> StateSnapshotContextSynchronousImpl(</span><br><span class="line">            checkpointId,</span><br><span class="line">            timestamp,</span><br><span class="line">            factory,</span><br><span class="line">            keyGroupRange,</span><br><span class="line">            getContainingTask().getCancelables())) &#123;</span><br><span class="line"></span><br><span class="line">        snapshotState(snapshotContext);</span><br><span class="line">        </span><br><span class="line">        snapshotInProgress.setKeyedStateRawFuture(snapshotContext.getKeyedStateStreamFuture());</span><br><span class="line">        snapshotInProgress.setOperatorStateRawFuture(snapshotContext.getOperatorStateStreamFuture());</span><br><span class="line">        <span class="comment">//这里调用operator的snapshot异步方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != operatorStateBackend) &#123;</span><br><span class="line">            snapshotInProgress.setOperatorStateManagedFuture(</span><br><span class="line">                operatorStateBackend.snapshot(checkpointId, timestamp, factory, checkpointOptions));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != keyedStateBackend) &#123;</span><br><span class="line">            snapshotInProgress.setKeyedStateManagedFuture(</span><br><span class="line">                keyedStateBackend.snapshot(checkpointId, timestamp, factory, checkpointOptions));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> snapshotInProgress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>operatorStateBackend是保存状态的介质，Flink中提供了三种不同的存储介质:heap，hdfs，rockdb。将Future加入到snapshotInProgress中，全部完成后执行AsyncCheckpointRunnable。</p>
</li>
<li><p>AsyncCheckpointRunnable线程的run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileSystemSafetyNet.initializeSafetyNetForThread();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        TaskStateSnapshot jobManagerTaskOperatorSubtaskStates =</span><br><span class="line">            <span class="keyword">new</span> TaskStateSnapshot(operatorSnapshotsInProgress.size());</span><br><span class="line"></span><br><span class="line">        TaskStateSnapshot localTaskOperatorSubtaskStates =</span><br><span class="line">            <span class="keyword">new</span> TaskStateSnapshot(operatorSnapshotsInProgress.size());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;OperatorID, OperatorSnapshotFutures&gt; entry : operatorSnapshotsInProgress.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">            OperatorID operatorID = entry.getKey();</span><br><span class="line">            OperatorSnapshotFutures snapshotInProgress = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// finalize the async part of all by executing all snapshot runnables</span></span><br><span class="line">            OperatorSnapshotFinalizer finalizedSnapshots =</span><br><span class="line">                <span class="keyword">new</span> OperatorSnapshotFinalizer(snapshotInProgress);</span><br><span class="line"></span><br><span class="line">            jobManagerTaskOperatorSubtaskStates.putSubtaskStateByOperatorID(</span><br><span class="line">                operatorID,</span><br><span class="line">                finalizedSnapshots.getJobManagerOwnedState());</span><br><span class="line"></span><br><span class="line">            localTaskOperatorSubtaskStates.putSubtaskStateByOperatorID(</span><br><span class="line">                operatorID,</span><br><span class="line">                finalizedSnapshots.getTaskLocalState());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> asyncEndNanos = System.nanoTime();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> asyncDurationMillis = (asyncEndNanos - asyncStartNanos) / <span class="number">1_000_000L</span>;</span><br><span class="line">        <span class="comment">// checkpoint 完成时间</span></span><br><span class="line">        checkpointMetrics.setAsyncDurationMillis(asyncDurationMillis);</span><br><span class="line">        <span class="comment">// checkpoint完成后，通知jobmanager checkpoint完成</span></span><br><span class="line">        <span class="keyword">if</span> (asyncCheckpointState.compareAndSet(CheckpointingOperation.AsyncCheckpointState.RUNNING,</span><br><span class="line">            CheckpointingOperation.AsyncCheckpointState.COMPLETED)) &#123;</span><br><span class="line">            reportCompletedSnapshotStates(</span><br><span class="line">                jobManagerTaskOperatorSubtaskStates,</span><br><span class="line">                localTaskOperatorSubtaskStates,</span><br><span class="line">                asyncDurationMillis);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>reportCompletedSnapshotStates方法，在存储完state之后会通过CheckpointResponder发送消息给jobmanager告知checkpoint完成。jobmanager在所有task都通知了同一个id的checkpoint完成之后才会算这个checkpoint完成。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>flink-jobmanager处理SubmitJob消息</title>
    <url>/2019/02/25/flink-jobmanager%E5%A4%84%E7%90%86SubmitJob%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<p>本文主要介绍Jobmanager如何处理SubmitJob。</p>
<a id="more"></a>

<h2 id="Jobmanager处理SubmitJob"><a href="#Jobmanager处理SubmitJob" class="headerlink" title="Jobmanager处理SubmitJob"></a>Jobmanager处理SubmitJob</h2><p>先将submitJob的主要步骤总结写在开头，然后一步步分析。</p>
<ul>
<li>1，通过JobGraph生成ExecutionGraph;</li>
<li>2，恢复状态CheckpointedState，或者Savepoint;</li>
<li>3，提交Execution给Scheduler进行调度；<ul>
<li>3.1 获取ExecutionGraph中所有vertice，并为其分配slot资源;</li>
<li>3.2 通知TaskManager，将每个vertice部署在分配好的资源中。<br>下面一步一步分析：</li>
</ul>
</li>
</ul>
<h3 id="通过JobGraph生成ExecutionGraph"><a href="#通过JobGraph生成ExecutionGraph" class="headerlink" title="通过JobGraph生成ExecutionGraph"></a><strong>通过JobGraph生成ExecutionGraph</strong></h3><ul>
<li>jobManager接收到SubmitJob消息后，生成了一个jobInfo对象装载job信息，然后调用submitJob方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">case</span> <span class="title">SubmitJob</span><span class="params">(jobGraph, listeningBehaviour)</span> </span>=&gt;</span><br><span class="line">      val client = sender()</span><br><span class="line">      val jobInfo = <span class="keyword">new</span> JobInfo(client, listeningBehaviour, System.currentTimeMillis(),</span><br><span class="line">        jobGraph.getSessionTimeout)</span><br><span class="line">      submitJob(jobGraph, jobInfo)</span><br></pre></td></tr></table></figure>

<ul>
<li>深入submitJob方法，首先判断jobGraph是否为空，如果为空，返回JobResultFailure消息；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (jobGraph == <span class="keyword">null</span>) &#123;</span><br><span class="line">      jobInfo.notifyClients(</span><br><span class="line">        decorateMessage(JobResultFailure(</span><br><span class="line">          <span class="keyword">new</span> SerializedThrowable(</span><br><span class="line">            <span class="keyword">new</span> JobSubmissionException(<span class="keyword">null</span>, <span class="string">"JobGraph must not be null."</span>)))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接着向类库缓存管理器注册该Job相关的库文件、类路径；必须确保该步骤在第一步执行，因为后续产生任何异常可以确保上传的类库和Jar等成功从类库缓存管理器移除。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">libraryCacheManager.registerJob(</span><br><span class="line">            jobGraph.getJobID, jobGraph.getUserJarBlobKeys, jobGraph.getClasspaths)</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来是获得用户代码的类加载器classLoader以及发生失败时的重启策略restartStrategy；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val userCodeLoader = libraryCacheManager.getClassLoader(jobGraph.getJobID)</span><br><span class="line">...</span><br><span class="line">val restartStrategy =</span><br><span class="line">    Option(jobGraph.getSerializedExecutionConfig()</span><br><span class="line">        .deserializeValue(userCodeLoader)</span><br><span class="line">        .getRestartStrategy())</span><br><span class="line">        .map(RestartStrategyFactory.createRestartStrategy)</span><br><span class="line">        .filter(p =&gt; p != <span class="keyword">null</span>) match &#123;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(strategy)</span> </span>=&gt; strategy</span><br><span class="line">        <span class="keyword">case</span> None =&gt; restartStrategyFactory.createRestartStrategy()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接着，获取ExecutionGraph对象的实例。首先尝试从缓存中查找，如果缓存中存在则直接返回，否则直接创建然后加入缓存；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val registerNewGraph = currentJobs.get(jobGraph.getJobID) match &#123;</span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">((graph, currentJobInfo)</span>) </span>=&gt;</span><br><span class="line">    	executionGraph = graph</span><br><span class="line">    	currentJobInfo.setLastActive()</span><br><span class="line">    	<span class="keyword">false</span></span><br><span class="line">    <span class="keyword">case</span> None =&gt;</span><br><span class="line">    	<span class="keyword">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val allocationTimeout: Long = flinkConfiguration.getLong(</span><br><span class="line">	JobManagerOptions.SLOT_REQUEST_TIMEOUT)</span><br><span class="line"></span><br><span class="line">val resultPartitionLocationTrackerProxy: ResultPartitionLocationTrackerProxy =</span><br><span class="line">	<span class="keyword">new</span> ResultPartitionLocationTrackerProxy(flinkConfiguration)</span><br><span class="line"></span><br><span class="line">executionGraph = ExecutionGraphBuilder.buildGraph(</span><br><span class="line">    executionGraph,</span><br><span class="line">    jobGraph,</span><br><span class="line">    flinkConfiguration,</span><br><span class="line">    futureExecutor,</span><br><span class="line">    ioExecutor,</span><br><span class="line">    scheduler,</span><br><span class="line">    userCodeLoader,</span><br><span class="line">    checkpointRecoveryFactory,</span><br><span class="line">    Time.of(timeout.length, timeout.unit),</span><br><span class="line">    restartStrategy,</span><br><span class="line">    jobMetrics,</span><br><span class="line">    numSlots,</span><br><span class="line">    blobServer,</span><br><span class="line">    resultPartitionLocationTrackerProxy,</span><br><span class="line">    Time.milliseconds(allocationTimeout),</span><br><span class="line">    log.logger)</span><br><span class="line">...</span><br><span class="line"><span class="comment">//加入缓存</span></span><br><span class="line"><span class="keyword">if</span> (registerNewGraph) &#123;</span><br><span class="line">   currentJobs.put(jobGraph.getJobID, (executionGraph, jobInfo))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接着根据配置生成带有graphManagerPlugin的graphManager（<strong>后面需要用到这个</strong>），和operationLogManager；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val conf = <span class="keyword">new</span> Configuration(jobGraph.getJobConfiguration)</span><br><span class="line">conf.addAll(jobGraph.getSchedulingConfiguration)</span><br><span class="line">val graphManagerPlugin = GraphManagerPluginFactory.createGraphManagerPlugin(</span><br><span class="line">	jobGraph.getSchedulingConfiguration, userCodeLoader)</span><br><span class="line">val operationLogManager = <span class="keyword">new</span> OperationLogManager(</span><br><span class="line">	OperationLogStoreLoader.loadOperationLogStore(jobGraph.getJobID(), conf))</span><br><span class="line">val graphManager =</span><br><span class="line">	<span class="keyword">new</span> GraphManager(graphManagerPlugin, <span class="keyword">null</span>, operationLogManager, executionGraph)</span><br><span class="line">graphManager.open(jobGraph, <span class="keyword">new</span> SchedulingConfig(conf, userCodeLoader))</span><br><span class="line">executionGraph.setGraphManager(graphManager)</span><br><span class="line">operationLogManager.start()</span><br></pre></td></tr></table></figure>

<ul>
<li>注册Job状态变化的事件回调给jobmanager自己;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">executionGraph.registerJobStatusListener(</span><br><span class="line">          <span class="keyword">new</span> StatusListenerMessenger(self, leaderSessionID.orNull))</span><br></pre></td></tr></table></figure>

<ul>
<li>注册整个job状态变化事件回调和单个task状态变化回调给client；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jobInfo.clients foreach &#123;</span><br><span class="line">    <span class="comment">// the sender wants to be notified about state changes</span></span><br><span class="line">    <span class="keyword">case</span> (client, ListeningBehaviour.EXECUTION_RESULT_AND_STATE_CHANGES) =&gt;</span><br><span class="line">    	val listener  = <span class="keyword">new</span> StatusListenerMessenger(client, leaderSessionID.orNull)</span><br><span class="line">    	executionGraph.registerExecutionListener(listener)</span><br><span class="line">    	executionGraph.registerJobStatusListener(listener)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成executionGraph细节在另一个文章中分析，获取executionGraph之后，如何提交job？继续看；</li>
</ul>
<h3 id="恢复状态CheckpointedState，或者Savepoint"><a href="#恢复状态CheckpointedState，或者Savepoint" class="headerlink" title="恢复状态CheckpointedState，或者Savepoint"></a><strong>恢复状态CheckpointedState，或者Savepoint</strong></h3><ul>
<li>如果是恢复的job，从最新的checkpoint中恢复；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRecovery) &#123;</span><br><span class="line">    <span class="comment">// this is a recovery of a master failure (this master takes over)</span></span><br><span class="line">    executionGraph.restoreLatestCheckpointedState(<span class="keyword">false</span>, <span class="keyword">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>或者获取savepoint配置，如果配置了savepoint，便从savepoint中恢复；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val savepointSettings = jobGraph.getSavepointRestoreSettings</span><br><span class="line"><span class="keyword">if</span> (savepointSettings.restoreSavepoint()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        val savepointPath = savepointSettings.getRestorePath()</span><br><span class="line">        val allowNonRestored = savepointSettings.allowNonRestoredState()</span><br><span class="line">        val resumeFromLatestCheckpoint = savepointSettings.resumeFromLatestCheckpoint()</span><br><span class="line"></span><br><span class="line">        executionGraph.getCheckpointCoordinator.restoreSavepoint(</span><br><span class="line">            savepointPath,</span><br><span class="line">            allowNonRestored,</span><br><span class="line">            resumeFromLatestCheckpoint,</span><br><span class="line">            executionGraph.getAllVertices,</span><br><span class="line">            executionGraph.getUserClassLoader</span><br><span class="line">        )</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后通知client任务提交成功消息，至此job提交成功，但是job还没启动，继续看；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jobInfo.notifyClients(</span><br><span class="line">	decorateMessage(JobSubmitSuccess(jobGraph.getJobID)))</span><br></pre></td></tr></table></figure>

<h3 id="提交Execution给Scheduler进行调度"><a href="#提交Execution给Scheduler进行调度" class="headerlink" title="提交Execution给Scheduler进行调度"></a><strong>提交Execution给Scheduler进行调度</strong></h3><h4 id="获取ExecutionGraph中所有vertice，并为其分配slot资源"><a href="#获取ExecutionGraph中所有vertice，并为其分配slot资源" class="headerlink" title="获取ExecutionGraph中所有vertice，并为其分配slot资源"></a><strong>获取ExecutionGraph中所有vertice，并为其分配slot资源</strong></h4><ul>
<li>先判断jobmanager是否是leader,如果是leader,执行scheduleForExecution方法进行调度；否则删除job。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (leaderSessionID.isDefined &amp;&amp;</span><br><span class="line">    leaderElectionService.hasLeadership(leaderSessionID.get)) &#123;</span><br><span class="line">    executionGraph.scheduleForExecution()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	self ! decorateMessage(RemoveJob(jobId, removeJobFromStateBackend = <span class="keyword">false</span>))</span><br><span class="line">	log.warn(s<span class="string">"Submitted job $jobId, but not leader. The other leader needs to recover "</span> +</span><br><span class="line">	<span class="string">"this. I am not scheduling the job for execution."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接着看下scheduleForExecution是如何调度的。</li>
<li>如果状态成功从created转变成running,则调用GraphManager开始调度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) &#123;</span><br><span class="line">	graphManager.startScheduling();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>GraphManager内部其实是使用了graphManagerPlugin的onSchedulingStarted方法；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScheduling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	graphManagerPlugin.onSchedulingStarted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>flink实现了三种GraphManagerPlugin：EagerSchedulingPlugin，RunningUnitGraphManagerPlugin，StepwiseSchedulingPlugin。</strong></p>
<ul>
<li>EagerSchedulingPlugin，调度开始后，启动所有顶点；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSchedulingStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> List&lt;ExecutionVertexID&gt; verticesToSchedule = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (JobVertex vertex : jobGraph.getVerticesSortedTopologicallyFromSources()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.getParallelism(); i++) &#123;</span><br><span class="line">			verticesToSchedule.add(<span class="keyword">new</span> ExecutionVertexID(vertex.getID(), i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	scheduler.scheduleExecutionVertices(verticesToSchedule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RunningUnitGraphManagerPlugin，根据runningUnit安排作业；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSchedulingStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	runningUnitMap.values().stream()</span><br><span class="line">    	.filter(LogicalJobVertexRunningUnit::allDependReady)</span><br><span class="line">        .forEach(<span class="keyword">this</span>::addToScheduleQueue);</span><br><span class="line">    checkScheduleNewRunningUnit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>StepwiseSchedulingPlugin，首先启动源顶点，并根据其可消耗输入启动下游顶点；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSchedulingStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> List&lt;ExecutionVertexID&gt; verticesToSchedule = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (JobVertex vertex : jobGraph.getVerticesSortedTopologicallyFromSources()) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (vertex.isInputVertex()) &#123;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.getParallelism(); i++) &#123;</span><br><span class="line">    			verticesToSchedule.add(<span class="keyword">new</span> ExecutionVertexID(vertex.getID(), i));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scheduleOneByOne(verticesToSchedule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面三种plugin不同是调度vertice的顺序，但是vertice调度方法是一样的，最终都是调用ExecutionGraphVertexScheduler的scheduleExecutionVertices方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutionGraphVertexScheduler</span> <span class="keyword">implements</span> <span class="title">VertexScheduler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleExecutionVertices</span><span class="params">(Collection&lt;ExecutionVertexID&gt; 			         verticesToSchedule)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (executionVerticesToBeScheduled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isReconciling) &#123;</span><br><span class="line">                executionVerticesToBeScheduled.add(verticesToSchedule);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        executionGraph.scheduleVertices(verticesToSchedule);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>继续深入scheduleVertices方法，该方法是在调度之前检查vertice健康状态，如果都没问题，则调用schedule(vertices)方法；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVertices</span><span class="params">(Collection&lt;ExecutionVertexID&gt; verticesToSchedule)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		。。。</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> CompletableFuture&lt;Void&gt; schedulingFuture = schedule(vertices);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (state == JobStatus.RUNNING &amp;&amp; currentGlobalModVersion == globalModVersion) &#123;</span><br><span class="line">			schedulingFutures.put(schedulingFuture, schedulingFuture);</span><br><span class="line">			schedulingFuture.whenCompleteAsync(</span><br><span class="line">					(Void ignored, Throwable throwable) -&gt; &#123;</span><br><span class="line">						schedulingFutures.remove(schedulingFuture);</span><br><span class="line">					&#125;,</span><br><span class="line">					futureExecutor);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			schedulingFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">		。。。</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>深入schedule(vertices)方法，这是真正调度vertices的方法,看看具体做了什么。</p>
<ul>
<li>为每个vertice准备调度的资源：ScheduledUnit，SlotProfile</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">checkState(state == JobStatus.RUNNING, <span class="string">"job is not running currently"</span>);</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">boolean</span> queued = allowQueuedScheduling;</span><br><span class="line">		List&lt;SlotRequestId&gt; slotRequestIds = <span class="keyword">new</span> ArrayList&lt;&gt;(vertices.size());</span><br><span class="line">		List&lt;ScheduledUnit&gt; scheduledUnits = <span class="keyword">new</span> ArrayList&lt;&gt;(vertices.size());</span><br><span class="line">		List&lt;SlotProfile&gt; slotProfiles = <span class="keyword">new</span> ArrayList&lt;&gt;(vertices.size());</span><br><span class="line">		List&lt;Execution&gt; scheduledExecutions = <span class="keyword">new</span> ArrayList&lt;&gt;(vertices.size());</span><br><span class="line">        <span class="comment">//为每个vertice准备调度的资源</span></span><br><span class="line">		<span class="keyword">for</span> (ExecutionVertex ev : vertices) &#123;</span><br><span class="line">			<span class="keyword">final</span> Execution exec = ev.getCurrentExecutionAttempt();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Tuple2&lt;ScheduledUnit, SlotProfile&gt; scheduleUnitAndSlotProfile = exec.enterScheduledAndPrepareSchedulingResources();</span><br><span class="line">				slotRequestIds.add(<span class="keyword">new</span> SlotRequestId());</span><br><span class="line">				scheduledUnits.add(scheduleUnitAndSlotProfile.f0);</span><br><span class="line">				slotProfiles.add(scheduleUnitAndSlotProfile.f1);</span><br><span class="line">				scheduledExecutions.add(exec);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IllegalExecutionStateException e) &#123;</span><br><span class="line">				LOG.info(<span class="string">"The execution &#123;&#125; may be already scheduled by other thread."</span>, ev.getTaskNameWithSubtaskIndex(), e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分配slot</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;CompletableFuture&lt;LogicalSlot&gt;&gt; allocationFutures =</span><br><span class="line">				slotProvider.allocateSlots(slotRequestIds, scheduledUnits, queued, slotProfiles, allocationTimeout);</span><br><span class="line">		List&lt;CompletableFuture&lt;Void&gt;&gt; assignFutures = <span class="keyword">new</span> ArrayList&lt;&gt;(slotRequestIds.size());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allocationFutures.size(); i++) &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">			allocationFutures.get(i).whenComplete(</span><br><span class="line">					(ignore, throwable) -&gt; &#123;</span><br><span class="line">						<span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">							slotProvider.cancelSlotRequest(</span><br><span class="line">									slotRequestIds.get(index),</span><br><span class="line">									scheduledUnits.get(index).getSlotSharingGroupId(),</span><br><span class="line">									scheduledUnits.get(index).getCoLocationConstraint(),</span><br><span class="line">									throwable);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">			);</span><br><span class="line">			assignFutures.add(allocationFutures.get(i).thenAccept(</span><br><span class="line">					(LogicalSlot logicalSlot) -&gt; &#123;</span><br><span class="line">						<span class="keyword">if</span> </span><br><span class="line">						<span class="comment">//</span></span><br><span class="line">						(!scheduledExecutions.get(index).tryAssignResource(logicalSlot)) &#123;</span><br><span class="line">							<span class="comment">// release the slot</span></span><br><span class="line">							Exception e = <span class="keyword">new</span> FlinkException(<span class="string">"Could not assign logical slot to execution "</span> + scheduledExecutions.get(index) + <span class="string">'.'</span>);</span><br><span class="line">							logicalSlot.releaseSlot(e);</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> CompletionException(e);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;)</span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所有的slot分配完成才算完成，有一个失败便算失败。所有slot分配成功之后，异步执行所有Exceution的deploy方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; currentSchedulingFuture = allAssignFutures</span><br><span class="line">    .异常处理</span><br><span class="line">    .handleAsync(</span><br><span class="line">    (Collection&lt;Void&gt; ignored, Throwable throwable) -&gt; &#123;</span><br><span class="line">    	<span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">throw</span> <span class="keyword">new</span> CompletionException(throwable);</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="keyword">boolean</span> hasFailure = <span class="keyword">false</span>;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  scheduledExecutions.size(); i++) &#123;</span><br><span class="line">    			<span class="keyword">try</span> &#123;</span><br><span class="line">    				scheduledExecutions.get(i).deploy();</span><br><span class="line">    			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    				hasFailure = <span class="keyword">true</span>;</span><br><span class="line">    				scheduledExecutions.get(i).markFailed(e);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">if</span> (hasFailure) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CompletionException(</span><br><span class="line">            <span class="keyword">new</span> FlinkException(<span class="string">"Fail to deploy some executions."</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, futureExecutor);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="通知TaskManager，将每个vertice部署在分配好的资源中"><a href="#通知TaskManager，将每个vertice部署在分配好的资源中" class="headerlink" title="通知TaskManager，将每个vertice部署在分配好的资源中"></a><strong>通知TaskManager，将每个vertice部署在分配好的资源中</strong></h4><p>下面深入deploy方法，deploy负责将Execution部署到先前分配好的资源上，提交task到taskManagerGateway，然后由taskManagerGateway转发给Taskmanager。TaskManager如何处理SubmitTask消息之后分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploy</span><span class="params">()</span> <span class="keyword">throws</span> JobException </span>&#123;</span><br><span class="line">	...一系列检查保证slot可用</span><br><span class="line">	executor.execute(</span><br><span class="line">		() -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">final</span> TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(</span><br><span class="line">						attemptId,</span><br><span class="line">						slot,</span><br><span class="line">						taskRestore,</span><br><span class="line">						attemptNumber);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// null taskRestore to let it be GC'ed</span></span><br><span class="line">				taskRestore = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">final</span> TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway();</span><br><span class="line">				<span class="comment">//提交task到taskManagerGateway，然后由taskManagerGateway转发给Taskmanager</span></span><br><span class="line">				<span class="keyword">final</span> CompletableFuture&lt;Acknowledge&gt; submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout);</span><br><span class="line"></span><br><span class="line">				...</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">				markFailed(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发-volatile</title>
    <url>/2018/07/29/java%E5%B9%B6%E5%8F%91-volatile/</url>
    <content><![CDATA[<p>volatile关键字能够保证变量的可见性，这就先要了解Java内存模型，Java内存模型是所有线程有一个共享的主内存，每个线程都有自己的工作内存，工作内存里都会保存一份共享变量的副本，</p>
<a id="more"></a>
<p>对变量修改都是修改本线程的变量副本，然后刷新到主内存，但是刷新的时间是不确定的。volatile修饰了变量之后，每个线程修改变量副本之后都会立即刷新到主内存，读取这个变量也会强制从主内存读取最新值。所以volatile保证了变量的可见性。</p>
<h2 id="在什么场景下能够使用volatile保证线程安全"><a href="#在什么场景下能够使用volatile保证线程安全" class="headerlink" title="在什么场景下能够使用volatile保证线程安全"></a>在什么场景下能够使用volatile保证线程安全</h2><ul>
<li>因为volatile能够保证可见性，有序性，不能保证原子性，所以在保证原子性的场景下使用volatile能实现线程安全。符合下面两条规则的场景：<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
</li>
<li>否则要使用synchronized，Lock，原子类来保证原子性。因为锁保证了原子性，可见性，有序性，所以是线程安全的。</li>
</ul>
<h2 id="虚拟机层面如何保证立即可见"><a href="#虚拟机层面如何保证立即可见" class="headerlink" title="虚拟机层面如何保证立即可见"></a>虚拟机层面如何保证立即可见</h2><blockquote>
<p>对volatile修饰的变量赋值后，多执行了一个带lock前缀的空操作，这个操作相当于一个内存屏障，内存屏障能够在多个CPU访问同一块内存时保证一致性。lock前缀的作用是使得本CPU的Cache写入了内存，该写入动作也会引起别的CPU或者别的内核无效化其Cache,这种操作相当于对Cache中的变量做了一次“store”“write”操作，将变量从工作内存同步回主内存，所以通过这样一个空操作，可以让volatile变量的修改对其他CPU立即可见。</p>
</blockquote>
<h2 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h2><ul>
<li>volatile本身具有禁止指令重排序语义，因为指令重排序无法越过内存屏障。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>浅复制和深复制</title>
    <url>/2017/08/27/%E6%B5%85%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B7%B1%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>本文主要介绍浅复制和深复制的区别。</p>
<a id="more"></a>

<h1 id="浅复制和深复制"><a href="#浅复制和深复制" class="headerlink" title="浅复制和深复制"></a>浅复制和深复制</h1><ul>
<li><p>浅复制：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。 </p>
</li>
<li><p>深复制：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制一遍。</p>
</li>
</ul>
<h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Professor</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Professor(String name,<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Professor p;</span><br><span class="line">    Student(String name,<span class="keyword">int</span> age,Professor p) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">        <span class="keyword">this</span>.p=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student o=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            o=(Student)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Professor p=<span class="keyword">new</span> Professor(<span class="string">"wangwu"</span>,<span class="number">50</span>);</span><br><span class="line">        Student s1=<span class="keyword">new</span> Student(<span class="string">"zhangsan"</span>,<span class="number">18</span>,p);</span><br><span class="line">        Student s2=(Student)s1.clone();</span><br><span class="line">        s2.p.name=<span class="string">"lisi"</span>;</span><br><span class="line">        s2.p.age=<span class="number">30</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"name="</span>+s1.p.name+<span class="string">","</span>+<span class="string">"age="</span>+s1.p.age);</span><br><span class="line">        System.out.println(<span class="string">"name="</span>+s2.p.name+<span class="string">","</span>+<span class="string">"age="</span>+s2.p.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果是：<br>name=lisi,age=30<br>name=lisi,age=30</p>
</blockquote>
<ul>
<li>所以浅复制，同一个引用指向的是同一个对象，互相影响。</li>
</ul>
<h2 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Professor</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Professor(String name,<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不一样的地方</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object o=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            o=<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Professor p;</span><br><span class="line">    Student(String name,<span class="keyword">int</span> age,Professor p) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">        <span class="keyword">this</span>.p=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student o=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            o=(Student)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对引用的对象也进行复制,深复制</span></span><br><span class="line">        o.p=(Professor)p.clone();</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Professor p=<span class="keyword">new</span> Professor(<span class="string">"wangwu"</span>,<span class="number">50</span>);</span><br><span class="line">        Student s1=<span class="keyword">new</span> Student(<span class="string">"zhangsan"</span>,<span class="number">18</span>,p);</span><br><span class="line">        Student s2=(Student)s1.clone();</span><br><span class="line">        s2.p.name=<span class="string">"lisi"</span>;</span><br><span class="line">        s2.p.age=<span class="number">30</span>;</span><br><span class="line">        <span class="comment">//学生1的教授不改变。</span></span><br><span class="line">        System.out.println(<span class="string">"name="</span>+s1.p.name+<span class="string">","</span>+<span class="string">"age="</span>+s1.p.age);</span><br><span class="line">        System.out.println(<span class="string">"name="</span>+s2.p.name+<span class="string">","</span>+<span class="string">"age="</span>+s2.p.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果：<br>name=wangwu,age=50<br>name=lisi,age=30</p>
</blockquote>
<ul>
<li>所以深复制，改变其中一个对象，另一个对象不受影响。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程</title>
    <url>/2017/06/16/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>本文主要从线程的产生，状态，同步，通信，安全等方面介绍java中的多线程。</p>
<a id="more"></a>

<blockquote>
<p>首先先弄清两个概念:并发和并行。</p>
<ul>
<li>并行指两个及多个事件实际意义的同时进行。</li>
<li>并发是宏观上的并行，其实一个cpu上还是顺序执行，只是cpu通过调度算法快速的切换不同事件执行,达到看似多个事件同时进行的效果。并发是为了提高效率接近并行的执行效果。而实现并发的手段是多进程或多线程。</li>
</ul>
</blockquote>
<h1 id="线程产生"><a href="#线程产生" class="headerlink" title="线程产生"></a>线程产生</h1><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">       MyThread t1 =<span class="keyword">new</span> MyThread();</span><br><span class="line">       t2.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><ul>
<li>也是使用Thread来执行这个任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        MyRunnable r = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r); t1.start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">//TODO </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h2><ul>
<li>任务完成后可返回结果，但前两种方法不行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    MyCallable c = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    <span class="comment">//FutureTask类既实现了Runnable接口,也实现了Future&lt;V&gt;接口</span></span><br><span class="line">    FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(c); </span><br><span class="line">    <span class="keyword">new</span> Thread(result).start();  <span class="comment">//启动线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Integer sum = result.get();</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后会详细介绍Callable,Future,FutureTask</p>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><ul>
<li><p>新状态：线程对象已经创建，还没有在其上调用start()方法。</p>
</li>
<li><p>可运行状态：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。</p>
</li>
<li><p>运行状态：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。</p>
</li>
<li><p>等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，但是当前没有条件运行。换句话说，它是可运行的，但是如果某件事件出现，他可能返回到可运行状态。</p>
</li>
<li><p>死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p>
</li>
</ul>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><blockquote>
<p>可以使用synchronized和ReentrantLock两种锁实现互斥，达到同步的目的。</p>
</blockquote>
<ul>
<li><p>使用synchronized修饰方法或语句块</p>
<ul>
<li><p>synchronized是一个内置锁的加锁机制，当某个方法加上synchronized关键字后，就表明要获得该内置锁才能执行，但并不能阻止其他线程访问不需要获得该内置锁的方法。</p>
</li>
<li><p>synchronized可以加在方法上，也可以直接加在对象上，从而保证一段代码只能有一个线程在运行，保证线程的同步。</p>
</li>
<li><p>加在对象和加在方法上有什么不同？</p>
<ul>
<li>方法的同步底层是使用ACC_SYNCHRONIZED标识符实现的</li>
<li>对象的同步底层是使用monitorenter和monitorexit两条指令实现的，即每个对象都有一个监视器锁。</li>
</ul>
</li>
<li><p>synchronized加在不同方法上有什么不同？</p>
<ul>
<li>如果synchronized加在一个类的普通方法上，那么相当于synchronized(this)。是一个对象锁。</li>
<li>如果synchronized加载一个类的静态方法上，那么相当于synchronized(Class对象)。是一个类锁，一个类只有一个类锁。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用显式锁ReentrantLock</p>
<ul>
<li>这里是<a href="https://blog.csdn.net/u013014724/article/details/103936025" target="_blank" rel="noopener">synchronized和ReentrantLock的比较</a></li>
</ul>
</li>
</ul>
<h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><ul>
<li>使用CAS算法，见。</li>
</ul>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><ul>
<li><p>Object的wait和notify机制</p>
</li>
<li><p>Condition的等待/通知机制:await,signal,signalAll</p>
</li>
</ul>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><ul>
<li><p>为了并发执行程序，提高执行效率，使用多线程编程，而多线程编程就会涉及到安全问题，比如多个线程访问共享的可变数据的问题。</p>
</li>
<li><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
</li>
<li><p>但是如果不安全，如何实现线程安全呢</p>
<ul>
<li>通过上面的线程同步的方法</li>
<li>使用本地线程存储ThreadLocal</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
</search>
