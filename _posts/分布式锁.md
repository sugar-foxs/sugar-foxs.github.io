---
layout:     post
title:      分布式锁
subtitle:   
date:       2020-03-12
author:     sugar-foxs
catalog: 	true
tags:
    - 分布式
---

在分布式系统中，单进程内的锁已然不能适用，为了防止分布式系统中的多个进程之间相互干扰，分布式锁应运而生。本文主要来学习下分布式锁。

<!-- more -->
# 分布式锁的概念
- 可以先想想我们在单进程内，多个线程操作同一个共享变量时出现的线程安全问题，我们是用来锁来解决。以此类推，在分布式环境下，多个进程之间无法约束访问同一个方法或者同一个资源，会导致安全问题，所以需要第三方进程来实现分布式锁。
- 在分布式系统环境下，一个方法或同一个资源在同一时间只能被一个机器的一个线程执行。
- 分布式锁只是一种思想，它的实现有很多方式。

# 分布式锁的实现
## redis的setnx 命令
- redis锁定的原理是利用setnx命令，能原子的完成加锁和设置过期时间，即只有在某个key不存在情况才能set成功该key，这样就达到了多个进程并发去set同一个key，只有一个进程能set成功。
```java
@Configuration
public class RedisConfig {
    private static final Logger logger = LoggerFactory.getLogger(RedisConfig.class);

    @Bean
    JedisPool getPool() {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        String host = "127.0.0.1";
        int port = 6379;
        JedisPool jedisPool = new JedisPool(jedisPoolConfig, host, port, 5000, null);
        logger.info("初始化JedisPool成功!host:{},port:{} ", host, port);
        return jedisPool;
    }
}

@Service
public class RedisLock {
    private String lockKey = "redis_lock";

    private long internalLockLeaseTime = 30000;

    private SetParams params = SetParams.setParams().nx().px(internalLockLeaseTime);

    @Autowired
    JedisPool jedisPool;
    
    /**
     * 加锁
     * @param id
     * @return
     */
    public boolean lock(String id){
        try (Jedis jedis = jedisPool.getResource()) {
            Long start = System.currentTimeMillis();
            while(true) {
                //SET命令返回OK ，则证明获取锁成功
                String lock = jedis.set(lockKey, id, params);
                if ("OK".equals(lock)) {
                    System.out.println("获取锁成功");
                    return true;
                }
                //否则循环等待，在timeout时间内仍未获取到锁，则获取失败
                long l = System.currentTimeMillis() - start;
                if (l >= 10000) {
                    System.out.println("获取锁超时");
                    return false;
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * 解锁
     * @param id
     * @return
     */
    public boolean unlock(String id){
        Jedis jedis = jedisPool.getResource();
        String script =
                "if redis.call('get',KEYS[1]) == ARGV[1] then" +
                        "   return redis.call('del',KEYS[1]) " +
                        "else" +
                        "   return 0 " +
                        "end";
        try {
            Object result = jedis.eval(script, Collections.singletonList(lockKey),
                    Collections.singletonList(id));
            if("1".equals(result.toString())){
                return true;
            }
            return false;
        }finally {
            jedis.close();
        }
    }
}

@SpringBootTest
class DemoApplicationTests {
    private static final Logger logger = LoggerFactory.getLogger(DemoApplicationTests.class);

    @Autowired
    private RedisLock redisLock;

    private int count=0;

    @Test
    public void testRedisLock() throws InterruptedException {
        int clientCount =10;
        CountDownLatch countDownLatch = new CountDownLatch(clientCount);

        ExecutorService executorService = Executors.newFixedThreadPool(clientCount);
        long start = System.currentTimeMillis();
        for (int i = 0;i<clientCount;i++){
            String id = UUID.randomUUID().toString();

            executorService.execute(() -> {
                try {
                    redisLock.lock(id);
                    count++;
                }finally {
                    redisLock.unlock(id);
                }
                countDownLatch.countDown();
                System.out.println(countDownLatch.getCount());
            });
        }
        countDownLatch.await();
        long end = System.currentTimeMillis();
        logger.info("执行线程数:{},总耗时:{},count数为:{}",clientCount,end-start,count);
    }
}

```
- 这里这是针对单机redis实现的分布式锁，缺点很明显，一旦redis挂了，依赖他的服务都挂了，所以实际生产环境更需要集群环境下的redis分布式锁，下面介绍下redlock算法，java版本可以看下Redisson。

### redlock算法
> 假设有N个Redis master节点，这些节点都是完全独立的，我们不用任何复制或者其他隐含的分布式协调算法。前面已经介绍了如何在单节点环境下安全地获取和释放锁。因此我们应当用这个方法在每个单节点里来获取和释放锁。我们需要在不同的计算机或者虚拟机上运行N个master节点来保证他们大多数情况下都不会同时宕机。
- 假设有5个master节点，一个客户端需要做如下操作来获取锁：
1. 获取当前时间（单位是毫秒）。

2. 轮流用相同的key和随机值在5个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有比总的锁释放时间小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间设置为5-50毫秒的范围，这个可以防止一个客户端在某个宕机的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。

3. 客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（在这里是3个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。

4. 如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。

5. 如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。

- 建议第二步中应该同时向N个Redis实例发出异步的获取锁请求。

## zookeeper的顺序临时节点
- zk节点有临时和持久之分，临时节点表示客户端和服务端断开连接后节点会自动删除，持久节点相反不会删除。
- 不管临时节点还是持久节点，都有顺序和非顺序的节点，顺序节点表示zk会给该节点进行顺序编号。
- 那临时顺序节点是如何实现分布式锁的呢？
    - 创建分布式锁首先会创建一个持久节点作为根节点。
    - 客户端想要获取锁，需要先在根节点下创建一个临时顺序节点，然后查看所有顺序节点，看自己是否是第一个，如果是第一个就拿到了锁，如果不是第一个，获取锁便失败，这时会对自己上一个顺序节点加监听器Watcher，当前一个节点对应的客户端主动释放了锁，或者客户端宕机，相应的临时顺序节点会被删除，这个删除操作会被通知下一个节点的客户端，客户端会重新去获取锁，如果发现自己是第一个节点，便拿到了锁。

- 示例代码
- zk可以使用docker很快的搭建出来。可参考{% post_link docker命令 %}
- 使用了Curator开源框架的分布式锁实现。ZkClient作为获取zk客户端的类。
```java
public class ZkClient {
    public static CuratorFramework build() {
        final String connectString = "127.0.0.1:2181";

        // 重试策略，初始化每次重试之间需要等待的时间，基准等待时间为1秒。
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);

        // 使用默认的会话时间（60秒）和连接超时时间（15秒）来创建 Zookeeper 客户端
        return CuratorFrameworkFactory.builder()
                .connectString(connectString)
                .connectionTimeoutMs(15 * 1000)
                .sessionTimeoutMs(60 * 100)
                .retryPolicy(retryPolicy)
                .build();
    }
}
```

- 用两个线程各自开启zk客户端模拟多个进程。doSomeThing是一个需要加分布式锁的方法。使用睡眠模拟做的事情。
```java
public class ZkLock {
    public static void main(String[] args) {
        new Thread(new TestRunnable()).start();
        new Thread(new TestRunnable()).start();
    }

    private static class TestRunnable implements Runnable {
        @Override
        public void run() {
            try {
                doSomeThing();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public static void doSomeThing() throws Exception {
        CuratorFramework client = ZkClient.build();
        client.start();

        // 根节点如果不存在会自动创建
        final String lockNode = "/test";
        InterProcessMutex lock = new InterProcessMutex(client, lockNode);
        try {
            boolean get = false;
            while (!get){
                // 获取锁加了超时时间，超时之后，临时节点会被删除
                if (lock.acquire(5, TimeUnit.SECONDS)) {
                    Stat stat = client.checkExists().forPath(lockNode);
                    if (null != stat){
                        get = true;
                        System.out.println(Thread.currentThread()+"获取到了锁"+System.currentTimeMillis());
                        Thread.sleep(10000);
                    }
                } else {
                    System.out.println(Thread.currentThread()+"获取锁超时");
                }
            }
        } finally {
            if (lock.isAcquiredInThisProcess()) {
                lock.release();
            }
            client.close();
        }
    }
}
```
- 临时顺序节点是这样的,后面的编号按顺序排列，名字都是lock，这个lock name是curator框架默认的，这个用户也可以自己指定。lock前的一串字符串是curator生成的（这里的编号可用来生成分布式id）
> _c_71fb74e3-a75b-47d1-aa90-f88c19e333e6-lock-0000000001  
_c_88cdcc5b-96d3-4810-8eac-5da5d9a35e3c-lock-0000000002


## Memcached的add指令
- memcached带有add函数，利用add函数的特性即可实现分布式锁。add和set的区别在于：如果多线程并发set，则每个set都会成功，但最后存储的值以最后的set的线程为准。而add的话则相反，add会添加第一个到达的值，并返回true，后续的添加则都会返回false。利用该点即可很轻松地实现分布式锁。
- 缺点：
    - memcached采用列入LRU置换策略，所以如果内存不够，可能导致缓存中的锁信息丢失。
    - memcached无法持久化，一旦重启，将导致信息丢失。
## Chubby：粗粒度分布式锁服务，底层利用了 Paxos 一致性算法
- zookeepr是chubby的开源实现

## 数据库实现分布式锁
- 数据库实现的分布式锁性能比较差，一般不建议使用